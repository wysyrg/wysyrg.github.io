<!DOCTYPE html>
<html lang="en">
    <!-- title -->


    

<!-- keywords -->



<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="John Doe">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="John Doe">
    
        <meta name="keywords" content="hexo,hexo-theme,hexo-blog">
    
    <meta name="description" content="">
    <meta name="description" content="_IO_FILE 参考链接：https:&#x2F;&#x2F;fish-o0o.github.io&#x2F;2019&#x2F;12&#x2F;29&#x2F;FILE%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%8A%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95&#x2F; https:&#x2F;&#x2F;www.yuque.com&#x2F;cyberangel&#x2F;rg9gdm&#x2F;pvp243#EFwc4">
<meta property="og:type" content="article">
<meta property="og:title" content="_IO_FILE">
<meta property="og:url" content="http://example.com/2022/05/14/IO_FILE/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="_IO_FILE 参考链接：https:&#x2F;&#x2F;fish-o0o.github.io&#x2F;2019&#x2F;12&#x2F;29&#x2F;FILE%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%8A%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95&#x2F; https:&#x2F;&#x2F;www.yuque.com&#x2F;cyberangel&#x2F;rg9gdm&#x2F;pvp243#EFwc4">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202205152122219.png">
<meta property="og:image" content="e:/draw_source/1557385923980.png">
<meta property="og:image" content="e:/draw_source/1557480731572.png">
<meta property="article:published_time" content="2022-05-14T11:22:16.893Z">
<meta property="article:modified_time" content="2022-05-16T09:30:04.906Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202205152122219.png">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <link rel="icon" href="/assets/favicon.ico">
    
    <title>_IO_FILE · 渐渐的博客</title>
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
    (function (w) {
        'use strict'
        // rel=preload support test
        if (!w.loadCSS) {
            w.loadCSS = function () {}
        }
        // define on the loadCSS obj
        var rp = (loadCSS.relpreload = {})
        // rel=preload feature support test
        // runs once and returns a function for compat purposes
        rp.support = (function () {
            var ret
            try {
                ret = w.document.createElement('link').relList.supports('preload')
            } catch (e) {
                ret = false
            }
            return function () {
                return ret
            }
        })()

        // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
        // then change that media back to its intended value on load
        rp.bindMediaToggle = function (link) {
            // remember existing media attr for ultimate state, or default to 'all'
            var finalMedia = link.media || 'all'

            function enableStylesheet() {
                link.media = finalMedia
            }

            // bind load handlers to enable media
            if (link.addEventListener) {
                link.addEventListener('load', enableStylesheet)
            } else if (link.attachEvent) {
                link.attachEvent('onload', enableStylesheet)
            }

            // Set rel and non-applicable media type to start an async request
            // note: timeout allows this to happen async to let rendering continue in IE
            setTimeout(function () {
                link.rel = 'stylesheet'
                link.media = 'only x'
            })
            // also enable media after 3 seconds,
            // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
            setTimeout(enableStylesheet, 3000)
        }

        // loop through link elements in DOM
        rp.poly = function () {
            // double check this to prevent external calls from running
            if (rp.support()) {
                return
            }
            var links = w.document.getElementsByTagName('link')
            for (var i = 0; i < links.length; i++) {
                var link = links[i]
                // qualify links to those with rel=preload and as=style attrs
                if (
                    link.rel === 'preload' &&
                    link.getAttribute('as') === 'style' &&
                    !link.getAttribute('data-loadcss')
                ) {
                    // prevent rerunning on link
                    link.setAttribute('data-loadcss', true)
                    // bind listeners to toggle media back
                    rp.bindMediaToggle(link)
                }
            }
        }

        // if unsupported, run the polyfill
        if (!rp.support()) {
            // run once at least
            rp.poly()

            // rerun poly on an interval until onload
            var run = w.setInterval(rp.poly, 500)
            if (w.addEventListener) {
                w.addEventListener('load', function () {
                    rp.poly()
                    w.clearInterval(run)
                })
            } else if (w.attachEvent) {
                w.attachEvent('onload', function () {
                    rp.poly()
                    w.clearInterval(run)
                })
            }
        }

        // commonjs
        if (typeof exports !== 'undefined') {
            exports.loadCSS = loadCSS
        } else {
            w.loadCSS = loadCSS
        }
    })(typeof global !== 'undefined' ? global : this)
</script>

    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }
</style>

    <link rel="preload" href="/css/style.css?v=20210823" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="/css/dark.css?v=20210823" as="style">
    <link rel="stylesheet" href="/css/dark.css" media="(prefers-color-scheme: dark)">
    <link rel="stylesheet" href="/css/mobile.css?v=20210823" media="(max-width: 960px)">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js?v=20210823" as="script">
    <link rel="preload" href="/scripts/dark.js?v=20210823" as="script">
    <link rel="preload" href="/font/Oswald-Regular.ttf" as="font" crossorigin>
    <link rel="preload" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" as="font" crossorigin>
    <!-- algolia -->
    
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
<meta name="generator" content="Hexo 5.4.0"></head>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ == undefined) {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js" />')
        }
    </script>
    
        <body class="post-body">
    
        <!-- header -->
        <header class="header header-mobile">
    <!-- top read progress line -->
    <div class="header-element">
        <div class="read-progress"></div>
    </div>
    <!-- sidebar menu button -->
    <div class="header-element">
        
            <div class="header-sidebar-menu">
        
            
                <div style="padding-left: 1px;">&#xe775;</div>
            
        </div>
    </div>
    <!-- header actions -->
    <div class="header-actions">
        <!-- theme mode switch button -->
        <span class="header-theme-btn header-element">
            <i class="fas fa-adjust"></i>
        </span>
        <!-- back to home page text -->
        <span class="home-link header-element">
            <a href=/>渐渐的博客</a>
        </span>
    </div>
    <!-- toggle banner for post layout -->
    
        
            <div class="banner">
        
            <div class="blog-title header-element">
                <a href="/">渐渐的博客</a>
            </div>
            <div class="post-title header-element">
                <a href="#" class="post-name">_IO_FILE</a>
            </div>
        </div>
    
</header>

        <!-- fixed footer -->
        <footer class="footer-fixed">
    <!-- back to top button -->
    <div class="footer-fixed-element">
        
            <div class="back-top back-top-hidden">
        
        
            <div>&#xe639;</div>
        
        </div>
    </div>
</footer>

        <!-- wrapper -->
        <div class="wrapper">
            <div class="site-intro" style="







    height:50vh;

">
    
    <!-- 主页  -->
    
        
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/wlop1.jpeg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
                _IO_FILE
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
                
            <!-- 404 -->
            
        </p>
        <!-- 文章页 meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                
                    <div class="post-intro-read">
                        <span>Word count: <span class="post-count word-count">15.7k</span>Reading time: <span class="post-count reading-time">72 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <!-- 撰写日期 -->
                    <span class="iconfont-archer post-intro-calander">&#xe676;</span>
                    <span class="post-intro-time">2022/05/14</span>
                    <!-- busuanzi -->
                    
                        <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                            <span class="iconfont-archer post-intro-busuanzi">&#xe602;</span>
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    
                    <!-- 文章分享 -->
                    <span class="share-wrapper">
                        <span class="iconfont-archer share-icon">&#xe71d;</span>
                        <span class="share-text">Share</span>
                        <ul class="share-list">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>

            <script>
  // get user agent
  function getBrowserVersions() {
    var u = window.navigator.userAgent
    return {
      userAgent: u,
      trident: u.indexOf('Trident') > -1, //IE内核
      presto: u.indexOf('Presto') > -1, //opera内核
      webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
      gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
      mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
      ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
      android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
      iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
      iPad: u.indexOf('iPad') > -1, //是否为iPad
      webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
      weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
      uc: u.indexOf('UCBrowser') > -1, //是否为android下的UC浏览器
    }
  }
  var browser = {
    versions: getBrowserVersions(),
  }
  console.log('userAgent: ' + browser.versions.userAgent)

  // callback
  function fontLoaded() {
    console.log('font loaded')
    if (document.getElementsByClassName('site-intro-meta')) {
      document
        .getElementsByClassName('intro-title')[0]
        .classList.add('intro-fade-in')
      document
        .getElementsByClassName('intro-subtitle')[0]
        .classList.add('intro-fade-in')
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in')
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb() {
    if (browser.versions.uc) {
      console.log('UCBrowser')
      fontLoaded()
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular'],
        },
        loading: function () {
          // 所有字体开始加载
          // console.log('font loading');
        },
        active: function () {
          // 所有字体已渲染
          fontLoaded()
        },
        inactive: function () {
          // 字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout')
          fontLoaded()
        },
        timeout: 5000, // Set the timeout to two seconds
      })
    }
  }

  function asyncErr() {
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0]
    o.src = u
    if (cb) {
      o.addEventListener(
        'load',
        function (e) {
          cb(null, e)
        },
        false
      )
    }
    if (err) {
      o.addEventListener(
        'error',
        function (e) {
          err(null, e)
        },
        false
      )
    }
    s.parentNode.insertBefore(o, s)
  }

  var asyncLoadWithFallBack = function (arr, success, reject) {
    var currReject = function () {
      reject()
      arr.shift()
      if (arr.length) async(arr[0], success, currReject)
    }

    async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack(
    [
      'https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js',
      'https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js',
      "/lib/webfontloader.min.js",
    ],
    asyncCb,
    asyncErr
  )
</script>

            <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
            <div class="container container-unloaded">
                <main class="main post-page">
    <article class="article-entry">
        <h2 id="IO-FILE"><a href="#IO-FILE" class="headerlink" title="_IO_FILE"></a>_IO_FILE</h2><blockquote>
<p>参考链接：<a target="_blank" rel="noopener" href="https://fish-o0o.github.io/2019/12/29/FILE%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%8A%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/">https://fish-o0o.github.io/2019/12/29/FILE%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%8A%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/cyberangel/rg9gdm/pvp243#EFwc4">https://www.yuque.com/cyberangel/rg9gdm/pvp243#EFwc4</a></p>
<p><a target="_blank" rel="noopener" href="https://ray-cp.github.io/archivers/IO_FILE_fclose_analysis">https://ray-cp.github.io/archivers/IO_FILE_fclose_analysis</a></p>
</blockquote>
<h2 id="IO-FILE-1"><a href="#IO-FILE-1" class="headerlink" title="_IO_FILE"></a>_IO_FILE</h2><p>FILE结构的利用是一种通用的控制流劫持技术。攻击者可以覆盖堆上的FILE指针使其指向一个伪造的结构，并通过结构中一个名为vtable的指针，来执行任意代码。</p>
<h3 id="FILE介绍"><a href="#FILE介绍" class="headerlink" title="FILE介绍"></a>FILE介绍</h3><p>FILE 在 Linux 系统的标准 IO 库中是用于描述文件的结构，称为文件流。 FILE 结构在程序执行 fopen()、fread()、fclose() 等函数时会进行创建，并分配在堆中。我们常定义一个指向 FILE 结构的指针来接收这个返回值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   /libio/libio.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;		<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;	<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;	<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;	<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base;	<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;	<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;	<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;	<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;	<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _fileno;               #文件描述符</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="keyword">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> _cur_column;  #表示文件流中文件的行数</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;  #虚表指针偏移</span><br><span class="line">  <span class="keyword">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;        <span class="meta"># lock结构体</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001</span></span><br><span class="line">  _IO_off64_t _offset;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="keyword">void</span> *_freeres_buf;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">void</span> *__pad1;</span><br><span class="line">  <span class="keyword">void</span> *__pad2;</span><br><span class="line">  <span class="keyword">void</span> *__pad3;</span><br><span class="line">  <span class="keyword">void</span> *__pad4;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">size_t</span> __pad5;</span><br><span class="line">  <span class="keyword">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="keyword">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="keyword">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="keyword">void</span> *) - <span class="keyword">sizeof</span> (<span class="keyword">size_t</span>)];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">IO_FILE</span>;</span>  <span class="comment">//可以看到_IO_FILE结构体其实就是_IO_FILE结构体。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中**_flags<strong>字段标志了该</strong>FILE<strong>结构体的读写等属性，该字段的前</strong>2<strong>个字节固定为</strong><code>0xFBAD</code><strong>的魔术头，其具体数值在</strong><code>glibc/libio/libio.h</code>**中进行宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Magic numbers and bits for the _flags field.</span></span><br><span class="line"><span class="comment">   The magic numbers use the high-order bits of _flags;</span></span><br><span class="line"><span class="comment">   the remaining bits are available for variable flags.</span></span><br><span class="line"><span class="comment">   Note: The magic numbers must all be negative if stdio</span></span><br><span class="line"><span class="comment">   emulation is desired. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_MAGIC 0xFBAD0000 <span class="comment">/* Magic number */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _OLD_STDIO_MAGIC 0xFABC0000 <span class="comment">/* Emulate old stdio. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_MAGIC_MASK 0xFFFF0000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_USER_BUF 1 <span class="comment">/* User owns buffer; don&#x27;t delete it on close. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_UNBUFFERED 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_NO_READS 4 <span class="comment">/* Reading not allowed */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_NO_WRITES 8 <span class="comment">/* Writing not allowd */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_EOF_SEEN 0x10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_ERR_SEEN 0x20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_DELETE_DONT_CLOSE 0x40 <span class="comment">/* Don&#x27;t call close(_fileno) on cleanup. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_LINKED 0x80 <span class="comment">/* Set if linked (using _chain) to streambuf::_list_all.*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_IN_BACKUP 0x100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_LINE_BUF 0x200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_TIED_PUT_GET 0x400 <span class="comment">/* Set if put and get pointer logicly tied. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_CURRENTLY_PUTTING 0x800</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_IS_APPENDING 0x1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_IS_FILEBUF 0x2000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_BAD_SEEN 0x4000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_USER_LOCK 0x8000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_FLAGS2_MMAP 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_FLAGS2_NOTCANCEL 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> _IO_FLAGS2_FORTIFY 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>_IO_read_ptr</strong>字段为输入缓冲区的当前地址<br><strong>_IO_read_end</strong>字段为输入缓冲区的结束地址<br><strong>_IO_read_base</strong>字段为输入缓冲区的起始地址<br><strong>_IO_write_base</strong>字段为输出缓冲区的起始地址<br><strong>_IO_write_ptr</strong>字段为输出缓冲区的当前地址<br><strong>_IO_write_end</strong>字段为输出缓冲区的结束地址<br><strong>_IO_buf_base</strong>字段为输入输出缓冲区的起始地址<br><strong>_IO_buf_end</strong>字段为输入输出缓冲区的结束地址<br><strong>_IO_save_base</strong>  备份缓冲区的起始地址<br> <strong>_IO_backup_base</strong>  备份缓冲区的第一个有效字符的指针<br> <strong>_IO_save_end</strong>  备份缓冲区的起始地址</p>
<p><strong>_chain</strong>字段为指向下一个**_IO_FILE<strong>结构体的指针，在</strong><code>gilbc/libio/libioP.h</code>**中有如下声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> *_<span class="title">IO_list_all</span>;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p> <code>_IO_FILE_plus</code>是<strong>FILE</strong>结构体的外层的一个结构体。该结构体在**<code>glibc/libio/libioP.h</code>**中定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We always allocate an extra word following an _IO_FILE.</span></span><br><span class="line"><span class="comment">   This contains a pointer to the function jump table used.</span></span><br><span class="line"><span class="comment">   This is for compatibility with C++ streambuf; the word can</span></span><br><span class="line"><span class="comment">   be used to smash to a pointer to a virtual function table. */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>中间包含了一个我们常说的<strong>FILE</strong>结构体，以及**_IO_jump_t**的一个虚表结构体。<code>vtable</code>指向的函数跳转表其实是一种兼容C++虚函数的实现。当程序对某个流进行操作时，会调用该流对应的跳转表中的某个函数。该虚表结构体如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![iofile1](E:\draw_source\iofile1.png)</span><br><span class="line"></span><br><span class="line">值得注意的是，在**_IO_FILE**结构体定义的内部有一个宏`#ifdef _IO_USE_OLD_IO_FILE`，如果不存在**`_IO_USE_OLD_IO_FILE`**的宏定义，则会将后面的**&#125;**以及下一个结构体**`_IO_FILE_complete`**的定义头给跳过，即扩充了**_IO_FILE**结构体，使其拥有了更多的字段。**`_IO_2_1_stdin`**、**`_IO_2_1_stdout`**、**`_IO_2_1_stderr`**的**FILE**结构体均为扩展后的。</span><br><span class="line"></span><br><span class="line">上图中所有FILE结构体的虚表指针均指向虚表`_IO_file_jumps`,在进行IO操作时，都会调用该结构体中的函数</span><br><span class="line"></span><br><span class="line">### fopen</span><br><span class="line"></span><br><span class="line">`fopen`为`stdio`库中的函数，其在**`glibc/include/stdio.h`**中宏定义如下：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#   define fopen(fname, mode) _IO_new_fopen (fname, mode)</span><br></pre></td></tr></table></figure>

<p>由<code>stdio.h</code>宏定义可知，平时我们常用的<code>fopen</code>函数其实为定义在**<code>glibc/libio/iofopen.c</code><strong>中的</strong><code>_IO_new_fopen</code><strong>函数，该函数直接调用了</strong><code>__fopen_internal</code>**函数。</p>
<h4 id="IO-new-fopen-gt-fopen-internal"><a href="#IO-new-fopen-gt-fopen-internal" class="headerlink" title="_IO_new_fopen-&gt;__fopen_internal"></a><code>_IO_new_fopen-&gt;__fopen_internal</code></h4><p>整个<code>__fopen_internal</code>函数包含四个部分：</p>
<ol>
<li><code>malloc</code>分配内存空间。</li>
<li><code>_IO_no_init</code> 对file结构体进行<code>null</code>初始化。</li>
<li><code>_IO_file_init</code>将结构体链接进<code>_IO_list_all</code>链表。</li>
<li><code>_IO_file_fopen</code>执行系统调用打开文件。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">_IO_FILE * _IO_new_fopen (<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __fopen_internal (filename, mode, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_IO_FILE *</span><br><span class="line">__fopen_internal (<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode, <span class="keyword">int</span> is32)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">locked_FILE</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">fp</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_lock_t lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> <span class="title">wd</span>;</span></span><br><span class="line">  &#125; *new_f = (struct locked_FILE *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (struct locked_FILE)); <span class="comment">// step 1 分配内存</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (new_f == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  new_f-&gt;fp.file._lock = &amp;new_f-&gt;lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  _IO_no_init (&amp;new_f-&gt;fp.file, <span class="number">0</span>, <span class="number">0</span>, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);    #<span class="meta"># step 2 null初始化结构体数据</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  _IO_no_init (&amp;new_f-&gt;fp.file, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;              ## 设置vtable为_IO_file_jumps</span><br><span class="line">  _IO_new_file_init_internal (&amp;new_f-&gt;fp);              #<span class="meta"># step 3 将file结构体链接进去_IO_list_all</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>  !_IO_UNIFIED_JUMPTABLES</span></span><br><span class="line">  new_f-&gt;fp.vtable = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (_IO_file_fopen ((_IO_FILE *) new_f, filename, mode, is32) != <span class="literal">NULL</span>)        <span class="meta"># step 4 打开文件</span></span><br><span class="line">    <span class="keyword">return</span> __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);</span><br><span class="line"></span><br><span class="line">  _IO_un_link (&amp;new_f-&gt;fp);</span><br><span class="line">  <span class="built_in">free</span> (new_f);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>__fopen_internal</code>函数中首先声明了一个<code>locked_FILE</code>结构体变量指针<code>new_f</code>,该结构体中主要包含了<code>_IO_FILE_plus</code>和<code>_IO_wide_data</code>两个结构，并为该声明的变量分配了空间。</p>
<h4 id="IO-new-fopen-gt-fopen-internal-gt-IO-no-init"><a href="#IO-new-fopen-gt-fopen-internal-gt-IO-no-init" class="headerlink" title="_IO_new_fopen-&gt;__fopen_internal-&gt;_IO_no_init"></a><code>_IO_new_fopen-&gt;__fopen_internal-&gt;_IO_no_init</code></h4><p><code>_IO_no_init (&amp;new_f-&gt;fp.file, 1, 0, NULL, NULL);</code>该行中<code>__fopen_internal</code>函数调用了<code>__IO_no_init</code>函数对新申请的locked_FILE结构体进行了初始化，该函数在**<code>glibc/libio/genops.c</code>**中定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_IO_no_init (_IO_FILE *fp, <span class="keyword">int</span> flags, <span class="keyword">int</span> orientation,</span><br><span class="line">	     struct _IO_wide_data *wd, <span class="keyword">const</span> struct _IO_jump_t *jmp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_old_init (fp, flags);</span><br><span class="line">  fp-&gt;_mode = orientation;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="keyword">if</span> (orientation &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_wide_data = wd;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_backup_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_save_end = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      fp-&gt;_wide_data-&gt;_wide_vtable = jmp;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">/* Cause predictable crash when a wide function is called on a byte</span></span><br><span class="line"><span class="comment">       stream.  */</span></span><br><span class="line">    fp-&gt;_wide_data = (struct _IO_wide_data *) <span class="number">-1L</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  fp-&gt;_freeres_list = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="IO-new-fopen-gt-fopen-internal-gt-IO-no-init-gt-IO-old-init"><a href="#IO-new-fopen-gt-fopen-internal-gt-IO-no-init-gt-IO-old-init" class="headerlink" title="_IO_new_fopen-&gt;__fopen_internal-&gt;_IO_no_init-&gt;_IO_old_init"></a><code>_IO_new_fopen-&gt;__fopen_internal-&gt;_IO_no_init-&gt;_IO_old_init</code></h4><p>其中调用的_IO_old_init函数定义其上方：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_IO_old_init (_IO_FILE *fp, <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">  fp-&gt;_flags = _IO_MAGIC|flags;</span><br><span class="line">  fp-&gt;_flags2 = <span class="number">0</span>;</span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_ptr = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_ptr = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_chain = <span class="literal">NULL</span>; <span class="comment">/* Not necessary. */</span></span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_backup_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_save_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_markers = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_cur_column = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _IO_JUMPS_OFFSET</span></span><br><span class="line">  fp-&gt;_vtable_offset = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">    _IO_lock_init (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_IO_old_init</code>函数主要是对<code>_IO_FILE_plus</code>结构体中的各个元素进行初始化，而<code>_IO_no_init</code>主要是对<code>_IO_wide_data</code>结构体中的各个元素进行初始化。通过两个结构体的初始化，初步猜测，**<code>_IO_FILE_plus</code><strong>结构体中元素及虚表主要用于单字节的文件流处理流程中，</strong><code>_IO_wide_data</code>**结构体中的元素及虚表主要用于宽字节的文件流处理流程中。</p>
<blockquote>
<p>**<code>_IO_wide_data</code>**定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Extra data for wide character streams.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_read_ptr;	<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_read_end;	<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_read_base;	<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_write_base;	<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_write_ptr;	<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_write_end;	<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_buf_base;	<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_buf_end;		<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_save_base;	<span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_backup_base;	<span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">				   backup area */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_save_end;	<span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="keyword">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> _<span class="title">codecvt</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>**<code>__fopen_internal</code><strong>函数中 <code>_IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;</code>调用了</strong><code>_IO_JUMPS</code><strong>函数对结构体的虚表进行了初始化，</strong><code>_IO_JUMPS</code><strong>函数在</strong><code>glibc/libio/libioP.h</code>**中宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_JUMPS(THIS) (THIS)-&gt;vtable</span></span><br></pre></td></tr></table></figure>

<p>即将**<code>_IO_FILE_plus</code><strong>结构体中的虚表指针赋值为虚表</strong><code>_IO_file_jumps</code>**的地址。</p>
<p><code>_IO_file_jumps</code>定义如下<code>extern const struct _IO_jump_t _IO_file_jumps;</code></p>
<h4 id="IO-new-fopen-gt-fopen-internal-gt-IO-new-file-init-internal"><a href="#IO-new-fopen-gt-fopen-internal-gt-IO-new-file-init-internal" class="headerlink" title="_IO_new_fopen-&gt;__fopen_internal-&gt;_IO_new_file_init_internal"></a><code>_IO_new_fopen-&gt;__fopen_internal-&gt;_IO_new_file_init_internal</code></h4><p><code>__fopen_internal</code>函数中 <code>_IO_new_file_init_internal (&amp;new_f-&gt;fp);</code>调用<code>_IO_new_file_init_internal</code>函数将新初始化的结构体链入<code>_IO_list_all</code>链表的头部，该函数在**<code>glibc/libio/fileops.c</code>**中定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_IO_new_file_init_internal (struct _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* POSIX.1 allows another file handle to be used to change the position</span></span><br><span class="line"><span class="comment">     of our file descriptor.  Hence we actually don&#x27;t know the actual</span></span><br><span class="line"><span class="comment">     position before we do the first fseek (and until a following fflush). */</span></span><br><span class="line">  fp-&gt;file._offset = _IO_pos_BAD;</span><br><span class="line">  fp-&gt;file._IO_file_flags |= CLOSED_FILEBUF_FLAGS;</span><br><span class="line"></span><br><span class="line">  _IO_link_in (fp);</span><br><span class="line">  fp-&gt;file._fileno = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该函数主要实现了将初始化好的**<code>_IO_FILE_plus</code><strong>结构体链入</strong><code>_IO_list_all</code><strong>链表头部的功能，其中链入链表的功能主要是由</strong><code>_IO_link_in</code><strong>函数进行实现，该函数定义在</strong><code>glibc/libio/genops.c</code><strong>中。除了实现链入功能外，还对</strong><code>_IO_FILE_plus</code><strong>结构体加入了相应的属性，如</strong><code>CLOSED_FILEBUF_FLAGS</code><strong>(可关闭？)属性以及</strong>_IO_link_in<strong>函数中的</strong><code>_IO_LINKED</code><strong>已链接属性。并对</strong><code>_fileno</code><strong>函数赋值为</strong>-1<strong>，该字段代表该文件流在</strong><code>_IO_list_all</code><strong>链表中的序号，此处赋值为</strong>-1<strong>相当于对该字段进行一个非法数值的初始化，后面会有</strong><code>_IO_file_is_open</code><strong>函数专门对</strong><code>_fileno</code><strong>数值是否合法进行</strong>check**。</p>
<blockquote>
<p><code>_IO_pos_BAD</code>定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* _IO_pos_BAD is an _IO_off64_t value indicating error, unknown, or EOF. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _IO_pos_BAD</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> _IO_pos_BAD ((_IO_off64_t) -1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="IO-new-fopen-gt-fopen-internal-gt-IO-new-file-init-internal-gt-IO-link-in"><a href="#IO-new-fopen-gt-fopen-internal-gt-IO-new-file-init-internal-gt-IO-link-in" class="headerlink" title="_IO_new_fopen-&gt;__fopen_internal-&gt;_IO_new_file_init_internal -&gt;_IO_link_in"></a><code>_IO_new_fopen-&gt;__fopen_internal-&gt;_IO_new_file_init_internal -&gt;_IO_link_in</code></h4><blockquote>
<p><code>_IO_link_in</code>定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_IO_link_in (struct _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((fp-&gt;file._flags &amp; _IO_LINKED) == <span class="number">0</span>)  <span class="comment">// 检查flag的标志位是否是_IO_LINKED</span></span><br><span class="line"> &#123;</span><br><span class="line">   fp-&gt;file._flags |= _IO_LINKED;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">   _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">   _IO_lock_lock (list_all_lock);</span><br><span class="line">   run_fp = (_IO_FILE *) fp;</span><br><span class="line">   _IO_flockfile ((_IO_FILE *) fp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   fp-&gt;file._chain = (_IO_FILE *) _IO_list_all;</span><br><span class="line">   _IO_list_all = fp;</span><br><span class="line">   ++_IO_list_all_stamp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">   _IO_funlockfile ((_IO_FILE *) fp);</span><br><span class="line">   run_fp = <span class="literal">NULL</span>;</span><br><span class="line">   _IO_lock_unlock (list_all_lock);</span><br><span class="line">   _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前一直都知道FILE结构体是通过<code>_IO_list_all</code>的单链表进行管理的，这里<code>_IO_link_in</code>函数的功能是检查FILE结构体是否包含<code>_IO_LINKED</code>标志，如果不包含则表示这个结构体没有链接进入<code>_IO_list_all</code>，则再后面把它链接进入<code>_IO_list_all</code>链表，同时设置FILE结构体的<code>_chain</code>字段为之前的链表的值，否则直接返回。</p>
</blockquote>
<h4 id="IO-new-fopen-gt-fopen-internal-gt-IO-new-file-fopen"><a href="#IO-new-fopen-gt-fopen-internal-gt-IO-new-file-fopen" class="headerlink" title="_IO_new_fopen-&gt;__fopen_internal-&gt;_IO_new_file_fopen"></a><code>_IO_new_fopen-&gt;__fopen_internal-&gt;_IO_new_file_fopen</code></h4><p>**<code>__fopen_internal</code><strong>函数中调用了</strong><code>_IO_file_open</code>**函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_IO_file_fopen ((_IO_FILE *) new_f, filename, mode, is32) != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>开始执行真正意义上的**<code>fopen</code><strong>操作，该函数在</strong><code>glibc/libio/fileops.c</code>**中定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> _IO_new_file_fopen _IO_file_fopen</span></span><br><span class="line"></span><br><span class="line">versioned_symbol (libc, _IO_new_file_fopen, _IO_file_fopen, GLIBC_2_1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_IO_FILE *</span><br><span class="line">_IO_new_file_fopen (_IO_FILE *fp, <span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode,</span><br><span class="line">		    <span class="keyword">int</span> is32not64)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> oflags = <span class="number">0</span>, omode;</span><br><span class="line">  <span class="keyword">int</span> read_write;</span><br><span class="line">  <span class="keyword">int</span> oprot = <span class="number">0666</span>;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  _IO_FILE *result;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *cs;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *last_recognized;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_IO_file_is_open (fp))  <span class="comment">//检查文件是否以打开，打开则返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">switch</span> (*mode)  <span class="comment">// 设置文件打开模式</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">      omode = O_RDONLY;</span><br><span class="line">      read_write = _IO_NO_WRITES;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">      omode = O_WRONLY;</span><br><span class="line">      oflags = O_CREAT|O_TRUNC;</span><br><span class="line">      read_write = _IO_NO_READS;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">      omode = O_WRONLY;</span><br><span class="line">      oflags = O_CREAT|O_APPEND;</span><br><span class="line">      read_write = _IO_NO_READS|_IO_IS_APPENDING;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line">  last_recognized = mode;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">7</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">switch</span> (*++mode)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;\0&#x27;</span>:</span><br><span class="line">	  <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">	  omode = O_RDWR;</span><br><span class="line">	  read_write &amp;= _IO_IS_APPENDING;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line">	  last_recognized = mode;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">	  oflags |= O_EXCL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line">	  last_recognized = mode;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line">	  last_recognized = mode;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:</span><br><span class="line">	  fp-&gt;_flags2 |= _IO_FLAGS2_MMAP;</span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">	  fp-&gt;_flags2 |= _IO_FLAGS2_NOTCANCEL;</span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> O_CLOEXEC</span></span><br><span class="line">	  oflags |= O_CLOEXEC;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	  fp-&gt;_flags2 |= _IO_FLAGS2_CLOEXEC;</span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	  <span class="comment">/* Ignore.  */</span></span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//调用_IO_file_open函数</span></span><br><span class="line">  result = _IO_file_open (fp, filename, omode|oflags, oprot, read_write,</span><br><span class="line">			  is32not64);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ASSUME_O_CLOEXEC</span></span><br><span class="line">      <span class="keyword">if</span> ((fp-&gt;_flags2 &amp; _IO_FLAGS2_CLOEXEC) != <span class="number">0</span> &amp;&amp; __have_o_cloexec &lt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">int</span> fd = _IO_fileno (fp);</span><br><span class="line">	  <span class="keyword">if</span> (__have_o_cloexec == <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">int</span> flags = __fcntl (fd, F_GETFD);</span><br><span class="line">	      __have_o_cloexec = (flags &amp; FD_CLOEXEC) == <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="keyword">if</span> (__have_o_cloexec &lt; <span class="number">0</span>)</span><br><span class="line">	    __fcntl (fd, F_SETFD, FD_CLOEXEC);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Test whether the mode string specifies the conversion.  */</span></span><br><span class="line">      cs = <span class="built_in">strstr</span> (last_recognized + <span class="number">1</span>, <span class="string">&quot;,ccs=&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (cs != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Yep.  Load the appropriate conversions and set the orientation</span></span><br><span class="line"><span class="comment">	     to wide.  */</span></span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> <span class="title">gconv_fcts</span> <span class="title">fcts</span>;</span></span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cc</span>;</span></span><br><span class="line">	  <span class="keyword">char</span> *endp = __strchrnul (cs + <span class="number">5</span>, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">	  <span class="keyword">char</span> *ccs = <span class="built_in">malloc</span> (endp - (cs + <span class="number">5</span>) + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (ccs == <span class="literal">NULL</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">int</span> malloc_err = errno;  <span class="comment">/* Whatever malloc failed with.  */</span></span><br><span class="line">	      (<span class="keyword">void</span>) _IO_file_close_it (fp);</span><br><span class="line">	      __set_errno (malloc_err);</span><br><span class="line">	      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  *((<span class="keyword">char</span> *) __mempcpy (ccs, cs + <span class="number">5</span>, endp - (cs + <span class="number">5</span>))) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	  strip (ccs, ccs);</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (__wcsmbs_named_conv (&amp;fcts, ccs[<span class="number">2</span>] == <span class="string">&#x27;\0&#x27;</span></span><br><span class="line">				   ? upstr (ccs, cs + <span class="number">5</span>) : ccs) != <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="comment">/* Something went wrong, we cannot load the conversion modules.</span></span><br><span class="line"><span class="comment">		 This means we cannot proceed since the user explicitly asked</span></span><br><span class="line"><span class="comment">		 for these.  */</span></span><br><span class="line">	      (<span class="keyword">void</span>) _IO_file_close_it (fp);</span><br><span class="line">	      <span class="built_in">free</span> (ccs);</span><br><span class="line">	      __set_errno (EINVAL);</span><br><span class="line">	      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="built_in">free</span> (ccs);</span><br><span class="line"></span><br><span class="line">	  assert (fcts.towc_nsteps == <span class="number">1</span>);</span><br><span class="line">	  assert (fcts.tomb_nsteps == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	  fp-&gt;_wide_data-&gt;_IO_read_ptr = fp-&gt;_wide_data-&gt;_IO_read_end;</span><br><span class="line">	  fp-&gt;_wide_data-&gt;_IO_write_ptr = fp-&gt;_wide_data-&gt;_IO_write_base;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Clear the state.  We start all over again.  */</span></span><br><span class="line">	  <span class="built_in">memset</span> (&amp;fp-&gt;_wide_data-&gt;_IO_state, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span> (<span class="keyword">__mbstate_t</span>));</span><br><span class="line">	  <span class="built_in">memset</span> (&amp;fp-&gt;_wide_data-&gt;_IO_last_state, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span> (<span class="keyword">__mbstate_t</span>));</span><br><span class="line"></span><br><span class="line">	  cc = fp-&gt;_codecvt = &amp;fp-&gt;_wide_data-&gt;_codecvt;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* The functions are always the same.  */</span></span><br><span class="line">	  *cc = __libio_codecvt;</span><br><span class="line"></span><br><span class="line">	  cc-&gt;__cd_in.__cd.__nsteps = fcts.towc_nsteps;</span><br><span class="line">	  cc-&gt;__cd_in.__cd.__steps = fcts.towc;</span><br><span class="line"></span><br><span class="line">	  cc-&gt;__cd_in.__cd.__data[<span class="number">0</span>].__invocation_counter = <span class="number">0</span>;</span><br><span class="line">	  cc-&gt;__cd_in.__cd.__data[<span class="number">0</span>].__internal_use = <span class="number">1</span>;</span><br><span class="line">	  cc-&gt;__cd_in.__cd.__data[<span class="number">0</span>].__flags = __GCONV_IS_LAST;</span><br><span class="line">	  cc-&gt;__cd_in.__cd.__data[<span class="number">0</span>].__statep = &amp;result-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line"></span><br><span class="line">	  cc-&gt;__cd_out.__cd.__nsteps = fcts.tomb_nsteps;</span><br><span class="line">	  cc-&gt;__cd_out.__cd.__steps = fcts.tomb;</span><br><span class="line"></span><br><span class="line">	  cc-&gt;__cd_out.__cd.__data[<span class="number">0</span>].__invocation_counter = <span class="number">0</span>;</span><br><span class="line">	  cc-&gt;__cd_out.__cd.__data[<span class="number">0</span>].__internal_use = <span class="number">1</span>;</span><br><span class="line">	  cc-&gt;__cd_out.__cd.__data[<span class="number">0</span>].__flags</span><br><span class="line">	    = __GCONV_IS_LAST | __GCONV_TRANSLIT;</span><br><span class="line">	  cc-&gt;__cd_out.__cd.__data[<span class="number">0</span>].__statep =</span><br><span class="line">	    &amp;result-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* From now on use the wide character callback functions.  */</span></span><br><span class="line">	  _IO_JUMPS_FILE_plus (fp) = fp-&gt;_wide_data-&gt;_wide_vtable;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Set the mode now.  */</span></span><br><span class="line">	  result-&gt;_mode = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>_IO_new_file_fopen</code><strong>有</strong>4</strong>个参数，分别是文件指针、文件名、属性、是否为<strong>32</strong>位，其中第一个参数为前面步骤初始化的**_IO_FILE<strong>结构体指针，第</strong>2、3<strong>两个参数为用户在调用</strong><code>stdio.h</code><strong>中</strong><code>fopen</code><strong>函数传入的参数，第四个参数为</strong><code>glibc/libio</code>、<code>iofopen.c</code><strong>中</strong><code>_IO_new_fopen</code><strong>函数调用</strong><code>__fopen_internal</code><strong>函数时传入的常量</strong>1<strong>。该段代码除了声明变量外主要进行了</strong>2<strong>个操作：检查该文件流是否打开、根据调用参数的主属性为该文件流添加</strong>flag**。</p>
<h4 id="IO-new-fopen-gt-fopen-internal-gt-IO-new-file-fopen-gt-IO-file-is-open"><a href="#IO-new-fopen-gt-fopen-internal-gt-IO-new-file-fopen-gt-IO-file-is-open" class="headerlink" title="_IO_new_fopen-&gt;__fopen_internal-&gt;_IO_new_file_fopen-&gt;_IO_file_is_open"></a><code>_IO_new_fopen-&gt;__fopen_internal-&gt;_IO_new_file_fopen-&gt;_IO_file_is_open</code></h4><p>第一个操作通过调用**<code>_IO_file_is_open</code><strong>函数来实现，该函数在</strong><code>glibc/libio/libioP.h</code>**中宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_is_open(__fp) ((__fp)-&gt;_fileno != -1)</span></span><br></pre></td></tr></table></figure>

<p>即通过检查<strong>FILE</strong>结构体的**<code>_fileno</code>**是否为合法序号来判断检该文件流是否为已打开状态。</p>
<p>第二个操作则是通过<strong>mode</strong>，即<strong>fopen</strong>函数第二个参数的第一个字符来确定该文件流的属性，并添加对应的<strong>flag</strong>。在写入<strong>flag</strong>字段前，代码中有<strong>3</strong>个比那里那个来分别存储不同的属性，这三个变量分别是<strong>omode</strong>、<strong>oflags</strong>、<strong>read_write</strong>，其中<strong>omode</strong>标志文件的读写属性，<strong>oflags</strong>标志文件的修改方式，<strong>read_write</strong>标志文件内容的读写方式。有如下对应关系：</p>
<table>
<thead>
<tr>
<th><strong>mode</strong></th>
<th><strong>omode</strong></th>
<th><strong>oflags</strong></th>
<th><strong>read_write</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>r</strong></td>
<td><strong>O_RDONLY</strong>(只读)</td>
<td><strong>NULL</strong>(无)</td>
<td><strong>_IO_NO_WRITES</strong>(不给写)</td>
</tr>
<tr>
<td><strong>w</strong></td>
<td><strong>O_WRONLY</strong>(只写)</td>
<td><strong>O_CREAT|O_TRUNC</strong>(新建/覆盖)</td>
<td><strong>_IO_NO_READS</strong>(不给读)</td>
</tr>
<tr>
<td><strong>a</strong></td>
<td><strong>O_WRONLY</strong>(只写)</td>
<td><strong>O_CREAT|O_APPEND</strong>(新建/追加)</td>
<td><strong>_IO_NO_READS|_IO_IS_APPENDING</strong>(不给读/给追加)</td>
</tr>
</tbody></table>
<p>_IO_new_file_fopen继续往后走，代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">7</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">switch</span> (*++mode)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;\0&#x27;</span>:</span><br><span class="line">	  <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">	  omode = O_RDWR;</span><br><span class="line">	  read_write &amp;= _IO_IS_APPENDING;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line">	  last_recognized = mode;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">	  oflags |= O_EXCL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line">	  last_recognized = mode;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line">	  last_recognized = mode;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:</span><br><span class="line">	  fp-&gt;_flags2 |= _IO_FLAGS2_MMAP;</span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">	  fp-&gt;_flags2 |= _IO_FLAGS2_NOTCANCEL;</span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> O_CLOEXEC</span></span><br><span class="line">	  oflags |= O_CLOEXEC;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	  fp-&gt;_flags2 |= _IO_FLAGS2_CLOEXEC;</span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	  <span class="comment">/* Ignore.  */</span></span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  result = _IO_file_open (fp, filename, omode|oflags, oprot, read_write,</span><br><span class="line">			  is32not64);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该段代码主要进行了<strong>2</strong>个操作：通过文件流副属性获取对应的<strong>flag</strong>、调用**_IO_file_open**函数打开文件。第一个操作与主属性的表示相似，副属性有如下的对应关系：</p>
<table>
<thead>
<tr>
<th><strong>mode</strong></th>
<th><strong>omode</strong></th>
<th><strong>oflags</strong></th>
<th><strong>read_write</strong></th>
<th><strong>_flags2</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>+</strong></td>
<td><strong>O_RDWR</strong>(可读可写)</td>
<td>不变</td>
<td><strong>&amp;_IO_IS_APPENDING</strong></td>
<td>不变</td>
</tr>
<tr>
<td><strong>x</strong></td>
<td>不变</td>
<td><strong>O_EXCL</strong></td>
<td>不变</td>
<td>不变</td>
</tr>
<tr>
<td><strong>b</strong></td>
<td>不变</td>
<td>不变</td>
<td>不变</td>
<td>不变</td>
</tr>
<tr>
<td><strong>m</strong></td>
<td>不变</td>
<td>不变</td>
<td>不变</td>
<td><strong>_IO_FLAGS32_MMAP</strong></td>
</tr>
<tr>
<td><strong>c</strong></td>
<td>不变</td>
<td>不变</td>
<td>不变</td>
<td><strong>_IO_FLAGS2_NOTCANCEL</strong></td>
</tr>
<tr>
<td><strong>e</strong></td>
<td>不变</td>
<td><strong>O_CLOEXEC</strong></td>
<td>不变</td>
<td><strong>_IO_FLAGS2_CLOEXEC</strong></td>
</tr>
</tbody></table>
<h4 id="IO-new-fopen-gt-fopen-internal-gt-IO-new-file-fopen-gt-IO-file-open"><a href="#IO-new-fopen-gt-fopen-internal-gt-IO-new-file-fopen-gt-IO-file-open" class="headerlink" title="_IO_new_fopen-&gt;__fopen_internal-&gt;_IO_new_file_fopen-&gt;_IO_file_open"></a><code>_IO_new_fopen-&gt;__fopen_internal-&gt;_IO_new_file_fopen-&gt;_IO_file_open</code></h4><p>在将所有附属性遍历完后，会调用**_IO_file_open<strong>函数用于打开文件并返回句柄，该函数有6个参数，该函数在</strong>glibc/libio/fileops.c**中定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">_IO_FILE *</span><br><span class="line">_IO_file_open (_IO_FILE *fp, <span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> posix_mode, <span class="keyword">int</span> prot,</span><br><span class="line">	       <span class="keyword">int</span> read_write, <span class="keyword">int</span> is32not64)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> fdesc;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL))</span><br><span class="line">    fdesc = open_not_cancel (filename,</span><br><span class="line">			     posix_mode | (is32not64 ? <span class="number">0</span> : O_LARGEFILE), prot);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    fdesc = open (filename, posix_mode | (is32not64 ? <span class="number">0</span> : O_LARGEFILE), prot);  <span class="comment">//调用系统函数open打开文件  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  fdesc = open (filename, posix_mode, prot);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (fdesc &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_fileno = fdesc; <span class="comment">// 将文件描述符设置到FILE结构体的相应字段_fileno里</span></span><br><span class="line">  _IO_mask_flags (fp, read_write,_IO_NO_READS+_IO_NO_WRITES+_IO_IS_APPENDING);</span><br><span class="line">  <span class="comment">/* For append mode, send the file offset to the end of the file.  Don&#x27;t</span></span><br><span class="line"><span class="comment">     update the offset cache though, since the file handle is not active.  */</span></span><br><span class="line">  <span class="keyword">if</span> ((read_write &amp; (_IO_IS_APPENDING | _IO_NO_READS))</span><br><span class="line">      == (_IO_IS_APPENDING | _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_off64_t new_pos = _IO_SYSSEEK (fp, <span class="number">0</span>, _IO_seek_end);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD &amp;&amp; errno != ESPIPE)</span><br><span class="line">	&#123;</span><br><span class="line">	  close_not_cancel (fdesc);</span><br><span class="line">	  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  _IO_link_in ((struct _IO_FILE_plus *) fp); <span class="comment">//再次调用_IO_link_in</span></span><br><span class="line">  <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数中，首先会判断<strong>FILE</strong>结构体的**_flags2<strong>是否有</strong>_IO_FLAGS2_NOTCANCEL<strong>位，即是否含有</strong>c<strong>的副属性，若有则会调用</strong>__open_nocancel<strong>函数，若无则会调用</strong>__open**函数，从这两个函数传入了相同的参数可以看出，这两个函数实现了相似的功能，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__libc_open64 (<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">int</span> oflag, ...)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> mode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__OPEN_NEEDS_MODE (oflag))</span><br><span class="line">    &#123;</span><br><span class="line">      va_list arg;</span><br><span class="line">      va_start (arg, oflag);</span><br><span class="line">      mode = va_arg (arg, <span class="keyword">int</span>);</span><br><span class="line">      va_end (arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> SYSCALL_CANCEL (open, file, oflag | O_LARGEFILE, mode);</span><br><span class="line">&#125;</span><br><span class="line">weak_alias (__libc_open64, __open64)</span><br><span class="line">libc_hidden_weak (__open64)</span><br><span class="line">weak_alias (__libc_open64, open64)</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__open_nocancel (<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">int</span> oflag, ...)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> mode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__OPEN_NEEDS_MODE (oflag))</span><br><span class="line">    &#123;</span><br><span class="line">      va_list arg;</span><br><span class="line">      va_start (arg, oflag);</span><br><span class="line">      mode = va_arg (arg, <span class="keyword">int</span>);</span><br><span class="line">      va_end (arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> INLINE_SYSCALL (openat, <span class="number">4</span>, AT_FDCWD, file, oflag, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这两个函数在<strong>return</strong>时均调用了<strong>INLINE_SYSCALL_CALL</strong>函数，即到最后将带有文件修改方式和读写属性的<strong>flag</strong>作为参数，调用<strong>SYSCALL</strong>进行打开文件操作，并将句柄返回。（再往底层就是直接宏定义汇编代码，就不继续深究<strong>INLINE_SYSCALL_CALL</strong>函数内部了）<br>返回后，回到**_IO_file_open<strong>函数中，接下来将打开文件后的文件流序号赋值给</strong>_fileno<strong>字段，之后调用了</strong>_IO_mask_flags<strong>将具有读写方式的属性加入</strong>FILE<strong>结构体的</strong>flags<strong>字段中，若读写方式为</strong>a**(追加)，则会将文件末尾作为文件的偏移。</p>
<p><code>_IO_mask_flags</code>定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_mask_flags(fp, f, mask) \</span></span><br><span class="line"><span class="meta">       ((fp)-&gt;_flags = ((fp)-&gt;_flags &amp; ~(mask)) | ((f) &amp; (mask)))</span></span><br></pre></td></tr></table></figure>

<h4 id="IO-new-fopen-gt-fopen-internal-gt-IO-new-file-fopen-gt-IO-file-open-gt-IO-link-in"><a href="#IO-new-fopen-gt-fopen-internal-gt-IO-new-file-fopen-gt-IO-file-open-gt-IO-link-in" class="headerlink" title="_IO_new_fopen-&gt;__fopen_internal-&gt;_IO_new_file_fopen-&gt;_IO_file_open-&gt;_IO_link_in"></a><code>_IO_new_fopen-&gt;__fopen_internal-&gt;_IO_new_file_fopen-&gt;_IO_file_open-&gt;_IO_link_in</code></h4><p>最后会调用**_IO_link_in<strong>函数确保该结构体已链入</strong>_IO_list_all<strong>链表(因为在</strong>_IO_link_in<strong>函数中会有对</strong>_IO_LINKED<strong>的</strong>check<strong>，所以并不是重复链入)，至此</strong>_IO_file_open**函数执行完毕。</p>
<p>函数的主要功能就是执行系统调用<code>open</code>打开文件，并将文件描述符赋值给FILE结构体的<code>_fileno </code>字段，最后再次调用<code>_IO_link_in</code>函数，确保该结构体被链接进入<code>_IO_list_all</code>链表。</p>
<p>从**_IO_file_open<strong>返回后回到</strong>_IO_new_file_fopen<strong>函数，之后有的一个大段的</strong>if<strong>语句中，大概是给之前初始化的</strong>_wide_data<strong>中的各元素进行赋值，在</strong>if<strong>函数的最后将</strong>FILE<strong>结构体中的</strong>_mode<strong>字段赋值为</strong>1**。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(result != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cs = <span class="built_in">strstr</span>(last_recognized +<span class="number">1</span> , <span class="string">&quot;,ccs=&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(cs != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ......                  <span class="comment">//大概是给_wide_data中的各元素赋值</span></span><br><span class="line">        result-&gt;_mode = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p><strong>return</strong>后返回到**__fopen_internal<strong>函数中，此时执行到了</strong>__fopen_internal<strong>函数的最后一步，如果上面调用</strong>_IO_file_fopen<strong>函数打开文件失败，则执行以下函数：调用</strong>_IO_un_link<strong>函数将链入</strong>_IO_list_all<strong>的结构体摘除，并</strong>free<strong>掉为其申请的空间，之后</strong>return NULL<strong>；若打开文件成功，则会执行以下函数：调用</strong>__fopen_maybe_mmap<strong>函数并返回。该函数在</strong>glibc/libio/iofopen.c**中定义如下；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">_IO_FILE *</span><br><span class="line">__fopen_maybe_mmap (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _G_HAVE_MMAP</span></span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags2 &amp; _IO_FLAGS2_MMAP) &amp;&amp; (fp-&gt;_flags &amp; _IO_NO_WRITES))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Since this is read-only, we might be able to mmap the contents</span></span><br><span class="line"><span class="comment">	 directly.  We delay the decision until the first read attempt by</span></span><br><span class="line"><span class="comment">	 giving it a jump table containing functions that choose mmap or</span></span><br><span class="line"><span class="comment">	 vanilla file operations and reset the jump table accordingly.  */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_mode &lt;= <span class="number">0</span>)</span><br><span class="line">	_IO_JUMPS_FILE_plus (fp) = &amp;_IO_file_jumps_maybe_mmap;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	_IO_JUMPS_FILE_plus (fp) = &amp;_IO_wfile_jumps_maybe_mmap;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_wide_vtable = &amp;_IO_wfile_jumps_maybe_mmap;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数会判断**_flags2<strong>字段中是否含有</strong>_IO_FLAGS2_MMAP<strong>位，即在打开文件时是否有</strong>m<strong>属性，还会检查</strong>_flags<strong>字段中是否含有</strong>_IO_NO_WRITES<strong>位，即在打开文件时是否有</strong>r<strong>属性。即在打开文件时有</strong>rm<strong>两个属性，则会执行函数的主体部分，调用</strong>_IO_JUMPS_FILE_plus<strong>函数将重置</strong>FILE<strong>结构体的</strong>vtable<strong>虚表，该函数在</strong>glibc/libio/libioP.h**中定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_JUMPS_FILE_plus(THIS) \</span></span><br><span class="line"><span class="meta">  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE_plus, vtable)</span></span><br></pre></td></tr></table></figure>

<p>以上，完成了对<strong>fopen</strong>函数源码的分析，该函数主要进行了<strong>3</strong>个操作：为文件流申请空间；初始化<strong>FILE</strong>结构体及虚表，包括将文件流链入**_IO_list_all**链表中；打开文件流，包括读取文件属性以及利用系统调用打开文件。</p>
<h4 id="总结流程如下："><a href="#总结流程如下：" class="headerlink" title="总结流程如下："></a>总结流程如下：</h4><p><img src="https://cdn.jsdelivr.net/gh/wysyrg/picodemo/img/202205152122219.png" alt="绘图1_去水印-001"></p>
<h3 id="fcolse"><a href="#fcolse" class="headerlink" title="fcolse"></a>fcolse</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>首先把fclose的总体的流程描述一遍，从fopen的流程中，我们知道了fopen主要是建立了FILE结构体以及将其链接进入了<code>_IO_list_all</code>链表中，同时fread或fwrite会建立输入输出缓冲区，所以在fclose时会对这些操作进行相应的释放。</p>
<p><code>fclose</code>函数实现主要是在<code>_IO_new_fclose</code>函数中，大致可分为三步，基本上可以与<code>fopen</code>相对应：</p>
<ol>
<li>调用<code>_IO_un_link</code>将文件结构体从<code>_IO_list_all</code>链表中取下。</li>
<li>调用<code>_IO_file_close_it</code>关闭文件并释放缓冲区。</li>
<li>释放FILE内存以及确认文件关闭。</li>
</ol>
<p>与<strong>fopen</strong>函数相同，在<strong>glibc/include/stdio.h</strong>中有如下宏定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> fclose(fp) _IO_new_fclose (fp)</span></span><br></pre></td></tr></table></figure>

<h4 id="IO-new-fclose"><a href="#IO-new-fclose" class="headerlink" title="_IO_new_fclose"></a><code>_IO_new_fclose</code></h4><p><strong>fclose</strong>函数的原形为**_IO_new_fclose<strong>函数，该函数在</strong>glibc/libio/iofclose.c**中定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_new_fclose (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">  CHECK_FILE(fp, EOF);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)</span></span><br><span class="line">  <span class="comment">/* We desperately try to help programs which are using streams in a</span></span><br><span class="line"><span class="comment">     strange way and mix old and new functions.  Detect old streams</span></span><br><span class="line"><span class="comment">     here.  */</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> _IO_old_fclose (fp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First unlink the stream.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    _IO_un_link ((struct _IO_FILE_plus *) fp);   <span class="comment">// 将 fp 从链表中取出</span></span><br><span class="line"></span><br><span class="line">  _IO_acquire_lock (fp);                        <span class="comment">//_IO_acquire_lock (fp)加锁，应对多线程资源共享的问题</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    status = _IO_file_close_it (fp);             <span class="comment">// 关闭目标文件</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    status = fp-&gt;_flags &amp; _IO_ERR_SEEN ? <span class="number">-1</span> : <span class="number">0</span>;</span><br><span class="line">  _IO_release_lock (fp);                       <span class="comment">//去锁 </span></span><br><span class="line">  _IO_FINISH (fp);                             <span class="comment">//确认FILE结构体从链表中删除以及缓冲区被释放</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _LIBC</span></span><br><span class="line">      <span class="comment">/* This stream has a wide orientation.  This means we have to free</span></span><br><span class="line"><span class="comment">	 the conversion functions.  */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cc</span> =</span> fp-&gt;_codecvt;</span><br><span class="line"></span><br><span class="line">      __libc_lock_lock (__gconv_lock);</span><br><span class="line">      __gconv_release_step (cc-&gt;__cd_in.__cd.__steps);</span><br><span class="line">      __gconv_release_step (cc-&gt;__cd_out.__cd.__steps);</span><br><span class="line">      __libc_lock_unlock (__gconv_lock);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (_IO_have_backup (fp))</span><br><span class="line">	_IO_free_backup_area (fp);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp != _IO_stdin &amp;&amp; fp != _IO_stdout &amp;&amp; fp != _IO_stderr)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_IO_file_flags = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">free</span>(fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>该函数主要是<strong>fopen</strong>函数的逆过程，首先在判断文件流是否含有**_IO_file_flags<strong>和</strong>_IO_SI_FILEBUF<strong>后，函数会执行</strong>_IO_un_link<strong>函数，该函数在</strong>glibc/libio/genops.c**定义如下：</p>
<h4 id="IO-new-fclose-gt-IO-un-link"><a href="#IO-new-fclose-gt-IO-un-link" class="headerlink" title="_IO_new_fclose-&gt;_IO_un_link"></a><code>_IO_new_fclose-&gt;_IO_un_link</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_IO_un_link (struct _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;file._flags &amp; _IO_LINKED)                              <span class="comment">// 检查标志位</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> **<span class="title">f</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">      _IO_lock_lock (list_all_lock);</span><br><span class="line">      run_fp = (_IO_FILE *) fp;</span><br><span class="line">      _IO_flockfile ((_IO_FILE *) fp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      <span class="keyword">if</span> (_IO_list_all == <span class="literal">NULL</span>)</span><br><span class="line">	;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (fp == _IO_list_all)                           <span class="comment">// fp为链表的头</span></span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_list_all = (struct _IO_FILE_plus *) _IO_list_all-&gt;file._chain;</span><br><span class="line">	  ++_IO_list_all_stamp;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span>                                                    <span class="comment">// fp为链表中间节点</span></span><br><span class="line">	<span class="keyword">for</span> (f = &amp;_IO_list_all-&gt;file._chain; *f; f = &amp;(*f)-&gt;_chain)</span><br><span class="line">	  <span class="keyword">if</span> (*f == (_IO_FILE *) fp)</span><br><span class="line">	    &#123;</span><br><span class="line">	      *f = fp-&gt;file._chain;</span><br><span class="line">	      ++_IO_list_all_stamp;</span><br><span class="line">	      <span class="keyword">break</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">      fp-&gt;file._flags &amp;= ~_IO_LINKED;                        <span class="comment">//修改标志位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_funlockfile ((_IO_FILE *) fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">      _IO_lock_unlock (list_all_lock);</span><br><span class="line">      _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数是**_IO_link_in<strong>函数的逆过程，主要实现了将文件流从</strong>_IO_list_all**链表中卸下，以及一些对结构体中字段的善后操作。</p>
<p>函数先检查标志位是否包含<code>_IO_LINKED</code>标志，该标志的定义是<code>#define _IO_LINKED 0x80</code>，表示该结构体是否被链接到了<code>_IO_list_all</code>链表中。</p>
<p>如果没有<code>_IO_LINKED</code>标志（不在<code>_IO_list_all</code>链表中）或者<code>_IO_list_all</code>链表为空，则直接返回。</p>
<p>否则的话即表示结构体为<code>_IO_list_all</code>链表中某个节点，所要做的就是将这个节点取下来，接下来就是单链表的删除节点的操作，首先判断是不是<code>_IO_list_all</code>链表头，如果是的话直接将<code>_IO_list_all</code>指向<code>_IO_list_all-&gt;file._chain</code>就好了，如果不是链表头则遍历链表，找到该结构体，再将其取下。</p>
<p>最后返回之前设置<code>file._flags</code>为<code>~_IO_LINKED</code>表示该结构体不在<code>_IO_list_all</code>链表中。</p>
<h4 id="IO-new-fclose-gt-IO-new-file-close-it"><a href="#IO-new-fclose-gt-IO-new-file-close-it" class="headerlink" title="_IO_new_fclose-&gt;_IO_new_file_close_it "></a><code>_IO_new_fclose-&gt;_IO_new_file_close_it </code></h4><p>接着调用了**_IO_file_close_it<strong>函数，该函数在</strong>glibc/libio/fileops.c**定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> _IO_new_file_close_it _IO_file_close_it</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_new_file_close_it (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> write_status;</span><br><span class="line">  <span class="keyword">if</span> (!_IO_file_is_open (fp))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_NO_WRITES) == <span class="number">0</span></span><br><span class="line">      &amp;&amp; (fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) != <span class="number">0</span>)</span><br><span class="line">    write_status = _IO_do_flush (fp);      <span class="comment">//刷新输出缓冲区</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    write_status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  _IO_unsave_markers (fp);  <span class="comment">//_IO_unsave_markers(fp)将保存的markers清除，</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> close_status = ((fp-&gt;_flags2 &amp; _IO_FLAGS2_NOCLOSE) == <span class="number">0</span></span><br><span class="line">		      ? _IO_SYSCLOSE (fp) : <span class="number">0</span>);   <span class="comment">//调用vtable __close关闭文件</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Free buffer. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (_IO_have_wbackup (fp))</span><br><span class="line">	_IO_free_wbackup_area (fp);</span><br><span class="line">      _IO_wsetb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">      _IO_wsetg (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">      _IO_wsetp (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_setb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);         <span class="comment">//设置base指针，并释放缓冲区</span></span><br><span class="line">  _IO_setg (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);      <span class="comment">//置零输入缓冲区</span></span><br><span class="line">  _IO_setp (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>);             <span class="comment">//置零输出缓冲区</span></span><br><span class="line"></span><br><span class="line">  _IO_un_link ((struct _IO_FILE_plus *) fp);        <span class="comment">//确保结构体已从_IO_list_all中取下</span></span><br><span class="line">  fp-&gt;_flags = _IO_MAGIC|CLOSED_FILEBUF_FLAGS;</span><br><span class="line">  fp-&gt;_fileno = <span class="number">-1</span>;                     <span class="comment">//设置文件描述符为-1</span></span><br><span class="line">  fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> close_status ? close_status : write_status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>if ((fp-&gt;_flags &amp; _IO_NO_WRITES) == 0&amp;&amp; (fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) != 0)</code>判断是否为写属性的文件流，以及是否进行过写操作，若有，则会调用**_IO_do_flush<strong>函数，该函数在</strong>glibc/libio/libioP.h**中有宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> _IO_do_flush(_f) \</span></span><br><span class="line"><span class="meta">  ((_f)-&gt;_mode &lt;= 0							      \</span></span><br><span class="line"><span class="meta">   ? _IO_do_write(_f, (_f)-&gt;_IO_write_base,				      \</span></span><br><span class="line"><span class="meta">		  (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)		      \</span></span><br><span class="line"><span class="meta">   : _IO_wdo_write(_f, (_f)-&gt;_wide_data-&gt;_IO_write_base,		      \</span></span><br><span class="line"><span class="meta">		   ((_f)-&gt;_wide_data-&gt;_IO_write_ptr			      \</span></span><br><span class="line"><span class="meta">		    - (_f)-&gt;_wide_data-&gt;_IO_write_base)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> _IO_do_flush(_f) \</span></span><br><span class="line"><span class="meta">  _IO_do_write(_f, (_f)-&gt;_IO_write_base,				      \</span></span><br><span class="line"><span class="meta">	       (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>可以看到该函数直接是针对文件流的整个缓冲区去调用了**_IO_do_write**函数，即实现了将仍存在于缓冲区中的数据写入文件的操作。</p>
<h4 id="IO-new-fclose-gt-IO-new-file-close-it-gt-IO-file-close"><a href="#IO-new-fclose-gt-IO-new-file-close-it-gt-IO-file-close" class="headerlink" title="_IO_new_fclose-&gt;_IO_new_file_close_it -&gt;_IO_file_close"></a><code>_IO_new_fclose-&gt;_IO_new_file_close_it -&gt;_IO_file_close</code></h4><p>之后调用**_IO_SYSCLOSE<strong>函数，该函数对应虚表中的</strong>__close<strong>，即</strong>_IO_file_close<strong>函数，该函数在</strong>glibc/libio/fileops.c**中定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_file_close (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Cancelling close should be avoided if possible since it leaves an</span></span><br><span class="line"><span class="comment">     unrecoverable state behind.  */</span></span><br><span class="line">  <span class="keyword">return</span> close_not_cancel (fp-&gt;_fileno);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>close_not_cancel</code>的定义为<code>#define close_not_cancel(fd) \  __close (fd)</code>该函数直接调用了系统调用<code>close</code>关闭文件描述符。</p>
<p>该函数直接调用了<strong>close_not_cancel</strong>函数去执行系统调用对文件进行关闭。</p>
<p>在调用了<code>_IO_SYSCLOSE</code>函数关闭文件描述符后，<code>_IO_new_file_close_it</code>函数开始释放输入输出缓冲区并置零输入输出缓冲区。一口气调用了<code>_IO_setb</code>、<code>_IO_setg</code>、<code>_IO_setp</code>三个函数，这三个函数在缓冲区建立的时候都看过了，<code>_IO_setb</code>是设置结构体的buf指针，<code>_IO_setg</code>是设置read相关的指针，<code>_IO_setp</code>是设置write相关的指针，在这里还需要重新看下<code>_IO_setb</code>函数，因为在这个函数里还释放了缓冲区，函数在<code>libio/genops.c</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_IO_setb (_IO_FILE *f, <span class="keyword">char</span> *b, <span class="keyword">char</span> *eb, <span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    <span class="built_in">free</span> (f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_IO_buf_end = eb;</span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    f-&gt;_flags &amp;= ~_IO_USER_BUF;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在<code>_IO_setb</code>释放的缓冲区，并置零了buf指针。找到了释放缓冲区的地方了，之前看fread和fwrite的时候都没注意到这里。执行完这一段之后，指针被清零了。继续往下看，其调用了<code>_IO_un_link</code>函数，确保结构体从<code>_IO_list_all</code>链表中取了下来。然后将文件描述符设置为<code>-1</code>。</p>
<h4 id="IO-new-fclose-gt-IO-FINISH"><a href="#IO-new-fclose-gt-IO-FINISH" class="headerlink" title="_IO_new_fclose-&gt;_IO_FINISH"></a><code>_IO_new_fclose-&gt;_IO_FINISH</code></h4><p>返回到**_IO_new_fclose<strong>函数后，主要去执行了</strong>_IO_FINISH<strong>函数，该函数为虚表中的</strong>__finish<strong>，即对应</strong>_IO_new_file_finish<strong>函数，该函数在</strong>glibc/libio/fileops.c**中定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_FINISH(FP) JUMP1 (__finish, FP, 0)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> _IO_new_file_finish _IO_file_finish</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_IO_new_file_finish (_IO_FILE *fp, <span class="keyword">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_file_is_open (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_do_flush (fp);</span><br><span class="line">      <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_DELETE_DONT_CLOSE))</span><br><span class="line">	_IO_SYSCLOSE (fp);</span><br><span class="line">    &#125;</span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_finish, _IO_file_finish)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该函数一次调用了**_IO_do_flush、_IO_SYSCLOSE<strong>以及</strong>_IO_default_finish**函数，</p>
<p>IO_do_flush针对文件流的整个缓冲区去调用了**_IO_do_write**函数，即实现了将仍存在于缓冲区中的数据写入文件的操作。</p>
<p><code>_IO_default_finish</code>确认缓冲区确实被释放</p>
<h4 id="IO-new-fclose-gt-IO-FINISH-gt-IO-default-finish"><a href="#IO-new-fclose-gt-IO-FINISH-gt-IO-default-finish" class="headerlink" title="_IO_new_fclose-&gt;_IO_FINISH-&gt;_IO_default_finish"></a><code>_IO_new_fclose-&gt;_IO_FINISH-&gt;_IO_default_finish</code></h4><p>其中**_IO_default_finish<strong>函数在</strong>glibc/libio/genops.c**中定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_IO_default_finish (_IO_FILE *fp, <span class="keyword">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *<span class="title">mark</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_IO_buf_base);</span><br><span class="line">      fp-&gt;_IO_buf_base = fp-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (mark = fp-&gt;_markers; mark != <span class="literal">NULL</span>; mark = mark-&gt;_next)</span><br><span class="line">    mark-&gt;_sbuf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_save_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">      fp-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_un_link ((struct _IO_FILE_plus *) fp);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">    _IO_lock_fini (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到**_IO_new_file_finish**中调用的几个函数，均在前面正常关闭的流程中有过调用，所以基本上都不会去执行。</p>
<p>程序回到<code>_IO_new_fclose</code>中，到此时已经将结构体从链表中删除，刷新了缓冲区，释放了缓冲区内存，只剩下结构体内存尚未释放，因此代码也剩下最后一段代码，即调用<code>free</code>释放结构体内存。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>分析完成后，回头看fclose函数的功能，主要就是刷新输出缓冲区并释放缓冲区内存、释放结构体内存。仍然总结下调用了vtable中的函数：</p>
<ul>
<li>在清空缓冲区<code>_IO_do_flush</code>中的<code>_IO_do_write</code>函数中（若进行过写操作）会调用vtable中的<code>_IO_do_flush</code>函数。</li>
<li>关闭文件描述符<code>_IO_SYSCLOSE</code>函数为vtable中的<code>__close</code>函数。</li>
<li><code>_IO_FINISH</code>函数为vtable中的<code>__finish</code>函数。</li>
</ul>
<h3 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h3><p>基于glibc2.23的源码分析</p>
<p><strong>fread</strong>函数的一般用法为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fread( <span class="keyword">void</span> *buffer, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> count, FILE *stream );</span><br></pre></td></tr></table></figure>

<p>该函数共有<strong>4</strong>个参数，<strong>buffer</strong>代表接收从文件读取数据的变量首地址，<strong>size</strong>代表每个对象的大小，<strong>count</strong>代表对象的个数，<strong>stream</strong>是代表文件流。即该函数实现了从<strong>stream</strong>中读<strong>size * count</strong>字节数据并赋给<strong>buffer</strong>所指向的地址。</p>
<p>fread的流程图如下</p>
<p><img src="E:\draw_source\1557385923980.png" alt="1557385923980"></p>
<h4 id="IO-fread"><a href="#IO-fread" class="headerlink" title="_IO_fread"></a><code>_IO_fread</code></h4><p>该函数在<strong>glibc/libio/iofread.c</strong>中有如下定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">_IO_size_t</span><br><span class="line">_IO_fread (<span class="keyword">void</span> *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t bytes_requested = size * count;</span><br><span class="line">  _IO_size_t bytes_read;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (bytes_requested == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);                        <span class="comment">//加锁</span></span><br><span class="line">  bytes_read = _IO_sgetn (fp, (<span class="keyword">char</span> *) buf, bytes_requested);</span><br><span class="line">  _IO_release_lock (fp);                        <span class="comment">//去锁</span></span><br><span class="line">  <span class="keyword">return</span> bytes_requested == bytes_read ? count : bytes_read / size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="IO-fread-gt-CHECK-FILE"><a href="#IO-fread-gt-CHECK-FILE" class="headerlink" title="_IO_fread-&gt;CHECK_FILE"></a><code>_IO_fread-&gt;CHECK_FILE</code></h4><p>调用了<strong>CHECK_FILE</strong>函数对将要输入的文件流进行检查，该函数在<strong>glibc/libio/libioP.h</strong>中有宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> IO_DEBUG</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> CHECK_FILE(FILE, RET) \</span></span><br><span class="line"><span class="meta">	<span class="meta-keyword">if</span> ((FILE) == NULL) &#123; MAYBE_SET_EINVAL; return RET; &#125; \</span></span><br><span class="line"><span class="meta">	<span class="meta-keyword">else</span> &#123; COERCE_FILE(FILE); \</span></span><br><span class="line"><span class="meta">	       <span class="meta-keyword">if</span> (((FILE)-&gt;_IO_file_flags &amp; _IO_MAGIC_MASK) != _IO_MAGIC) \</span></span><br><span class="line"><span class="meta">	  &#123; MAYBE_SET_EINVAL; return RET; &#125;&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> CHECK_FILE(FILE, RET) COERCE_FILE (FILE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>即当<strong>IO_DEBUG</strong>被定义时，会对<strong>FILE</strong>结构体的**_flags<strong>字段进行</strong>_IO_MAGIC_MASK<strong>位的验证，若不存在，则说明传进来的不是</strong>FILE<strong>结构体，就</strong>return 0**。</p>
<h4 id="IO-fread-gt-IO-file-xsgetn"><a href="#IO-fread-gt-IO-file-xsgetn" class="headerlink" title="_IO_fread-&gt;_IO_file_xsgetn"></a><code>_IO_fread-&gt;_IO_file_xsgetn</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">_IO_size_t</span><br><span class="line">_IO_sgetn (_IO_FILE *fp, <span class="keyword">void</span> *data, _IO_size_t n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* FIXME handle putback buffer here! */</span></span><br><span class="line">  <span class="keyword">return</span> _IO_XSGETN (fp, data, n);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_sgetn)</span><br></pre></td></tr></table></figure>

<p>调用了**_IO_sgetn**函数进行读入数据操作。看到其调用了<code>_IO_XSGETN</code>函数，查看它定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)</span></span><br></pre></td></tr></table></figure>

<p>经过辗转后发现该函数为虚表中的**__xsgetn<strong>，即</strong>_IO_file_xsgetn<strong>函数，该函数定义于</strong>glibc/libio/fileop.c<strong>中，是</strong>fread**函数的关键。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">_IO_size_t</span><br><span class="line">_IO_file_xsgetn (_IO_FILE *fp, <span class="keyword">void</span> *data, _IO_size_t n)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t want, have;</span><br><span class="line">  _IO_ssize_t count;</span><br><span class="line">  <span class="keyword">char</span> *s = data;</span><br><span class="line"></span><br><span class="line">  want = n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">	  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">	&#125;           </span><br><span class="line">      <span class="comment">//  第一部分，如果fp-&gt;_IO_buf_base为空的话则调用`_IO_doallocbuf`</span></span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (want &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">      <span class="keyword">if</span> (want &lt;= have) <span class="comment">//  第二部分，输入缓冲区里已经有足够的字符，则直接把缓冲区里的字符给目标buff</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, want);</span><br><span class="line">	  fp-&gt;_IO_read_ptr += want;</span><br><span class="line">	  want = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (have &gt; <span class="number">0</span>) <span class="comment">//第二部分，输入缓冲区里有部分字符，但是没有达到fread的size需求，先把已有的拷贝至目标buff</span></span><br><span class="line">	    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line">	      s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	      <span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line">	      s += have;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	      want -= have;</span><br><span class="line">	      fp-&gt;_IO_read_ptr += have;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Check for backup and repeat */</span></span><br><span class="line">	  <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">	    &#123;</span><br><span class="line">	      _IO_switch_to_main_get_area (fp);</span><br><span class="line">	      <span class="keyword">continue</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* If we now want less than a buffer, underflow and repeat</span></span><br><span class="line"><span class="comment">	     the copy.  Otherwise, _IO_SYSREAD directly to</span></span><br><span class="line"><span class="comment">	     the user buffer. */</span></span><br><span class="line">	  <span class="keyword">if</span> (fp-&gt;_IO_buf_base</span><br><span class="line">	      &amp;&amp; want &lt; (<span class="keyword">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (__underflow (fp) == EOF) <span class="comment">//第三部分，输入缓冲区里不能满足需求，调用__underflow读入数据</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	      <span class="keyword">continue</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* These must be set before the sysread as we might longjmp out</span></span><br><span class="line"><span class="comment">	     waiting for input. */</span></span><br><span class="line">	  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">	  _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Try to maintain alignment: read a whole number of blocks.  */</span></span><br><span class="line">	  count = want;</span><br><span class="line">	  <span class="keyword">if</span> (fp-&gt;_IO_buf_base)</span><br><span class="line">	    &#123;</span><br><span class="line">	      _IO_size_t block_size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base;</span><br><span class="line">	      <span class="keyword">if</span> (block_size &gt;= <span class="number">128</span>)</span><br><span class="line">		count -= want % block_size;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  count = _IO_SYSREAD (fp, s, count);</span><br><span class="line">	  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">		fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">	      <span class="keyword">else</span></span><br><span class="line">		fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"></span><br><span class="line">	      <span class="keyword">break</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  s += count;</span><br><span class="line">	  want -= count;</span><br><span class="line">	  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">	    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n - want;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数中定义了<strong>4</strong>个变量，分别是<strong>want</strong>表示还要读入的数据字节数、<strong>have</strong>表示输入缓冲区中剩余的空间大小、<strong>count</strong>表示要读出数据的个数、<strong>s</strong>表示接收读出数据的变量地址。</p>
<p><code>_IO_file_xsgetn</code>是处理<code>fread</code>读入数据的核心函数，分为三个部分：</p>
<ul>
<li>第一部分是<code>fp-&gt;_IO_buf_base</code>为空的情况，表明此时的FILE结构体中的指针未被初始化，输入缓冲区未建立，则调用<code>_IO_doallocbuf</code>去初始化指针，建立输入缓冲区。</li>
<li>第二部分是输入缓冲区里有输入，即<code>fp-&gt;_IO_read_ptr</code>小于<code>fp-&gt;_IO_read_end</code>，此时将缓冲区里的数据直接拷贝至目标buff。</li>
<li>第三部分是输入缓冲区里的数据为空或者是不能满足全部的需求，则调用<code>__underflow</code>调用系统调用读入数据。</li>
</ul>
<h5 id="初始化缓冲区"><a href="#初始化缓冲区" class="headerlink" title="初始化缓冲区"></a>初始化缓冲区</h5><p>由于我们刚从<strong>fopen</strong>初始化过来，因此<strong>FILE</strong>结构体中的各字段仍是空值，因此会进入在<code>if (fp-&gt;_IO_buf_base == NULL)</code>的<strong>if-else</strong>语句，该语句首先判断该文件流中的**_IO_save_base<strong>字段是否已经赋值，即文件流是否有备份的缓冲区，若有则会将该缓冲区</strong>free<strong>掉，并去掉</strong>_IO_IN_BACKUP<strong>位，最后调用</strong>_IO_doallocbuf**函数。</p>
<h6 id="IO-fread-gt-IO-file-xsgetn-gt-IO-doallocbuf"><a href="#IO-fread-gt-IO-file-xsgetn-gt-IO-doallocbuf" class="headerlink" title="_IO_fread-&gt;_IO_file_xsgetn-&gt;_IO_doallocbuf"></a><code>_IO_fread-&gt;_IO_file_xsgetn-&gt;_IO_doallocbuf</code></h6><p>该函数在<strong>glibc/libio/genops.c</strong>中定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_IO_doallocbuf (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base) <span class="comment">//如果输入缓冲区不为空，直接返回</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED) || fp-&gt;_mode &gt; <span class="number">0</span>)   <span class="comment">// 检查标志位</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_DOALLOCATE (fp) != EOF) <span class="comment">//调用vtable函数</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  _IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数先检查<code>fp-&gt;_IO_buf_base</code>是否为空，如果不为空的话表明该输入缓冲区已被初始化，直接返回。如果为空，则检查<code>fp-&gt;_flags</code>看它是不是<code>_IO_UNBUFFERED</code>或者<code>fp-&gt;_mode</code>大于0，如果满足条件调用FILE的vtable中的<code>_IO_file_doallocate</code>，跟进去该函数，在<code>/libio/filedoalloc.c</code>中：</p>
<h6 id="IO-fread-gt-IO-file-xsgetn-gt-IO-doallocbuf-1"><a href="#IO-fread-gt-IO-file-xsgetn-gt-IO-doallocbuf-1" class="headerlink" title="_IO_fread-&gt;_IO_file_xsgetn-&gt;_IO_doallocbuf"></a><code>_IO_fread-&gt;_IO_file_xsgetn-&gt;_IO_doallocbuf</code></h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_DOALLOCATE(FP) JUMP0 (__doallocate, FP)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_file_doallocate (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t size;</span><br><span class="line">  <span class="keyword">char</span> *p;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat64</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LIBC</span></span><br><span class="line">  <span class="comment">/* If _IO_cleanup_registration_needed is non-zero, we should call the</span></span><br><span class="line"><span class="comment">     function it points to.  This is to make sure _IO_cleanup gets called</span></span><br><span class="line"><span class="comment">     on exit.  We call it from _IO_file_doallocate, since that is likely</span></span><br><span class="line"><span class="comment">     to get called by any program that does buffered I/O. */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (_IO_cleanup_registration_needed != <span class="literal">NULL</span>))</span><br><span class="line">    (*_IO_cleanup_registration_needed) ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  size = _IO_BUFSIZ;  #宏定义为<span class="number">8192</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_fileno &gt;= <span class="number">0</span> &amp;&amp; __builtin_expect (_IO_SYSSTAT (fp, &amp;st), <span class="number">0</span>) &gt;= <span class="number">0</span>) <span class="comment">//调用`_IO_SYSSTAT`获取FILE信息</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (S_ISCHR (st.st_mode))</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Possibly a tty.  */</span></span><br><span class="line">	  <span class="keyword">if</span> (</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEV_TTY_P</span></span><br><span class="line">	      DEV_TTY_P (&amp;st) ||</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	      local_isatty (fp-&gt;_fileno))</span><br><span class="line">	    fp-&gt;_flags |= _IO_LINE_BUF;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _IO_HAVE_ST_BLKSIZE</span></span><br><span class="line">      <span class="keyword">if</span> (st.st_blksize &gt; <span class="number">0</span>)</span><br><span class="line">	size = st.st_blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  p = <span class="built_in">malloc</span> (size);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (p == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  _IO_setb (fp, p, p + size, <span class="number">1</span>); <span class="comment">//调用`_IO_setb`设置FILE缓冲区</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>_IO_file_doallocate</code>函数是分配输入缓冲区的实现函数，首先调用<code>_IO_SYSSTAT</code>去获取文件信息，<code>_IO_SYSSTAT</code>函数是vtable中的<code> __stat</code>函数，对应着**<code>_IO_file_stat</code>**函数，获取文件信息，修改相应需要申请的size。</p>
<h6 id="IO-fread-gt-IO-file-xsgetn-gt-IO-doallocbuf-gt-IO-setb"><a href="#IO-fread-gt-IO-file-xsgetn-gt-IO-doallocbuf-gt-IO-setb" class="headerlink" title="_IO_fread-&gt;_IO_file_xsgetn-&gt;_IO_doallocbuf-&gt;_IO_setb"></a><code>_IO_fread-&gt;_IO_file_xsgetn-&gt;_IO_doallocbuf-&gt;_IO_setb</code></h6><p>空间申请出来后，调用<code>_IO_setb</code>,该函数在<strong>glibc/libio/genops.c</strong>中定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_IO_setb (_IO_FILE *f, <span class="keyword">char</span> *b, <span class="keyword">char</span> *eb, <span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    <span class="built_in">free</span> (f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_buf_base = b;  <span class="comment">//设置_IO_buf_base </span></span><br><span class="line">  f-&gt;_IO_buf_end = eb;  <span class="comment">//设置_IO_buf_end</span></span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    f-&gt;_flags &amp;= ~_IO_USER_BUF;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数相对比较简单的就是设置了<code>_IO_buf_base</code>和<code>_IO_buf_end</code>，到此，初始化缓冲区就完成了，函数返回<code>_IO_file_doallocate</code>后，接着<code>_IO_file_doallocate</code>也返回，回到<code>_IO_file_xsgetn</code>函数中。</p>
<h5 id="拷贝输入缓冲区数据"><a href="#拷贝输入缓冲区数据" class="headerlink" title="拷贝输入缓冲区数据"></a>拷贝输入缓冲区数据</h5><p>初始化缓冲区完成之后，代码返回到<code>_IO_file_xsgetn</code>函数中，程序就进入到第二部分：拷贝输入缓冲区数据，如果输入缓冲区里存在已输入的数据，则把它直接拷贝到目标缓冲区里。</p>
<p>这部分比较简单，需要说明下的是从这里可以看出来<code>fp-&gt;_IO_read_ptr</code>指向的是输入缓冲区的起始地址，<code>fp-&gt;_IO_read_end</code>指向的是输入缓冲区的结束地址。</p>
<p>将<code>fp-&gt;_IO_read_end-fp-&gt;_IO_read_ptr</code>之间的数据通过<code>memcpy</code>拷贝到目标缓冲区里。</p>
<h5 id="执行系统调用读取数据-N-lt-4K"><a href="#执行系统调用读取数据-N-lt-4K" class="headerlink" title="执行系统调用读取数据  N&lt;=4K"></a>执行系统调用读取数据  N&lt;=4K</h5><p>在输入缓冲区为0或者是不能满足需求的时候则会执行最后一步<code>__underflow</code>去执行系统调用<code>read</code>读取数据，并放入到输入缓冲区里。</p>
<p>由于是第一次读取数据，此时的<code>fp-&gt;_IO_read_end</code>以及<code>fp-&gt;_IO_read_ptr</code>都是0，因此会进入到<code>__underflow</code>，</p>
<h6 id="IO-fread-gt-IO-file-xsgetn-gt-underflow"><a href="#IO-fread-gt-IO-file-xsgetn-gt-underflow" class="headerlink" title="_IO_fread-&gt;_IO_file_xsgetn-&gt;__underflow"></a><code>_IO_fread-&gt;_IO_file_xsgetn-&gt;__underflow</code></h6><p>文件在<code>/libio/genops.c</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__underflow (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) == <span class="number">0</span> &amp;&amp; _IO_fwide (fp, <span class="number">-1</span>) != <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode == <span class="number">0</span>)</span><br><span class="line">    _IO_fwide (fp, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_put_mode (fp))</span><br><span class="line">    <span class="keyword">if</span> (_IO_switch_to_get_mode (fp) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_switch_to_main_get_area (fp);</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">	<span class="keyword">return</span> *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (_IO_have_markers (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (save_for_backup (fp, fp-&gt;_IO_read_end))</span><br><span class="line">	<span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (_IO_have_backup (fp))</span><br><span class="line">    _IO_free_backup_area (fp);</span><br><span class="line">    <span class="comment">// 调用_IO_UNDERFLOW</span></span><br><span class="line">  <span class="keyword">return</span> _IO_UNDERFLOW (fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数稍微做一些检查就会调用<code>_IO_UNDERFLOW</code>函数，其中一个检查是如果<code>fp-&gt;_IO_read_ptr</code>小于<code>fp-&gt;_IO_read_end</code>则表明输入缓冲区里存在数据，可直接返回，否则则表示需要继续读入数据。</p>
<p>检查都通过的话就会调用<code>_IO_UNDERFLOW</code>函数，该函数是FILE结构体vtable里的<code>_IO_new_file_underflow</code>，</p>
<h6 id="IO-fread-gt-IO-file-xsgetn-gt-underflow-gt-IO-new-file-underflow"><a href="#IO-fread-gt-IO-file-xsgetn-gt-underflow-gt-IO-new-file-underflow" class="headerlink" title="_IO_fread-&gt;_IO_file_xsgetn-&gt;__underflow-&gt;_IO_new_file_underflow"></a><code>_IO_fread-&gt;_IO_file_xsgetn-&gt;__underflow-&gt;_IO_new_file_underflow</code></h6><p>文件在<code>/libio/fileops.c</code>里：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_new_file_underflow (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_ssize_t count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="comment">/* SysV does not make this test; take it out for compatibility */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">    <span class="keyword">return</span> (EOF);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//  如果存在_IO_NO_READS标志，则直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果输入缓冲区里存在数据，则直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">   <span class="comment">// 如果没有输入缓冲区，则调用_IO_doallocbuf分配输入缓冲区</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">	  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">	&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flush all line buffered files before reading. */</span></span><br><span class="line">  <span class="comment">/* FIXME This can/should be moved to genops ?? */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; (_IO_LINE_BUF|_IO_UNBUFFERED))</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">      _IO_flush_all_linebuffered ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      <span class="comment">/* We used to flush all line-buffered stream.  This really isn&#x27;t</span></span><br><span class="line"><span class="comment">	 required by any standard.  My recollection is that</span></span><br><span class="line"><span class="comment">	 traditional Unix systems did this for stdout.  stderr better</span></span><br><span class="line"><span class="comment">	 not be line buffered.  So we do just that here</span></span><br><span class="line"><span class="comment">	 explicitly.  --drepper */</span></span><br><span class="line">      _IO_acquire_lock (_IO_stdout);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((_IO_stdout-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))</span><br><span class="line">	  == (_IO_LINKED | _IO_LINE_BUF))</span><br><span class="line">	_IO_OVERFLOW (_IO_stdout, EOF);</span><br><span class="line"></span><br><span class="line">      _IO_release_lock (_IO_stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_switch_to_get_mode (fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This is very tricky. We have to adjust those</span></span><br><span class="line"><span class="comment">     pointers before we call _IO_SYSREAD () since</span></span><br><span class="line"><span class="comment">     we may longjump () out while waiting for</span></span><br><span class="line"><span class="comment">     input. Those pointers may be screwed up. H.J. */</span></span><br><span class="line">  <span class="comment">//设置FILE结构体指针</span></span><br><span class="line">  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;</span><br><span class="line"> <span class="comment">//调用_IO_SYSREAD函数最终执行系统调用读取数据</span></span><br><span class="line">  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">		       fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">	fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	fp-&gt;_flags |= _IO_ERR_SEEN, count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">//设置结构体指针</span></span><br><span class="line">  fp-&gt;_IO_read_end += count;</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* If a stream is read to EOF, the calling application may switch active</span></span><br><span class="line"><span class="comment">	 handles.  As a result, our offset cache would no longer be valid, so</span></span><br><span class="line"><span class="comment">	 unset it.  */</span></span><br><span class="line">      fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">  <span class="keyword">return</span> *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>_IO_new_file_underflow</code>函数，是最终调用系统调用的地方，在最终执行系统调用之前，仍然有一些检查，整个流程为：</p>
<ol>
<li>检查FILE结构体的<code>_flag</code>标志位是否包含<code>_IO_NO_READS</code>，如果存在这个标志位则直接返回<code>EOF</code>，其中<code>_IO_NO_READS</code>标志位的定义是<code>#define _IO_NO_READS 4 /* Reading not allowed */</code>。</li>
<li>如果<code>fp-&gt;_IO_buf_base</code>位null，则调用<code>_IO_doallocbuf</code>分配输入缓冲区。</li>
<li>接着初始化设置FILE结构体指针，将他们都设置成<code>fp-&gt;_IO_buf_base</code></li>
<li>调用<code>_IO_SYSREAD</code>（vtable中的<code>_IO_file_read</code>函数），该函数最终执行系统调用read，读取文件数据，数据读入到<code>fp-&gt;_IO_buf_base</code>中，读入大小为输入缓冲区的大小<code>fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base</code>。</li>
<li>设置输入缓冲区已有数据的size，即设置<code>fp-&gt;_IO_read_end</code>为<code>fp-&gt;_IO_read_end += count</code>。</li>
</ol>
<p>其中第二步里面的如果<code>fp-&gt;_IO_buf_base</code>位null，则调用<code>_IO_doallocbuf</code>分配输入缓冲区，似乎有点累赘，因为之前已经分配了，这个原因我在最后会说明。</p>
<p>其中第四步的<code>_IO_SYSREAD</code>（vtable中的<code>_IO_file_read</code>函数）的源码比较简单，就是执行系统调用函数read去读取文件数据，文件在<code>libio/fileops.c</code>，源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_IO_ssize_t</span><br><span class="line">_IO_file_read (_IO_FILE *fp, <span class="keyword">void</span> *buf, _IO_ssize_t size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (__builtin_expect (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL, <span class="number">0</span>)</span><br><span class="line">	  ? read_not_cancel (fp-&gt;_fileno, buf, size)</span><br><span class="line">	  : read (fp-&gt;_fileno, buf, size));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用**_IO_SYSREAD<strong>函数尝试从</strong>fp<strong>中读</strong>_IO_buf_end - _IO_buf_base<strong>即</strong>4K<strong>大小的数据到从</strong>_IO_buf_base<strong>开始的空间中，该函数的原形为虚表中的</strong>__read<strong>，对应</strong>_IO_file_read**函数</p>
<p>该函数再往下就是调用**__read()<strong>或</strong>__read_nocancel()<strong>直接进行系统调用进行读入，返回值为实际读取的大小，赋值给</strong>count<strong>。若正常读取成功，则会将</strong>_IO_read_end<strong>和</strong>offset<strong>字段增加</strong>count<strong>的大小，返回</strong>_IO_read_ptr<strong>的值。调用完该函数后，返回</strong>_IO_file_xsgetn<strong>函数，此时该文件中最多</strong>4K<strong>大小的数据已经被读入到了缓存缓冲区中，且</strong>_IO_read_base<strong>和</strong>_IO_read_end<strong>两个指针分别对应这想要读入的数据的起始位置和终止位置，相当于输入缓冲区，此时执行</strong>continue<strong>，重新开始循环，进入<code>if (want &lt;= have)</code>判断语句，直接调用</strong>memcpy<strong>函数，将数据从输入缓冲区中拷贝如目标变量中，</strong>_IO_read_ptr<strong>字段加上相应大小，此时所有数据全部读入，</strong>want<strong>赋值为</strong>0**，一路执行，最后跳出循环。</p>
<h5 id="执行系统调用读取数据-N-gt-4K"><a href="#执行系统调用读取数据-N-gt-4K" class="headerlink" title="执行系统调用读取数据  N&gt;4K"></a>执行系统调用读取数据  N&gt;4K</h5><p>若读取数据大小大于<strong>4K</strong>，则不会进入<code>if (fp-&gt;_IO_buf_base           &amp;&amp; want &lt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))</code>判断语句，而是继续往下执行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">_IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Try to maintain alignment: read a whole number of blocks.  */</span></span><br><span class="line">  count = want;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_size_t block_size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base;</span><br><span class="line">      <span class="keyword">if</span> (block_size &gt;= <span class="number">128</span>)</span><br><span class="line">	count -= want % block_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  count = _IO_SYSREAD (fp, s, count);</span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">	fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  s += count;</span><br><span class="line">  want -= count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>紧接着调用了**_IO_setg<strong>和</strong>_IO_setp<strong>两个函数，这两个函数在</strong>glibc/libio/libioP.h**中有宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_setg(fp, eb, g, eg)  ((fp)-&gt;_IO_read_base = (eb),\</span></span><br><span class="line"><span class="meta">	(fp)-&gt;_IO_read_ptr = (g), (fp)-&gt;_IO_read_end = (eg))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_setp(__fp, __p, __ep) \</span></span><br><span class="line"><span class="meta">       ((__fp)-&gt;_IO_write_base = (__fp)-&gt;_IO_write_ptr \</span></span><br><span class="line"><span class="meta">	= __p, (__fp)-&gt;_IO_write_end = (__ep))</span></span><br></pre></td></tr></table></figure>

<p>即实现了将<strong>FILE</strong>结构体中的<strong>read</strong>和<strong>write</strong>相关共<strong>6</strong>个指针均初始化为**_IO_buf_base<strong>的功能。随后<code>if (fp-&gt;_IO_buf_base)</code>的判断中，是将之前分配的缓冲区大小作为一个</strong>block_size<strong>，因为这条分支接下来会直接调用</strong>_IO_SYSREAD<strong>函数，将数据直接从文件流中读入变量中而不经过缓冲区，所以为了(优化性能？)，每次只读取</strong>block_size<strong>大小的数据，即</strong>4K<strong>。调用完</strong>_IO_SYSREAD<strong>后</strong>want<strong>会减去</strong>4K<strong>再次进行循环，直到最后小于</strong>4K<strong>的一部分，会和上面</strong>n &lt;= 4K**经历相同的过程，并退出循环。</p>
<h4 id="其他输入函数"><a href="#其他输入函数" class="headerlink" title="其他输入函数"></a>其他输入函数</h4><p>首先是scanf，其最终调用read函数时栈回溯如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">read</span><br><span class="line">_IO_new_file_underflow at fileops.c</span><br><span class="line">__GI__IO_default_uflow at genops.c</span><br><span class="line">_IO_vfscanf_internal at vfscanf.c</span><br><span class="line">__isoc99_scanf at  at isoc99_scanf.c</span><br><span class="line">main ()</span><br><span class="line">__libc_start_main</span><br></pre></td></tr></table></figure>

<p>可以看到scanf最终也是调用stdin的vtable中的<code>_IO_new_file_underflow</code>去调用read的。不过它并不是使用<code>_IO_file_xsgetn</code>，而是使用vtable中的<code>__uflow</code>，源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">_IO_default_uflow (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  int ch = _IO_UNDERFLOW (fp);</span><br><span class="line">  if (ch == EOF)</span><br><span class="line">    return EOF;</span><br><span class="line">  return *(unsigned char *) fp-&gt;_IO_read_ptr++;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_uflow)</span><br></pre></td></tr></table></figure>

<p><code>__uflow</code>函数基本上啥都没干直接就调用了<code>_IO_new_file_underflow</code>因此最终也是<code>_IO_new_file_underflow</code>实现的输入。</p>
<p>再看看<code>gets</code>函数，函数调用栈如下，与scanf基本一致：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">read</span><br><span class="line">__GI__IO_file_underflow</span><br><span class="line">__GI__IO_default_uflow</span><br><span class="line">gets</span><br><span class="line">main</span><br><span class="line"> __libc_start_main+240</span><br></pre></td></tr></table></figure>

<p>再试了试fscanf等，仍然是一样的，仍然是最终通过<code>_IO_new_file_underflow</code>实现的输入。虽然不能说全部的io输入都是通过<code>_IO_new_file_underflow</code>函数最终实现的输入，但是应该也可以说大部分是使用<code>_IO_new_file_underflow</code>函数实现的。</p>
<p>但是仍然有一个问题，由于<code>__uflow</code>直接就调用了<code>_IO_new_file_underflow</code>函数，那么输入缓冲区是在哪里建立的呢，为了找到这个问题的答案，我在程序进入到fscanf函数后又在<code>malloc</code>函数下了个断点，然后栈回溯：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">malloc</span><br><span class="line">__GI__IO_file_doallocate</span><br><span class="line">__GI__IO_doallocbuf</span><br><span class="line">__GI__IO_file_underflow</span><br><span class="line">__GI__IO_default_uflow</span><br><span class="line">__GI__IO_vfscanf</span><br><span class="line">__isoc99_fscanf</span><br><span class="line">main</span><br><span class="line">__libc_start_main</span><br></pre></td></tr></table></figure>

<p>原来是在<code>__GI__IO_file_underflow</code>分配的空间，回到上面看该函数的源码，确实有一段判断输入缓冲区如果为空则调用<code>__GI__IO_doallocbuf</code>函数建立输入缓冲区的代码，这就解释了<code>__GI__IO_file_underflow</code>第二步中为啥还会有个输入缓冲区判断的原因了，不得不感慨，代码写的真巧妙。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><code>fread</code>在执行系统调用read前对vtable里的哪些函数进行了调用，具体如下：</p>
<ul>
<li><code>_IO_sgetn</code>函数调用了vtable的<code>_IO_file_xsgetn</code>。</li>
<li><code>_IO_doallocbuf</code>函数调用了vtable的<code>_IO_file_doallocate</code>以初始化输入缓冲区。</li>
<li>vtable中的<code>_IO_file_doallocate</code>调用了vtable中的<code>__GI__IO_file_stat</code>以获取文件信息。</li>
<li><code>__underflow</code>函数调用了vtable中的<code>_IO_new_file_underflow</code>实现文件数据读取。</li>
<li>vtable中的<code>_IO_new_file_underflow</code>调用了vtable<code>__GI__IO_file_read</code>最终去执行系统调用read。</li>
</ul>
<p>先提一下，后续如果想通过IO FILE实现任意读的话，最关键的函数应是<code>_IO_new_file_underflow</code>，它里面有个标志位的判断，是后面构造利用需要注意的一个比较重要条件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  如果存在_IO_NO_READS标志，则直接返回</span></span><br><span class="line"> <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">   &#123;</span><br><span class="line">     fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">     __set_errno (EBADF);</span><br><span class="line">     <span class="keyword">return</span> EOF;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>首先要说明的是<code>fwrite</code>函数中涉及的几个IO FILE结构体里的指针：</p>
<table>
<thead>
<tr>
<th>指针</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td>_IO_buf_base</td>
<td align="center">输入输出缓冲区基地址</td>
</tr>
<tr>
<td>_IO_buf_end</td>
<td align="center">输入输出缓冲区结束地址</td>
</tr>
<tr>
<td>_IO_write_base</td>
<td align="center">输出缓冲区基地址</td>
</tr>
<tr>
<td>_IO_write_ptr</td>
<td align="center">输出缓冲区已使用的地址</td>
</tr>
<tr>
<td>_IO_write_end</td>
<td align="center">输出缓冲区结束地址</td>
</tr>
</tbody></table>
<p>其中<code>_IO_buf_base</code>和<code>_IO_buf_end</code>是缓冲区建立函数<code>_IO_doallocbuf</code>（fread详细描述过）会在里面建立输入输出缓冲区，并把基地址保存在<code>_IO_buf_base</code>中，结束地址保存在<code>_IO_buf_end</code>中。在建立里输入输出缓冲区后，如果缓冲区作为输出缓冲区使用，会将基址址给<code>_IO_write_base</code>，结束地址给<code>_IO_write_end</code>，同时<code>_IO_write_ptr</code>表示为已经使用的地址。即<code>_IO_write_base</code>到<code>_IO_write_ptr</code>之间的空间是已经使用的缓冲区，<code>_IO_write_ptr</code>到<code>_IO_write_end</code>之间为剩余的输出缓冲区。</p>
<p><code>fwrite</code>函数的整体流程图如下</p>
<p><img src="E:\draw_source\1557480731572.png" alt="1557480731572"></p>
<p>从图中可以看到<code>fwrite</code>的主要实现在<code>_IO_new_file_xsputn</code>中，整体流程包含四个部分：</p>
<ol>
<li>首先判断输出缓冲区还有多少剩余，如果有剩余则将目标输出数据拷贝至输出缓冲区。</li>
<li>如果输出缓冲区没有剩余（输出缓冲区未建立也是没有剩余）或输出缓冲区不够则调用<code>_IO_OVERFLOW</code>建立输出缓冲区或刷新输出缓冲区。</li>
<li>输出缓冲区刷新后判断剩余的目标输出数据是否超过块的size，如果超过块的size，则不通过输出缓冲区直接以块为单位，使用<code>new_do_write</code>输出目标数据。</li>
<li>如果按块输出数据后还剩下一点数据则调用<code>_IO_default_xsputn</code>将数据拷贝至输出缓冲区。</li>
</ol>
<p><code>fwrite</code>的函数原型是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fwrite(<span class="keyword">const</span> <span class="keyword">void</span>* buffer, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> count, FILE* stream);</span><br></pre></td></tr></table></figure>

<p>该函数共有<strong>4</strong>个参数，<strong>buffer</strong>代表存储要写入文件数据的首地址，<strong>size</strong>代表每个对象的大小，<strong>count</strong>代表对象的个数，<strong>stream</strong>代表文件流。即该函数实现了将<strong>buffer</strong>中<strong>size * count</strong>字节数据写入<strong>stream</strong>文件流的操作。</p>
<h4 id="IO-fwrite"><a href="#IO-fwrite" class="headerlink" title="_IO_fwrite"></a><code>_IO_fwrite</code></h4><p><strong>fwrite</strong>函数原形为**_IO_fwrite<strong>函数，该函数在</strong>glibc/libio/iofwrite.c**中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_fwrite (<span class="keyword">const</span> <span class="keyword">void</span> *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t request = size * count;</span><br><span class="line">  _IO_size_t written = <span class="number">0</span>;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (request == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span> || _IO_fwide (fp, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">    written = _IO_sputn (fp, (<span class="keyword">const</span> <span class="keyword">char</span> *) buf, request);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="comment">/* We have written all of the input in case the return value indicates</span></span><br><span class="line"><span class="comment">     this or EOF is returned.  The latter is a special case where we</span></span><br><span class="line"><span class="comment">     simply did not manage to flush the buffer.  But the data is in the</span></span><br><span class="line"><span class="comment">     buffer and therefore written as far as fwrite is concerned.  */</span></span><br><span class="line">  <span class="keyword">if</span> (written == request || written == EOF)</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> written / size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也是一样的调用了<strong>CHECK_FILE</strong>函数进行检查，以及在调用关键函数前后加锁与去锁。然后就调用了<code>_IO_sputn</code>函数，该函数是<code>vtable</code>中的<code>__xsputn</code> （<code>_IO_new_file_xsputn</code>）在文件/libio/fileops.c中，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> _IO_new_file_xsputn _IO_file_xsputn</span></span><br><span class="line"></span><br><span class="line">_IO_size_t</span><br><span class="line">_IO_new_file_xsputn (_IO_FILE *f, <span class="keyword">const</span> <span class="keyword">void</span> *data, _IO_size_t n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *s = (<span class="keyword">const</span> <span class="keyword">char</span> *) data;</span><br><span class="line">  _IO_size_t to_do = n;</span><br><span class="line">  <span class="keyword">int</span> must_flush = <span class="number">0</span>;</span><br><span class="line">  _IO_size_t count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* This is an optimized implementation.</span></span><br><span class="line"><span class="comment">     If the amount to be written straddles a block boundary</span></span><br><span class="line"><span class="comment">     (or the filebuf is unbuffered), use sys_write directly. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First figure out how much space is available in the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;</span><br><span class="line">      <span class="keyword">if</span> (count &gt;= n)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">const</span> <span class="keyword">char</span> *p;</span><br><span class="line">	  <span class="keyword">for</span> (p = s + n; p &gt; s; )</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		  count = p - s + <span class="number">1</span>;</span><br><span class="line">		  must_flush = <span class="number">1</span>;</span><br><span class="line">		  <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then fill the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; to_do)</span><br><span class="line">	count = to_do;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      <span class="built_in">memcpy</span> (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">      f-&gt;_IO_write_ptr += count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      s += count;</span><br><span class="line">      to_do -= count;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_size_t block_size, do_write;</span><br><span class="line">      <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)  </span><br><span class="line">	<span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">	   caller that everything has been written.  */</span></span><br><span class="line">	<span class="keyword">return</span> to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Try to maintain alignment: write a whole number of blocks.  */</span></span><br><span class="line">      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">      do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_write)</span><br><span class="line">	&#123;</span><br><span class="line">	  count = new_do_write (f, s, do_write);</span><br><span class="line">	  to_do -= count;</span><br><span class="line">	  <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">	    <span class="keyword">return</span> n - to_do;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now write out the remainder.  Normally, this will fit in the</span></span><br><span class="line"><span class="comment">	 buffer, but it&#x27;s somewhat messier for line-buffered files,</span></span><br><span class="line"><span class="comment">	 so we let _IO_default_xsputn handle the general case. */</span></span><br><span class="line">      <span class="keyword">if</span> (to_do)</span><br><span class="line">	to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如流程所示，源码分析分四个部分进行，与流程相对应，其中下面每部分刚开始的代码都是<code>_IO_new_file_xsputn</code>函数中的源码。</p>
<h4 id="将目标输出数据拷贝至输出缓冲区"><a href="#将目标输出数据拷贝至输出缓冲区" class="headerlink" title="将目标输出数据拷贝至输出缓冲区"></a>将目标输出数据拷贝至输出缓冲区</h4><p>第一部分所包含的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> <span class="keyword">char</span> *s = (<span class="keyword">const</span> <span class="keyword">char</span> *) data;</span><br><span class="line">  _IO_size_t to_do = n;</span><br><span class="line">  <span class="keyword">int</span> must_flush = <span class="number">0</span>;</span><br><span class="line">  _IO_size_t count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* This is an optimized implementation.</span></span><br><span class="line"><span class="comment">     If the amount to be written straddles a block boundary</span></span><br><span class="line"><span class="comment">     (or the filebuf is unbuffered), use sys_write directly. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First figure out how much space is available in the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;</span><br><span class="line">      <span class="keyword">if</span> (count &gt;= n)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">const</span> <span class="keyword">char</span> *p;</span><br><span class="line">	  <span class="keyword">for</span> (p = s + n; p &gt; s; )</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		  count = p - s + <span class="number">1</span>;</span><br><span class="line">		  must_flush = <span class="number">1</span>;</span><br><span class="line">		  <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//判断输出缓冲区还有多少空间</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then fill the buffer. */</span></span><br><span class="line"> <span class="comment">//如果输出缓冲区有空间，则先把数据拷贝至输出缓冲区</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; to_do)</span><br><span class="line">	count = to_do;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      <span class="built_in">memcpy</span> (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">      f-&gt;_IO_write_ptr += count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      <span class="comment">//计算是否还有目标输出数据剩余</span></span><br><span class="line">      s += count;</span><br><span class="line">      to_do -= count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该函数中有<strong>3</strong>个比较重要的变量，分别是<strong>s</strong>表示放有待写入数据变量的首地址，<strong>to_do</strong>表示还需要写入的字节数，<strong>must_flush</strong>表示是否需要刷新缓冲区。接下来也是按照刚从<strong>fopen</strong>初始化完的状态开始分析。此时各字段均为空，也没有**_IO_LINE_BUF、_IO_CURRENTLY_PUTTING**属性，不会进入<code>if ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</code>和  <code>else if (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</code>，也不会进入<code>if (count &gt; 0)</code>判断语句。</p>
<p>主要功能就是判断输出缓冲区还有多少空间，其中像<code>demo</code>中的程序所示的<code>f-&gt;_IO_write_end</code>以及<code>f-&gt;_IO_write_ptr</code>均为0，此时的输出缓冲区为0。所以<strong>count</strong>变量没有被赋值仍然为<strong>0</strong></p>
<p>另一部分则是如果输出缓冲区如果仍有剩余空间的话，则将目标输出数据拷贝至输出缓冲区，并计算在输出缓冲区填满后，是否仍然剩余目标输出数据。</p>
<h4 id="建立输出缓冲区或flush输出缓冲区"><a href="#建立输出缓冲区或flush输出缓冲区" class="headerlink" title="建立输出缓冲区或flush输出缓冲区"></a>建立输出缓冲区或flush输出缓冲区</h4><p>第二部分代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     _IO_size_t block_size, do_write;</span><br><span class="line">     <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">     <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)   <span class="comment">// 函数实现清空输出缓冲区或建立缓冲区的功能</span></span><br><span class="line"><span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">   caller that everything has been written.  */</span></span><br><span class="line"><span class="keyword">return</span> to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Try to maintain alignment: write a whole number of blocks.  */</span></span><br><span class="line">     block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base; <span class="comment">//检查输出数据是否是大块</span></span><br><span class="line">     do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>经过了上一步骤后，如果还有目标输出数据，表明输出缓冲区未建立或输出缓冲区已经满了，此时调用<code>_IO_OVERFLOW</code>函数，该函数功能主要是实现刷新输出缓冲区或建立缓冲区的功能，该函数是vtable函数中的<code>__overflow</code>（<code>_IO_new_file_overflow</code>），文件在<code>/libio/fileops.c</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> _IO_new_file_overflow _IO_file_overflow</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_new_file_overflow (_IO_FILE *f, <span class="keyword">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断标志位是否包含_IO_NO_WRITES</span></span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span> </span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">    <span class="comment">//判断输出缓冲区是否为空</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;  </span><br><span class="line">       <span class="comment">//分配输出缓冲区</span></span><br><span class="line">	  _IO_doallocbuf (f);</span><br><span class="line">	  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment">	 If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment">	 logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment">	 read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment">	 makes room for subsequent output.</span></span><br><span class="line"><span class="comment">	 Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment">	 alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">	  _IO_free_backup_area (f);</span><br><span class="line">	  f-&gt;_IO_read_base -= MIN (nbackup,</span><br><span class="line">				   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">	  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="comment">//初始化指针</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">	f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">	f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出输出缓冲区 </span></span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">			 f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">		      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">char</span>) ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数首先判断文件是否含有**_IO_NO_WRITES<strong>属性，即在</strong>fopen<strong>操作时是否为</strong>r<strong>只读选项，若是，则不会执行该函数直接返回。接着判断是否不含</strong>_IO_CURRENTLY_PUTTING<strong>属性或者</strong>_IO_write_base**字段为空，如果为空的话表明输出缓冲区尚未建立，就调用<code>_IO_doallocbuf</code>函数去分配输出缓冲区，<code>_IO_doallocbuf</code>函数源码在上一篇<code>fread</code>中已经分析过了就不跟过去了，它的功能是分配输入输出缓冲区并将指针<code>_IO_buf_base</code>和<code>_IO_buf_end</code>赋值。在执行完<code>_IO_doallocbuf</code>分配空间后调用<code>_IO_setg</code>宏，该宏的定义为如下，它将输入相关的缓冲区指针赋值为<code>_IO_buf_base</code>指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_setg(fp, eb, g, eg)  ((fp)-&gt;_IO_read_base = (eb),\</span></span><br><span class="line"><span class="meta">	(fp)-&gt;_IO_read_ptr = (g), (fp)-&gt;_IO_read_end = (eg))</span></span><br></pre></td></tr></table></figure>

<p>然后进行**_IO_in_backup<strong>的检测，并代码初始化其他相关指针，最主要的就是将<code>f-&gt;_IO_write_base</code>以及将<code>f-&gt;_IO_write_ptr</code>设置成<code>f-&gt;_IO_read_ptr</code>指针；将<code>f-&gt;_IO_write_end</code>赋值为<code>f-&gt;_IO_buf_end</code>指针，并给文件流加上</strong>_IO_CURRENTLY_PUTTING**属性。</p>
<p>由于在**_IO_new_file_xsputn<strong>调用该函数时的第二个参数，即函数中的</strong>ch<strong>变量为</strong>EOF<strong>，就执行<code>_IO_do_write</code>来调用系统调用<code>write</code>输出输出缓冲区，传入的</strong>3<strong>个参数分别为</strong>FILE<strong>结构体指针、</strong>_IO_write_base<strong>以及</strong>_IO_write_ptr - _IO_write_base = 0**。输出的内容为<code>f-&gt;_IO_write_ptr</code>到<code>f-&gt;_IO_write_base</code>之间的内容。跟进去该函数，函数在<code>/libio/fileops.c</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> _IO_new_do_write _IO_do_write</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_new_do_write (_IO_FILE *fp, <span class="keyword">const</span> <span class="keyword">char</span> *data, _IO_size_t to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (to_do == <span class="number">0</span></span><br><span class="line">	  || (_IO_size_t) new_do_write (fp, data, to_do) == to_do) ? <span class="number">0</span> : EOF;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_do_write, _IO_do_write)</span><br></pre></td></tr></table></figure>

<p>该函数调用了<code>new_do_write</code>，跟进去，函数在<code>/libio/fileops.c</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span></span></span><br><span class="line"><span class="function">_IO_size_t</span></span><br><span class="line"><span class="function"><span class="title">new_do_write</span> <span class="params">(_IO_FILE *fp, <span class="keyword">const</span> <span class="keyword">char</span> *data, _IO_size_t to_do)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _IO_size_t count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">    <span class="comment">//额外判断</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_off64_t new_pos</span><br><span class="line">	= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用函数输出输出缓冲区</span></span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//刷新设置缓冲区指针</span></span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">		       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">		       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先会判断是否具有**_IO_IS_APPENDING<strong>属性，即判断该文件是由</strong>a<strong>属性打开还是由</strong>w<strong>属性打开：若为</strong>w<strong>属性，则将</strong>_offset<strong>字段赋值为</strong>-1<strong>；若为</strong>a<strong>属性，则</strong>_offset<strong>字段不变，这正是写文件时覆盖和追加方式的体现。之后判断</strong>_IO_read_end<strong>与</strong>_IO_write_base<strong>相等，若不等则调用</strong>_IO_SYSSEEK**函数。对于本次调用的流程，这两个判断语句不会有太大的影响。</p>
<p>终于到了调用<code>_IO_SYSWRITE</code>的地方，进行一个判断，判断<code>fp-&gt;_IO_read_end</code>是否等于<code>fp-&gt;_IO_write_base</code>，如果不等的话，调用<code>_IO_SYSSEEK</code>去调整文件偏移，这个函数就不跟进去了，正常执行流程不会过去这里。</p>
<p>接着就调用<code>_IO_SYSWRITE</code>函数，该函数是vtable中的<code>__write</code>（<code>_IO_new_file_write</code>）函数，也是最终执行系统调用的地方，跟进去看，文件在<code>/libio/fileops.c</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> _IO_new_file_write _IO_file_write</span></span><br><span class="line"></span><br><span class="line">_IO_ssize_t</span><br><span class="line">_IO_new_file_write (_IO_FILE *f, <span class="keyword">const</span> <span class="keyword">void</span> *data, _IO_ssize_t n)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_ssize_t to_do = n;</span><br><span class="line">  <span class="keyword">while</span> (to_do &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 系统调用write输出</span></span><br><span class="line">      _IO_ssize_t count = (__builtin_expect (f-&gt;_flags2</span><br><span class="line">					     &amp; _IO_FLAGS2_NOTCANCEL, <span class="number">0</span>)</span><br><span class="line">			   ? write_not_cancel (f-&gt;_fileno, data, to_do)</span><br><span class="line">			   : write (f-&gt;_fileno, data, to_do));</span><br><span class="line">      <span class="keyword">if</span> (count &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">	  <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      to_do -= count;</span><br><span class="line">      data = (<span class="keyword">void</span> *) ((<span class="keyword">char</span> *) data + count);</span><br><span class="line">    &#125;</span><br><span class="line">  n -= to_do;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_offset &gt;= <span class="number">0</span>)</span><br><span class="line">    f-&gt;_offset += n;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行完<code>_IO_SYSWRITE</code>函数后，通过调用**__write<strong>函数或</strong>__write_nocancel<strong>函数进行系统调用，将</strong>to_do<strong>长度的数据从</strong>data<strong>中写入文件中。调用完</strong>_IO_SYSWRITE<strong>函数后，若读入成功，即</strong>count<strong>不为</strong>0<strong>，在之后会调用</strong>_IO_adjust_column<strong>函数去更新</strong>FILE<strong>结构体中的</strong>_cur_column<strong>字段，该字段代表</strong>（<strong>文件的行数</strong>+1)<strong>，该函数在</strong>glibc/libio/genops.c**中定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span></span><br><span class="line">_IO_adjust_column (<span class="keyword">unsigned</span> start, <span class="keyword">const</span> <span class="keyword">char</span> *line, <span class="keyword">int</span> count)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *ptr = line + count;</span><br><span class="line">  <span class="keyword">while</span> (ptr &gt; line)</span><br><span class="line">    <span class="keyword">if</span> (*--ptr == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> line + count - ptr - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> start + count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数通过判断上面通过**_IO_SYSWRITE<strong>函数写入的数据中含有多少</strong>\n<strong>字符来确定文件中增加了多少行。调用完</strong>_IO_adjust_column<strong>后返回到</strong>new_do_write<strong>函数，之后会调用</strong>_IO_setg<strong>函数以及各种赋值操作将文件流中</strong>read、write<strong>相关</strong>6<strong>个字段都赋值为</strong>_IO_buf_base**，类似于初始化的操作。然后回到<code>new_do_write</code>函数，刷新设置缓冲区指针并返回。</p>
<h4 id="以块为单位直接输出数据"><a href="#以块为单位直接输出数据" class="headerlink" title="以块为单位直接输出数据"></a>以块为单位直接输出数据</h4><p>经历了缓冲区建立以及刷新缓冲区，程序返回到<code>_IO_new_file_xsputn</code>函数中，进入到如下代码功能块：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">//检查输出数据是否是大块</span></span><br><span class="line">     block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">     do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (do_write)</span><br><span class="line">&#123;  </span><br><span class="line">     <span class="comment">// 如果是大块的话则不使用输出缓冲区而直接输出。    </span></span><br><span class="line">  count = new_do_write (f, s, do_write);</span><br><span class="line">  to_do -= count;</span><br><span class="line">  <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">    <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>运行到此处，此时已经经过了<code>_IO_OVERFLOW</code>函数（对输出缓冲区进行了初始化或者刷新），也就是说此时的IO FILE缓冲区指针的状态是处于刷新的初始化状态，输出缓冲区中也没有数据。</p>
<p>上面这部分代码检查剩余目标输出数据大小，如果超过输入缓冲区<code>f-&gt;_IO_buf_end - f-&gt;_IO_buf_base</code>的大小，则为了提高效率，不再使用输出缓冲区，而是以块为基本单位直接将缓冲区调用<code>new_do_write</code>输出。<code>new_do_write</code>函数在上面已经详细描述过，就是输出，并刷新指针设置。</p>
<h4 id="剩余目标输出数据放入输出缓冲区中"><a href="#剩余目标输出数据放入输出缓冲区中" class="headerlink" title="剩余目标输出数据放入输出缓冲区中"></a>剩余目标输出数据放入输出缓冲区中</h4><p>在以大块为基本单位把数据直接输出后可能还剩余小块数据，或者要写入的数据小于<strong>4K</strong>，IO采用的策略则是将剩余目标输出数据放入到输出缓冲区里面，相关源码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Now write out the remainder.  Normally, this will fit in the</span></span><br><span class="line"><span class="comment"> buffer, but it&#x27;s somewhat messier for line-buffered files,</span></span><br><span class="line"><span class="comment"> so we let _IO_default_xsputn handle the general case. */</span>    </span><br><span class="line">    <span class="comment">//剩余的数据拷贝至输出缓冲区</span></span><br><span class="line">     <span class="keyword">if</span> (to_do)</span><br><span class="line">to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="keyword">return</span> n - to_do;</span><br></pre></td></tr></table></figure>

<p>程序调用<code>_IO_default_xsputn</code>函数对剩下的<code>s+do_write</code>数据进行操作，跟进去该函数，在<code>/libio/genops.c</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_default_xsputn (_IO_FILE *f, <span class="keyword">const</span> <span class="keyword">void</span> *data, _IO_size_t n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *s = (<span class="keyword">char</span> *) data;</span><br><span class="line">  _IO_size_t more = n;</span><br><span class="line">  <span class="keyword">if</span> (more &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Space available. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_size_t count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">	  <span class="keyword">if</span> (count &gt; more)</span><br><span class="line">	    count = more;</span><br><span class="line">	  <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">	    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line">          <span class="comment">// 输出长度大于20，则调用memcpy拷贝</span></span><br><span class="line">	      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	      <span class="built_in">memcpy</span> (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">	      f-&gt;_IO_write_ptr += count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	      s += count;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="keyword">else</span> <span class="keyword">if</span> (count)</span><br><span class="line">	    &#123;</span><br><span class="line">          <span class="comment">// 小于20则直接赋值</span></span><br><span class="line">	      <span class="keyword">char</span> *p = f-&gt;_IO_write_ptr;</span><br><span class="line">	      _IO_ssize_t i;</span><br><span class="line">	      <span class="keyword">for</span> (i = count; --i &gt;= <span class="number">0</span>; )</span><br><span class="line">		*p++ = *s++;</span><br><span class="line">	      f-&gt;_IO_write_ptr = p;</span><br><span class="line">	    &#125;</span><br><span class="line">	  more -= count;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="comment">// 如果输出缓冲区为空，则调用`_IO_OVERFLOW`直接输出。</span></span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || _IO_OVERFLOW (f, (<span class="keyword">unsigned</span> <span class="keyword">char</span>) *s++) == EOF)</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">      more--;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_xsputn)</span><br><span class="line"></span><br><span class="line">_IO_size_t</span><br><span class="line">_IO_sgetn (_IO_FILE *fp, <span class="keyword">void</span> *data, _IO_size_t n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* FIXME handle putback buffer here! */</span></span><br><span class="line">  <span class="keyword">return</span> _IO_XSGETN (fp, data, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到函数最主要的作用就是将剩余的目标输出数据拷贝到输出缓冲区里。为了性能优化，一种是当要拷贝的数据大于<strong>20</strong>字节时，会直接调用**__mempcpy<strong>进行拷贝，如果小于等于</strong>20<strong>，则用</strong>for<strong>循环逐字节进行拷贝，若缓冲区大小不够，则会调用</strong>_IO_OVERFLOW**刷新缓冲区。</p>
<p>值得注意的是，**_IO_default_xsputn<strong>函数仅仅实现了将数据从变量中拷贝到了从</strong>_IO_write_base<strong>到</strong>_IO_write_ptr**为止的缓冲区中，并没有写入文件。</p>
<p>根据源码我们也知道，demo程序中，最终会进入到<code>_IO_default_xsputn</code>中，并且把数据拷贝至输出缓冲区里，</p>
<h4 id="其他输出函数"><a href="#其他输出函数" class="headerlink" title="其他输出函数"></a>其他输出函数</h4><p><code>fwrite</code>分析完了，知道它最主要的就是通过vtable函数里面的<code>_IO_new_file_xsputn</code>实现功能，且最终的建立以及刷新输出缓冲区是在<code>_IO_new_file_overflow</code>函数里面，最终执行系统调用write对数据进行输出是在<code>new_do_write</code>函数中。</p>
<p>下面来看一下其他输出函数的栈回溯的情况，应该也都差不多，对于下面的函数，断点下在<code>write</code>函数，然后查看栈回溯。</p>
<p>首先是printf函数，它的栈回溯为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">write</span><br><span class="line">_IO_new_file_write</span><br><span class="line">new_do_write+<span class="number">51</span></span><br><span class="line">__GI__IO_do_write</span><br><span class="line">__GI__IO_file_xsputn</span><br><span class="line"><span class="built_in">vfprintf</span></span><br><span class="line"><span class="built_in">printf</span></span><br><span class="line">main</span><br><span class="line">__libc_start_main</span><br></pre></td></tr></table></figure>

<p>也是调用<code>_IO_new_file_overflow</code>函数进行的实现。但是<code>printf</code>函数里面情况其实也还挺复杂的，篇幅的限制，就不细说了，其他的输出函数应该也差不多。</p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p><code>fwrite</code>的时候把数据拷贝到了输出缓冲区，并没有调用<code>write</code>函数，那什么时候才写到文件里去呢。答案是main函数返回的时候的<code> _IO_cleanup</code>中调用的<code>_IO_flush_all_lockp</code>函数，这个留在后面IO FILE利用的时候再详细说明。</p>
<p>结束之前仍然总结下<code>fwrite</code>在执行系统调用write前对vtable里的哪些函数进行了调用，具体如下：</p>
<ul>
<li><code>_IO_fwrite</code>函数调用了vtable的<code>_IO_new_file_xsputn</code>。</li>
<li><code>_IO_new_file_xsputn</code>函数调用了vtable中的<code>_IO_new_file_overflow</code>实现缓冲区的建立以及刷新缓冲区。</li>
<li>vtable中的<code>_IO_new_file_overflow</code>函数调用了vtable的<code>_IO_file_doallocate</code>以初始化输入缓冲区。</li>
<li>vtable中的<code>_IO_file_doallocate</code>调用了vtable中的<code>__GI__IO_file_stat</code>以获取文件信息。</li>
<li><code>new_do_write</code>中的<code>_IO_SYSWRITE</code>调用了vtable<code>_IO_new_file_write</code>最终去执行系统调用write。</li>
</ul>
<p>同时，后续如果想通过IO FILE输出缓冲区实现任意读写的话，最关键的函数应是<code>_IO_new_file_overflow</code>，它里面有个标志位的判断，是后面构造利用需要注意的一个比较重要条件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断标志位是否包含_IO_NO_WRITES</span></span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span> </span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


    </article>
    <!-- license -->
    
    <!-- paginator -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href="/2022/07/02/ret2dlresolve_x64/" title="ret2dlresolve_x64">
                    <div class="nextTitle">ret2dlresolve_x64</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href="/2022/05/07/%E9%9D%9E%E6%A0%88%E4%B8%8A%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/" title="非栈上的格式化字符串漏洞">
                    <div class="prevTitle">非栈上的格式化字符串漏洞</div>
                </a>
            
        </li>
    </ul>
    <!-- comment -->
    
        <div class="post-comment">
            <!-- 来必力 City 版安装代码 -->


            

            

            

            <!-- utteranc评论 -->


            <!-- partial('_partial/comment/changyan') -->
            <!--PC版-->


            
            

        </div>
    
    <!-- timeliness note -->
    <!-- idea from: https://hexo.fluid-dev.com/posts/hexo-injector/#%E6%96%87%E7%AB%A0%E6%97%B6%E6%95%88%E6%80%A7%E6%8F%90%E7%A4%BA -->
    
    <!-- Mathjax -->
    
</main>

                <!-- profile -->
                
            </div>
            <footer class="footer footer-unloaded">
    <!-- social  -->
    
        <div class="social">
            
    
        
            
                <a href="mailto:2811745785@qq.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/wysyrg" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    


        </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- website approve for Chinese user -->
    
    <!-- 不蒜子  -->
    
        <div class="busuanzi-container">
            
             
                <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
            
        </div>
    	
</footer>

        </div>
        <!-- toc -->
        
            <div class="toc-wrapper toc-wrapper-loding" style=







    top:50vh;

>
                <div class="toc-catalog">
                    <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
                </div>
                <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#IO-FILE"><span class="toc-number">1.</span> <span class="toc-text">_IO_FILE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO-FILE-1"><span class="toc-number">2.</span> <span class="toc-text">_IO_FILE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FILE%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.</span> <span class="toc-text">FILE介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-new-fopen-gt-fopen-internal"><span class="toc-number">2.1.1.</span> <span class="toc-text">_IO_new_fopen-&gt;__fopen_internal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-new-fopen-gt-fopen-internal-gt-IO-no-init"><span class="toc-number">2.1.2.</span> <span class="toc-text">_IO_new_fopen-&gt;__fopen_internal-&gt;_IO_no_init</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-new-fopen-gt-fopen-internal-gt-IO-no-init-gt-IO-old-init"><span class="toc-number">2.1.3.</span> <span class="toc-text">_IO_new_fopen-&gt;__fopen_internal-&gt;_IO_no_init-&gt;_IO_old_init</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-new-fopen-gt-fopen-internal-gt-IO-new-file-init-internal"><span class="toc-number">2.1.4.</span> <span class="toc-text">_IO_new_fopen-&gt;__fopen_internal-&gt;_IO_new_file_init_internal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-new-fopen-gt-fopen-internal-gt-IO-new-file-init-internal-gt-IO-link-in"><span class="toc-number">2.1.5.</span> <span class="toc-text">_IO_new_fopen-&gt;__fopen_internal-&gt;_IO_new_file_init_internal -&gt;_IO_link_in</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-new-fopen-gt-fopen-internal-gt-IO-new-file-fopen"><span class="toc-number">2.1.6.</span> <span class="toc-text">_IO_new_fopen-&gt;__fopen_internal-&gt;_IO_new_file_fopen</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-new-fopen-gt-fopen-internal-gt-IO-new-file-fopen-gt-IO-file-is-open"><span class="toc-number">2.1.7.</span> <span class="toc-text">_IO_new_fopen-&gt;__fopen_internal-&gt;_IO_new_file_fopen-&gt;_IO_file_is_open</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-new-fopen-gt-fopen-internal-gt-IO-new-file-fopen-gt-IO-file-open"><span class="toc-number">2.1.8.</span> <span class="toc-text">_IO_new_fopen-&gt;__fopen_internal-&gt;_IO_new_file_fopen-&gt;_IO_file_open</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-new-fopen-gt-fopen-internal-gt-IO-new-file-fopen-gt-IO-file-open-gt-IO-link-in"><span class="toc-number">2.1.9.</span> <span class="toc-text">_IO_new_fopen-&gt;__fopen_internal-&gt;_IO_new_file_fopen-&gt;_IO_file_open-&gt;_IO_link_in</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E6%B5%81%E7%A8%8B%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">2.1.10.</span> <span class="toc-text">总结流程如下：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fcolse"><span class="toc-number">2.2.</span> <span class="toc-text">fcolse</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-new-fclose"><span class="toc-number">2.2.2.</span> <span class="toc-text">_IO_new_fclose</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-new-fclose-gt-IO-un-link"><span class="toc-number">2.2.3.</span> <span class="toc-text">_IO_new_fclose-&gt;_IO_un_link</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-new-fclose-gt-IO-new-file-close-it"><span class="toc-number">2.2.4.</span> <span class="toc-text">_IO_new_fclose-&gt;_IO_new_file_close_it </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-new-fclose-gt-IO-new-file-close-it-gt-IO-file-close"><span class="toc-number">2.2.5.</span> <span class="toc-text">_IO_new_fclose-&gt;_IO_new_file_close_it -&gt;_IO_file_close</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-new-fclose-gt-IO-FINISH"><span class="toc-number">2.2.6.</span> <span class="toc-text">_IO_new_fclose-&gt;_IO_FINISH</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-new-fclose-gt-IO-FINISH-gt-IO-default-finish"><span class="toc-number">2.2.7.</span> <span class="toc-text">_IO_new_fclose-&gt;_IO_FINISH-&gt;_IO_default_finish</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.2.8.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fread"><span class="toc-number">2.3.</span> <span class="toc-text">fread</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-fread"><span class="toc-number">2.3.1.</span> <span class="toc-text">_IO_fread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-fread-gt-CHECK-FILE"><span class="toc-number">2.3.2.</span> <span class="toc-text">_IO_fread-&gt;CHECK_FILE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-fread-gt-IO-file-xsgetn"><span class="toc-number">2.3.3.</span> <span class="toc-text">_IO_fread-&gt;_IO_file_xsgetn</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">初始化缓冲区</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#IO-fread-gt-IO-file-xsgetn-gt-IO-doallocbuf"><span class="toc-number">2.3.3.1.1.</span> <span class="toc-text">_IO_fread-&gt;_IO_file_xsgetn-&gt;_IO_doallocbuf</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#IO-fread-gt-IO-file-xsgetn-gt-IO-doallocbuf-1"><span class="toc-number">2.3.3.1.2.</span> <span class="toc-text">_IO_fread-&gt;_IO_file_xsgetn-&gt;_IO_doallocbuf</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#IO-fread-gt-IO-file-xsgetn-gt-IO-doallocbuf-gt-IO-setb"><span class="toc-number">2.3.3.1.3.</span> <span class="toc-text">_IO_fread-&gt;_IO_file_xsgetn-&gt;_IO_doallocbuf-&gt;_IO_setb</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E8%BE%93%E5%85%A5%E7%BC%93%E5%86%B2%E5%8C%BA%E6%95%B0%E6%8D%AE"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">拷贝输入缓冲区数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE-N-lt-4K"><span class="toc-number">2.3.3.3.</span> <span class="toc-text">执行系统调用读取数据  N&lt;&#x3D;4K</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#IO-fread-gt-IO-file-xsgetn-gt-underflow"><span class="toc-number">2.3.3.3.1.</span> <span class="toc-text">_IO_fread-&gt;_IO_file_xsgetn-&gt;__underflow</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#IO-fread-gt-IO-file-xsgetn-gt-underflow-gt-IO-new-file-underflow"><span class="toc-number">2.3.3.3.2.</span> <span class="toc-text">_IO_fread-&gt;_IO_file_xsgetn-&gt;__underflow-&gt;_IO_new_file_underflow</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE-N-gt-4K"><span class="toc-number">2.3.3.4.</span> <span class="toc-text">执行系统调用读取数据  N&gt;4K</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%BE%93%E5%85%A5%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.4.</span> <span class="toc-text">其他输入函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">2.3.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fwrite"><span class="toc-number">2.4.</span> <span class="toc-text">fwrite</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">2.4.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-fwrite"><span class="toc-number">2.4.2.</span> <span class="toc-text">_IO_fwrite</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E7%9B%AE%E6%A0%87%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE%E6%8B%B7%E8%B4%9D%E8%87%B3%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">2.4.3.</span> <span class="toc-text">将目标输出数据拷贝至输出缓冲区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA%E6%88%96flush%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">2.4.4.</span> <span class="toc-text">建立输出缓冲区或flush输出缓冲区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E5%9D%97%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%9B%B4%E6%8E%A5%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE"><span class="toc-number">2.4.5.</span> <span class="toc-text">以块为单位直接输出数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%A9%E4%BD%99%E7%9B%AE%E6%A0%87%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE%E6%94%BE%E5%85%A5%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%AD"><span class="toc-number">2.4.6.</span> <span class="toc-text">剩余目标输出数据放入输出缓冲区中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.7.</span> <span class="toc-text">其他输出函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">2.4.8.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol>
            </div>
        
        <!-- sidebar -->
        <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
        <div class="sidebar-panel-archives">
    <!-- 在 ejs 中将 archive 按照时间排序 -->
    
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 36
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
        
            
            
            <div class="archive-year"> 2022 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/06</span>
            <a class="archive-post-title" href="/2022/07/06/srop%E4%BE%8B%E9%A2%98/">srop例题</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/03</span>
            <a class="archive-post-title" href="/2022/07/03/0ctf_2018_babystack/">[Untitled Post]</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/02</span>
            <a class="archive-post-title" href="/2022/07/02/ret2dlresolve_x64/">ret2dlresolve_x64</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/29</span>
            <a class="archive-post-title" href="/2022/04/29/dl-runtime-resolve/">ret2dl-resolve</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/24</span>
            <a class="archive-post-title" href="/2022/04/24/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/">延迟绑定</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/22</span>
            <a class="archive-post-title" href="/2022/04/22/houseofAtum/">BCTF2018 House of Atum</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/19</span>
            <a class="archive-post-title" href="/2022/04/19/IDA%20pro/">IDA pro创建结构体</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span>
            <a class="archive-post-title" href="/2022/01/08/ciscn_2019/">ciscn</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> Invalid date </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">Invalid date</span>
            <a class="archive-post-title" href="/2022/05/14/IO_FILE/">_IO_FILE</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2022 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/20</span>
            <a class="archive-post-title" href="/2022/04/20/gundam/">HITBCTF2018 gundam</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/18</span>
            <a class="archive-post-title" href="/2022/04/18/examination/">examination</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/17</span>
            <a class="archive-post-title" href="/2022/04/17/LCTF2018%20PWN%20easy_heap/">LCTF2018 easy_heap</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/08</span>
            <a class="archive-post-title" href="/2022/04/08/tcache/">tcache</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/07</span>
            <a class="archive-post-title" href="/2022/04/07/libc-2.26/">libc 2.26</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/07</span>
            <a class="archive-post-title" href="/2022/04/07/house-of-storm/">house of storm</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/04</span>
            <a class="archive-post-title" href="/2022/04/04/%E5%B3%BB%E6%9E%81pwn/">峻极pwn</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">03/19</span>
            <a class="archive-post-title" href="/2022/03/19/stack%20pivoting/">stack pivoting</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/26</span>
            <a class="archive-post-title" href="/2022/02/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/16</span>
            <a class="archive-post-title" href="/2022/01/16/large%20bin%20attack/">large bin attack</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/15</span>
            <a class="archive-post-title" href="/2022/01/15/magicheap/">magicheap</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/15</span>
            <a class="archive-post-title" href="/2022/01/15/unsorted%20bin%20attack/">unsorted bin attack</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/13</span>
            <a class="archive-post-title" href="/2022/01/13/pwn200/">pwn200</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/12</span>
            <a class="archive-post-title" href="/2022/01/12/write%20some%20paper/">write some paper</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/09</span>
            <a class="archive-post-title" href="/2022/01/09/fastbin_attack/">fastbin_attack</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span>
            <a class="archive-post-title" href="/2022/01/08/overlapping%20chunks/">overlapping chunks</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span>
            <a class="archive-post-title" href="/2022/01/08/gdb%E8%B0%83%E8%AF%95/">gdb的使用</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span>
            <a class="archive-post-title" href="/2022/01/08/csaw/">csaw部分题解</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span>
            <a class="archive-post-title" href="/2022/01/08/secretHolder_hitcon_2016/">secretHolder_hitcon_2016</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span>
            <a class="archive-post-title" href="/2022/01/08/unsafe_unlink/">unsafe_unlink</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span>
            <a class="archive-post-title" href="/2022/01/08/kernel_pwn%E7%8E%AF%E5%A2%83/">kernel pwn环境搭建</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span>
            <a class="archive-post-title" href="/2022/01/08/lab1%20%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/">lab1实验报告</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span>
            <a class="archive-post-title" href="/2022/01/08/lab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/">lab2 实验报告</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span>
            <a class="archive-post-title" href="/2022/01/08/pwnable%E5%88%B7%E9%A2%98/">pwnable刷题</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span>
            <a class="archive-post-title" href="/2022/01/08/off-by-one/">off-by-one</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> Invalid date </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">Invalid date</span>
            <a class="archive-post-title" href="/2022/04/25/srop/">srop</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> Invalid date </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">Invalid date</span>
            <a class="archive-post-title" href="/2022/05/07/%E9%9D%9E%E6%A0%88%E4%B8%8A%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/">非栈上的格式化字符串漏洞</a>
        </li>
    
    </div>
</div>

        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
        
            <span class="sidebar-tag-name" data-tags="tcache">
                <span class="iconfont-archer">&#xe606;</span>
                tcache
            </span>
        
            <span class="sidebar-tag-name" data-tags="os">
                <span class="iconfont-archer">&#xe606;</span>
                os
            </span>
        
            <span class="sidebar-tag-name" data-tags="unsorted bin attack">
                <span class="iconfont-archer">&#xe606;</span>
                unsorted bin attack
            </span>
        
            <span class="sidebar-tag-name" data-tags="pwn">
                <span class="iconfont-archer">&#xe606;</span>
                pwn
            </span>
        
            <span class="sidebar-tag-name" data-tags="house of spirit">
                <span class="iconfont-archer">&#xe606;</span>
                house of spirit
            </span>
        
            <span class="sidebar-tag-name" data-tags="fastbin doule free">
                <span class="iconfont-archer">&#xe606;</span>
                fastbin doule free
            </span>
        
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
        缺失模块，请参考主题文档进行安装配置：https://github.com/fi3ework/hexo-theme-archer#%E5%AE%89%E8%A3%85%E4%B8%BB%E9%A2%98
    </div> 
    <div class="sidebar-tags-list"></div>
</div>

        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
        <span class="sidebar-category-name" data-categories="Diary">
            <span class="iconfont-archer">&#xe60a;</span>
            Diary
        </span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>

    </div>
</div>

        <!-- site-meta -->
        <script>
    var siteMeta = {
        root: "/",
        author: "John Doe"
    }
</script>

        <!-- import experimental options here -->
        <!-- Custom Font -->


        <!-- main func -->
        <script src="/scripts/main.js?v=20210823"></script>
        <!-- dark mode -->
        <script src="/scripts/dark.js?v=20210823"></script>
        <!-- fancybox -->
        <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" defer></script>
        <!-- algolia -->
        
        <!-- busuanzi -->
        
            <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
        
        <!-- CNZZ -->
        
        <!-- async load share.js -->
        
            <script src="/scripts/share.js?v=20210823" async></script>
        
        <!-- mermaid -->
        
    </body>
</html>
